<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <title>Web-selainohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="css/sh_style.css">
        <link rel="stylesheet" href="css/weso.css">
        <script src="js/jquery.js"></script>
        <script src="js/mustache.min.js"></script>
        <script src="js/material.js"></script>


      <script type="text/javascript" src="js/sh_main.js"></script>
      <script type="text/javascript" src="js/sh_java.js"></script>
      <script type="text/javascript" src="js/sh_xml.js"></script>
      <script type="text/javascript" src="js/sh_html.js"></script>
      <script type="text/javascript" src="js/sh_css.js"></script>
      <script type="text/javascript" src="js/sh_javascript_dom.js"></script>
      <script>
        jQuery(document).ready(function() {
          Material.createContentList();
          Material.createExerciseList();
          sh_highlightDocument();
        });
      </script>
    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <a href="http://www.cs.helsinki.fi/"><img src="img/header_tktl.png" alt="CS Dept. Univ. Helsinki"></a>
            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li class="active">
                        <a href="#">Web-selainohjelmointi</a>
                    </li>
                    <li>
                        <a href="#viikko1">Viikko 1</a>
                    </li>
                    <li>
                        <a href="#viikko2">Viikko 2</a>
                    </li>
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
                </ul>
            </nav>
        </header>
        <article>
          <section>
            <header>
              <h1 data-week-id="1">Lukijalle</h1>
            </header>
                
	    <p>Tämä materiaali on tarkoitettu Helsingin yliopiston tietojenkäsittelytieteen laitoksen kevään 2015 kurssille web-selainohjelmointi. Materiaalin kirjoittajat ovat Kalle Ilves ja Arto Vihavainen, ja se pohjautuu <a href="http://www.cs.helsinki.fi/group/java/s12-weso/" target="_blank">syksyn 2012 materiaaliin</a>. Materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä, joten voit käyttää ja levittää sitä vapaasti, kunhan alkuperäisten tekijöiden nimiä ei poisteta. Jos teet muutoksia materiaaliin ja haluat levittää muunneltua versiota, se täytyy lisensoida samanlaisella vapaalla lisenssillä. Materiaalien käyttö kaupalliseen tarkoitukseen on ilman erillistä lupaa kielletty.</p>

	    <p>Lue materiaalia siten, että teet samalla itse kaikki lukemasi esimerkit. Esimerkkeihin kannattaa tehdä pieniä muutoksia ja tarkkailla, miten muutokset vaikuttavat ohjelman toimintaan. Äkkiseltään voisi luulla, että esimerkkien tekeminen ja muokkaaminen hidastaa opiskelua. Tämä ei kuitenkaan pidä ollenkaan paikkansa. Oppiminen perustuu oleellisesti aktiiviseen tekemiseen ja rutiinin kasvattamiseen. Esimerkkien ja erityisesti omien kokeilujen tekeminen on parhaita tapoja sisäistää luettua.</p>

            <p>Pyri tekemään tai ainakin yrittämään tehtäviä sitä mukaa kuin luet tekstiä. Jos et osaa heti tehdä jotain tehtävää, älä masennu, sillä saat ohjausaikoina neuvoja tehtävien tekemiseen.</p>

            <p>Tekstiä ei ole tarkoitettu vain kertaalleen luettavaksi. Joudut varmasti myöhemmin palaamaan aiemmin lukemiisi kohtiin tai aiemmin tekemiisi tehtäviin. Tämä materiaali ei sisällä kaikkea oleellista web-selainohjelmointiin liittyvää. Tällä hetkellä ei ole oikeastaan yhtäkään yksittäistä kirjaa tai yksittäistä verkkomateriaalia josta löytyisi kaikki oleellinen. Joudut kurssin aikana ja myöhemmin etsimään tietoa myös omatoimisesti. Harjoitukset ja materiaali sisältävät jo jonkin verran ohjeita, mistä suunnista tietoa kannattaa lähteä hakemaan.</p>

            <p>Kun materiaalista löytyy esimerkiksi kirjoitusvirheitä tai parannettavaa, korjaa se :) -- materiaali on githubissa osoitteessa <a href="https://github.com/web-selainohjelmointi/web-selainohjelmointi.github.io" target="_blank">https://github.com/web-selainohjelmointi/web-selainohjelmointi.github.io</a>.</p>


            <div style="display: table">
              <div style="display: table-cell">
                <h2>Sisältö</h2>
                <div id="materiaali-sisalto"></div>
              </div>
              <div style="display: table-cell; padding-left: 35px">
                <h2>Tehtävät</h2>
                <div id="tehtava-sisalto"></div>
              </div>
            </div>
          </section>

          <section class="week">
            <header>
              <a name="viikko1"></a>
              <h1 data-week-id="1">Viikko 1</h1>
            </header>


	    <h2>Tools of the trade</h2>

	    <p>Käydään läpi pikaisesti oleellisia työkaluja.</p>
	    
	    <h3>Web-selainten tarjoamat kehittäjien työkalut</h3>
    
	    <p>Ohjelmien debuggaaminen on oleellinen taito. Selainohjelmistot pyörivät selaimessa, joten luonnollinen paikka niiden debuggaamiseen on selaimessa. Esimerkiksi google chrome ja mozilla firefox tarjoavat debuggausympäristöt, joilla voi tutkia sivuja. Debuggausympäristöt aukeavat yleensä nappia f12-painamalla. Oleellisin osio lienee konsoli, mistä näkee sivuihin liittyvät virheviestit sekä pääsee esimerkiksi tarkastelemaan sivun rakennetta.</p>
	    
	    <p>Tutustu Chrome Developer Toolseihin osoitteessa <a href="https://developer.chrome.com/devtools/" target="_blank">https://developers.google.com/chrome-developer-tools</a> -- lisäämme materiaaliin lisää linkkejä oleellisiin kohtiin.</p>


	    <!--
		<p>Omiin sovelluksiin voi myös lisätä debuggauskomentoja. Esimerkiksi komento <code>console.log("viesti");</code> osana JavaScript-kutsua lisää konsoliin viestin "viesti". Sovelluksen debuggaus viestien avulla on hyvä aloituskohta rikkinäisten sovellusten korjaamiselle..</p>
		-->
	    
	    
	    <h3>NetBeans</h3>
	    
	    <p>Kurssilla käytetään oletuksena NetBeans-ohjelmointiympäristöä, jonka uudet versiot tukevat myös selainohjelmistojen kehitystyötä. Laitoksen koneille on asennettu NetBeansin versio 8.x, joka tarjoaa kurssilla hyödyntämiämme välineitä. Kurssin tehtävät palautetaan NetBeansissa toimivan TMC:n kautta -- jos et halua käyttää NetBeansia, tehtävät voi palauttaa myös TMC:n webbisivuilta.</p>

	    <p>Huom! Toisin kuin kursseilla joihin olet tottunut, tällä kurssilla TMC <em>ei</em> tarkasta tehtävien oikeellisuutta. Tehtävän palauttaminen tarkoittaa että olet tarkastanut että tehtävä on toimii tehtävänannossa halutulla tavalla.</p>

	    <div class="tehtavat">
	      <NEXTWEEK></NEXTWEEK>

	      <h3>Hello World</h3>

	      <p>Huom! Tässä kurssiversiossa TMC <em>ei</em> tarkasta tehtävien oikeellisuutta. Palauttamalla tämän tehtävän ja myöhempiä tehtäviä <strong><em>vakuutat</em></strong> että tämä ja jatkossa palauttamasi tehtävät ovat parhaan ymmärryksesi mukaan ratkaistu oikein, ja ne toimivat kuten tehtävänannoissa on pyydetty.</p>

	      <p>Etsi omaan tilanteeseesi sopiva ohje osoitteesta <a href="https://github.com/UniversityHelsinkiTKTL/tmc-plugin-installation-guide" target="_blank">https://github.com/UniversityHelsinkiTKTL/tmc-plugin-installation-guide</a>, rekisteröidy tarvittaessa TMChen ja asenna tarvittaessa NetBeans ja TMC koneellesi. Valitse TMC NetBeansin asetuksista palvelimeksi <code>http://tmc.mooc.fi/hy</code> ja kurssiksi <code>k2015-weso</code>.</p>

	      <p>Tämän jälkeen TMC:n pitäisi ladata käyttöösi tehtäväpohjia. </p>

	      <p>TODO: Chrome-plugin</p>

	      <p>TODO: muuta tiedostoa, tallenna, ja varmista että muutos näkyy selaimessa.</p>

	      <p>TODO: Tee sivusta lopulta seuraavanlainen...</p>

	      <p>Huom, aiemman toisto! Tässä kurssiversiossa TMC <em>ei</em> tarkasta tehtävien oikeellisuutta. Palauttamalla tämän tehtävän <strong><em>vakuutat</em></strong> että jatkossa palauttamasi tehtävät ovat parhaan ymmärryksesi mukaan ratkaistu oikein, ja ne toimivat kuten tehtävänannoissa on pyydetty.</p>
	    </div>


	    <h3>Internet</h3>

	    <p>Web on täynnä selainohjelmointiin liittyviä artikkeleita ja artikkelien määrä kasvaa jatkuvasti. Vuonna 2012 haku lauseella "html5 introduction" palautti hieman yli 17000 sivua, tällä hetkellä -- vuonna 2015 -- tuloksia on noin 28200. Jos hakusanat syötetään ilman lainausmerkkejä, tuloksia on miljoonia. Kun teet kurssin tehtäviä, käytä googlea avuksi. Tätä materiaalia ei yritetäkään rakentaa kaiken kattavaksi, vaan joudut jatkuvasti etsimään lisätietoa internetistä. </p>

	    <p>Jos mietit että miten vaikkapa elementille asetetaan <span style="border:solid">reunat</span>, voit hakea lisätietoja avainsanoilla "html border" -- vastaavasti <span onmouseover="alert('ka-pow!');">hiiren toimintaan ja seurantaan</span> liittyviä artikkeleja löytynee avainsanoilla "html javascript mouse move". Ensimmäisen kymmenen artikkelin joukossa löytynee (lähes) varmasti sinua auttava artikkeli. Tiedon hakeminen netistä on taito siinä missä ohjelmointi tai lukeminen -- sitä kannattaa ja pitää harjoitella.</p>


	    <h2>HTML</h2>

	    <p>HTML on kieli web-sivustojen luomiseen. HTML ei ole ohjelmointikieli, vaan kuvauskieli, jonka avulla kuvataan sekä web-sivun rakenne että sivun sisältämä teksti. HTML-sivujen rakenne määritellään HTML-kielessä määritellyillä elementeillä, ja yksittäinen HTML-dokumentti koostuu sisäkkäin ja peräkkäin olevista elementeistä.</p>

	    <p>Sivujen rakenteen määrittelevät elementit erotellaan normaalista tekstistä pienempi kuin (&lt;) ja suurempi kuin (&gt;) -merkeillä. Elementti avataan elementin nimen sisältävällä pienempi kuin -merkillä alkavalla ja suurempi kuin -merkkiin loppuvalla merkkijonolla, esim. <code>&lt;html&gt;</code>, ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva, esim <code>&lt;/html&gt;</code>. Yksittäisen elementin sisälle voi laittaa muita elementtejä, ja elementti tulee sulkea aina lopuksi. Jos elementti ei sisällä muita elementtejä tai tekstiä, voi sen avata ja sulkea yksittäisellä komennolla, esim. <code>&lt;br/&gt;</code>.</p>


	    <h3>HTML-dokumentin runko</h3>


	    <p>Tyypillisen HTML-dokumentin runko näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti.&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Yllä olevassa HTML-dokumentissa on dokumentin tyypin kertova erikoiselementti <code>&lt;!DOCTYPE html&gt;</code>, joka kertoo dokumentin olevan HTML-sivu. Tätä seuraa elementti <code>&lt;html&gt;</code>, joka aloittaa HTML-dokumentin. Elementti <code>&lt;html&gt;</code> sisältää yleensä kaksi elementtiä, elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>. Elementti <code>&lt;head&gt;</code> sisältää sivun otsaketiedot, eli esimerkiksi sivun käyttämän merkistön <code>&lt;meta charset="utf-8" /&gt;</code> ja otsikon <code>&lt;title&gt;</code>. Elementti <code>&lt;body&gt;</code> sisältää selaimessa näytettävän sivun rungon. Ylläolevalla sivulla on ensimmäisen tason otsake-elementti <code>h1</code> (<em>header 1</em>) ja tekstielementti <code>p</code> (<em>paragraph</em>).</p>

	    <p>Elementit voivat sisältää attribuutteja ja attribuuttien arvoja. Yllä olevassa HTML-dokumentissa elementille <code>meta</code> on määritelty erillinen attribuutti <code>charset</code>, joka kertoo dokumentissa käytettävän merkistön: "utf-8". Attribuuttien lisäksi elementit voivat sisältää <em>tekstisolmun</em>. Esimerkiksi yllä olevat elementit <code>title</code>, <code>h1</code> ja <code>p</code> kukin sisältävät oman tekstisolmun. Tekstisolmulle ei ole erillistä elementtiä tai määrettä, vaan se näkyy tekstinä.</p>

	    <p>Puhe tekstisolmuista antaa viitettä jonkinlaisesta puurakenteesta. HTML-dokumentit, aivan kuten XML-dokumentit, ovat rakenteellisia dokumentteja, joiden rakenne on usein helppo ymmärtää puumaisena kaaviona. Ylläolevan web-sivun voi esittää esimerkiksi seuraavanlaisena puuna (attribuutit ja dokumentin tyyppi on jätetty merkitsemättä).</p>

<pre>
                       html
                   /          \
                 /              \
              head              body
            /       \         /      \
         meta       title     h1      p
                     :        :       :
                  tekstiä  tekstiä tekstiä
</pre>

	    <p>Koska HTML-dokumentti on rakenteellinen dokumentti, on elementtien sulkemisjärjestyksellä väliä. Elementit tulee sulkea samassa järjestyksessä kuin ne on avattu. Esimerkiksi, järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt/body&gt;&lt;/p&gt;</code> on väärä, kun taas järjestys <code>&lt;body&gt;&lt;p&gt;whoa, minttutee!&lt;/p&gt;&lt/body&gt;</code> on oikea.</p>



<div class="pohdi">
  <p><strong>Web-sivujen läpikäynti</strong></p>

  <p>Kun selaimet lataavat HTML-dokumenttia, ne käyvät sen läpi ylhäältä alas, vasemmalta oikealle. Kun selain kohtaa elementin, se luo sille uuden solmun. Seuraavista elementeistä luodut solmut menevät aiemmin luodun solmun alle kunnes aiemmin kohdattu elementti suljetaan. Aina kun elementti suljetaan, puussa palataan ylöspäin edelliselle tasolle.</p>

  <p>Miltä seuraavaa HTML-dokumenttia kuvaava puu näyttää?</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;PSY: Gangnam Style&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;p&gt;"Gangnam Style" is a single by South Korean rapper PSY, that has been viewed
        over 500 million times on &lt;a href="http://www.youtube.com"&gt;YouTube&lt;/a&gt;&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


  <p>Entä seuraavalla HTML-dokumentilla?</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;PSY: Gangnam Style&lt;/title&gt;
    &lt;body&gt;

        &lt;p&gt;"Gangnam Style" is a single by South Korean rapper PSY, that has been viewed
        over 500 million times on &lt;a href="http://www.youtube.com"&gt;YouTube&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

</div>


<div class="tehtavat">
  <h3>Ascii Artist</h3>

  <p>Tehtäväpohjassa olevassa kansiossa <code>src/main/webapp/</code> (tai NetBeansissa <code>Web Pages</code>) on dokumentti <code>index.html</code>. Muokkaa dokumenttia siten, että se sisältää seuraavannäköisen ASCII-taideteoksen (käytettävän fontin ei tarvitse olla sama).</p>

  <div><img src="img/ascii-artist.png"/></div>

  <p>Koska taideteos on ASCII-taidetta, et luonnollisestikaan saa käyttää sivussa kuvaa. Vinkki taideteoksen tekemiseen on yllä olevassa kuvassa. Kun taideteoksesi toimii Chromessa, palauta tehtävä TMC:lle.</p>

</div>


    <h3>Listaelementit</h3>


    <p>Sivuille voi lisätä listoja mm. <code>ol</code> (<em>ordered list</em>) ja <code>ul</code> (<em>unordered list</em>) -elementtien avulla. Elementeillä <code>ol</code> tai <code>ul</code> aloitetaan lista, ja listan sisälle asetettavat yksittäisiin listaelementteihin käytetään <code>li</code> (<em>list item</em>)-elementtiä. Yksittäiset listaelementit voivat taas sisältää esimerkiksi tekstisolmun tai lisää html-elementtejä.</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Yllä oleva lista näyttää seuraavalta ilman muita elementtejä.</p>

<div class="naytto">
  <p>
    <ol>
      <li>kauraa</li>
      <li>puuroa</li>
      <li>omenaa</li>
    </ol>
  </p>
</div>

    <h3>Kuvien lisääminen</h3>


    <p>Jokaisen web-sivuja rakentavan ihmisen tulee ainakin kerran elämässään lisätä kuva web-sivuilleen. Sivuille saa lisättyä kuvia elementillä <code>img</code>, jolla on attribuutti <code>src</code>, jonka arvona on kuvan sijainti. Kuvan sijainti riippuu kuvan näyttävän html-tiedoston sijainnista. Jos kuva on samassa kansiossa <code>html</code>-dokumentin kanssa, tarvitsee <code>img</code>-elementin <code>src</code>-attribuutin arvoksi asettaa vain kuvan nimi.</p>

    <p>Esimerkiksi, jos tämän html-tiedoston sisältämässä kansiossa on kansio nimeltä "img", ja siellä kuvatiedosto nimeltä "lamppu.png", saa kuvatiedoston sivuille näkyville elementillä <code>&lt;img src="img/lamppu.png" /&gt;</code>. Koska kuvaelementti <code>img</code> ei sisällä muita elementtejä tai tekstiä, voi sen sulkea suoraan.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;Kuvan saa taas näytettyä img-elementillä. Välähtikö?&lt;/p&gt;

        &lt;img src="img/lamppu.png" /&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Kuva ilman muita sivujen elementtejä näyttää seuraavalta.</p>

<div class="naytto">
  <img src="img/lamppu.png"/>
</div>

    <h4>Kuvien oikeuksista</h4>

    <p>Netissä olevat kuvat ja tiedostot eivät ole vapaasti kaikkien käytettävissä. Jos teet sivuja itsellesi, tutuille tai kavereille, ja käytät niissä netistä löytynyttä materiaalia, muista varmistaa että käyttämäsi kuvat ovat laillisesti käytettäviä. Kuvien käyttöoikeuksien varmistaminen ei ole aina helppoa tai edes mahdollista -- kannattaakin käyttää vain sivustoja, joiden oikeuksista on varmuus.</p>

    <p>Esimerkiksi flickr-sivustolla on erillinen <code>creative commons</code>-osio, joka listaa kuvia, joiden käyttö on sallittua <em>tietyin ehdoin</em>. Löydät eri ehdot ja kuvia osoitteesta <a href="http://www.flickr.com/creativecommons/" target="_blank">http://www.flickr.com/creativecommons/</a>. On myös sivuja, jotka tarkoituksella keräävät materiaalia tiettyihin aiheisiin liittyen. Esimerkiksi sivusto <a href="http://opengameart.org/" target="_blank">OpenGameArt</a> tarjoaa vapaasti peleissä käytettäviä materiaaleja.</p>

    <h3>Linkit toisille sivuille</h3>

    <p>Elementin <code>a</code> (<em>anchor</em>) avulla voi luoda linkin sivulta toiselle. Sivu, jolle käyttäjä siirtyy, merkitään elementin <code>a</code> attribuutin <code>href</code> arvolla. Jos sovelluksessasi on kaksi sivua, <code>index.html</code> ja <code>oma.html</code>, voi sivulta <code>oma.html</code> luoda linkin sivulle <code>index.html</code> komennolla <code>&lt;a href="index.html"&gt;index.html&lt;/a&gt;</code>. Sivulta voi lisätä myös linkin täysin toiselle sivulle. Alla olevassa esimerkissä on linkki <code>YouTube</code>-sivustolle.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

        &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä,
        listaelementtiä voi käyttää esimerkiksi ostoslistan tekemiseen.&lt;/p&gt;

        &lt;ol&gt;
            &lt;li&gt;kauraa&lt;/li&gt;
            &lt;li&gt;puuroa&lt;/li&gt;
            &lt;li&gt;omenaa&lt;/li&gt;
        &lt;/ol&gt;

        &lt;p&gt;Kuvan saa taas näytettyä img-elementillä. Välähtikö?&lt;/p&gt;

        &lt;img src="img/lamppu.png" /&gt;

        &lt;p&gt;Linkkejä saa lisättyä a-elementillä: &lt;a href="http://www.youtube.com/watch?v=9bZkp7q19f0"&gt;klikkaamalla
        liityt miljoonien joukkoon.&lt;/a&gt;&lt;/p&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Yllä olevan sivun viimeinen tekstielementti näyttää seuraavalta:</p>

<div class="naytto">
  <p>Linkkejä saa lisättyä a-elementillä: <a href="http://www.youtube.com/watch?v=9bZkp7q19f0">klikkaamalla liityt miljoonien joukkoon.</a></p>
</div>

    <p>Linkki-elementeille voi lisätä myös attribuutin <code>target</code>, jolla voi ilmaista tietyn ikkunan, johon sivu avataan. Jos attribuutille <code>target</code> antaa arvon "_blank", avataan linkki aina uuteen ikkunaan.</p>


    <h3>HTML5 ja apuvälineet sivun rakenteen määrittelyyn</h3>


    <p><a href="http://www.w3.org/html/wg/html5/" target="_blank">HTML5</a>, eli HTML-kuvauskielen uusin (vielä kesken oleva) versio, toi mukanaan sivun rakenteen suunnittelua helpottavia elementtejä. Sivun rakenteen määrittelyä helpottavat elementit <code>header</code>, jonka sisälle kirjoitetaan sivun yleinen alkuosa kuten <code>h1</code>-elementti ja valikko, <code>nav</code>, joka sisältää sivun valikon, <code>section</code>-elementti, joka esimerkiksi nivoo yhteen toisiinsa liittyviä osia, <code>article</code>, joka sisältää yksittäisen sivulla olevan dokumentin, ja <code>footer</code>, joka kertoo sivun loppuosan. Näiden avulla sivun saa jaettua loogisiin osakokonaisuuksiin.</p>

    <p>Rakennetta helpottavien elementtien käyttö ja toiminta liittyy elementtiin, jonka sisällä ne ovat. Jos elementtiä <code>header</code> käytetään elementin <code>article</code> sisällä, on <code>header</code> luonnollisesti artikkelin otsaketiedot. Jos taas <code>header</code>-elementti on <code>body</code>-elementin sisällä, liittyy <code>header</code>-elementin sisältö itse sivuun. </p>

    <p>Sivut koostuvat yleensä <code>header</code>-elementillä merkittävästä yläosasta, jossa on otsikko ja mahdollisesti <code>nav</code>-elementillä merkitty valikko. Näitä seuraa yksi tai useampi tekstiosa, joka merkitään <code>article</code>-elementillä. Sivun lopussa on elementti <code>footer</code>, joka sisältää esimerkiksi yhteystiedot.</p>

    <p>Seuraavassa on esimerkki, jossa <code>h1</code>-otsikko on asetettu <code>header</code>-elementin sisään. Sivulla on kaksi erillistä kirjoitusosaa, jotka on eroteltu <code>article</code>-elementeillä. Näitä seuraa lopulta <code>footer</code>-elementillä merkitty alaosa.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;ol&gt;
                &lt;li&gt;kauraa&lt;/li&gt;
                &lt;li&gt;puuroa&lt;/li&gt;
                &lt;li&gt;omenaa&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/article&gt;

        &lt;footer&gt;
            &lt;p&gt;alatunniste, esimerkiksi tekijöiden nimet.&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


<div class="naytto">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
  </header>

  <article>
    <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
  </article>

  <article>
    <ol>
      <li>kauraa</li>
      <li>puuroa</li>
      <li>omenaa</li>
    </ol>
  </article>

  <footer>
    <p>alatunniste, esimerkiksi tekijöiden nimet.</p>
  </footer>
</div>

    <h4>Rakenteellinen lähestymistapa sivujen sisällön määrittelyyn</h4>

    <p>HTML-kuvauskieltä käytetään sivujen rakenteen määrittelyyn. Ennen HTML5:ttä sivun elementtejä eroteltiin toisistaan <code>div</code> (<em>divider</em>)-elementeillä, joille määriteltiin attribuuttina sivun osa, jonka <code>div</code>-elementti sisälsi. Yllä olevan sivun rakenne voidaan luoda myös <code>div</code>-elementeillä.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;div class="header"&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/div&gt;

        &lt;div class="article"&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/div&gt;

        &lt;div class="article"&gt;
            &lt;ol&gt;
                &lt;li&gt;kauraa&lt;/li&gt;
                &lt;li&gt;puuroa&lt;/li&gt;
                &lt;li&gt;omenaa&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/div&gt;

        &lt;div class="footer"&gt;
            &lt;p&gt;alatunniste, esimerkiksi tekijöiden nimet.&lt;/p&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Huomannet että ero on käytännössä hyvin pieni. Oleellisinta on loogisten osakokonaisuuksien erottelu toisistaan. HTML5 tarjoaa siihen työvälineet, joita kannattaa käyttää.</p>

<div class="tehtavat">
  <h3>Kampuskuoro</h3>

  <p>Luo tehtäväpohjassa olevaan kansioon <code>src/main/webapp/</code> uusi sivu <code>index.html</code>. Muokkaa sivua siten, että se näyttää seuraavalta selaimessa:</p>

  <div class="naytto">
    <img src="img/w1e3-kampuskuoro.png" />
  </div>

  <p>Otsikon tulee olla <code>header</code>-elementin sisällä, kuvaus ja laululista omien <code>article</code>-elementtien sisällä. Ei haittaa jos tekstin leveys on eri kuin yllä olevassa kuvassa! Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>
</div>


    <h3>Lomakkeet</h3>

    <p>Lomakkeita käytetään tiedon syöttämiseen web-sivuille. Tietoa voi lähettää joko erilliselle palvelimelle, tai käsitellä osana sivustoa JavaScript-kielen avulla. Lomakkeet aloitetaan HTML-elementillä <code>&lt;form&gt;</code>. Lomake-elementin sisälle voi asettaa useita erilaisia kenttiä. Palvelimelle dataa lähetettäessä jokaisella kentällä tulee olla attribuutti <code>name</code>, jota käytetään palvelimella tiedon identifiointiin.</p>


    <p>Erilaisia lomakekenttiä on useita:</p>

    <ul>
      <li>tekstikenttä: <br/><input type="text" name="kentan_nimi" />
    <pre class="sh_html">
      &lt;input type="text" /&gt;
      </pre></li>

      <li>salasanakenttä: <br/><input type="password" name="kentan_nimi" />
    <pre class="sh_html">
      &lt;input type="password" /&gt;
      </pre></li>

      <li>tekstialue: <br/><textarea name="tekstialue"></textarea><br/>Toisin kuin monet muut lomakkeen kenttäelementit, tekstialue tulee sulkea erillisellä elementillä.
    <pre class="sh_html">
      &lt;textarea name="tekstialue"&gt;&lt/textarea&gt;
      </pre></li>

      <li>valintaruutu: <br/>
    <input type="checkbox" name="porkkanaa" /> Porkkanaa<br/>
    <input type="checkbox" name="naurista" /> Naurista<br/>
    <input type="checkbox" name="kaalia" /> Kaalia<br/>
    Selaimesta riippuen valintaruudun tiedot lähetetään lomakkeen mukana vain kentän ollessa valittuna.
    <pre class="sh_html">
      &lt;input type="checkbox" name="porkkanaa" /&gt; Porkkanaa &lt;br/&gt;
      &lt;input type="checkbox" name="naurista" /&gt; Naurista &lt;br/&gt;
      &lt;input type="checkbox" name="kaalia" /&gt; Kaalia &lt;br/&gt;
    </pre>
      </li>

      <li>valintanappi:<br/>
    <input type="radio" name="valinta" value="porkkanaa"/> Porkkanaa<br/>
    <input type="radio" name="valinta" value="naurista"/> Naurista<br/>
    <input type="radio" name="valinta" value="kaalia"/> Kaalia<br/>
    Valintanappia käytettäessä vain yksi saman name-attribuutin omistava radio-tyyppinen input-elementti voi olla valittuna. Lomaketta lähetettäessä valitun elementin attribuutin <code>value</code> arvo lähetetään <code>name</code> attribuutin arvona.
    <pre class="sh_html">
      &lt;input type="radio" name="valinta" value="porkkanaa"/&gt; Porkkanaa&lt;br/&gt;
      &lt;input type="radio" name="valinta" value="naurista"/&gt; Naurista&lt;br/&gt;
      &lt;input type="radio" name="valinta" value="kaalia"/&gt; Kaalia&lt;br/&gt;
      </pre></li>


      <li>painettava nappi:<br/>
    <input type="button" value="Painettava nappi" /><br/>
    Painettavaa nappia painettaessa mitään ei tapahdu, ellei siihen ole erikseen lisätty toiminnallisuutta esimerkiksi javascript-kielellä.
    <pre class="sh_html">
      &lt;input type="button" value="Painettava nappi" /&gt;
      </pre></li>

      <li>lähetysnappi:<br/>
    <input type="submit" value="Lähetä" /><br/>
    Lähetysnappia painettaessa lomakkeen tiedot lähetetään lomake-elementissä määriteltyyn osoitteeseen (lomake-elementin <code>action</code> -attribuutin arvo) valitulla lähestytavalla (lomake-elementin <code>method</code>-attribuutin arvo).
    <pre class="sh_html">
      &lt;input type="submit" value="Lähetä" /&gt;
      </pre></li>

    </ul>


    <h4>Lomakkeen lähettäminen</h4>


    <p>Kun lomake lähetetään selain ohjaa käyttäjän kohdeosoitteeseen siten, että lähetettävän lomakkeen tiedot ovat mukana selaimen tekemässä pyynnössä. Jos lomakkeen lähetystapa on <code>GET</code>, on lomakkeen tiedot osana osoitetta. Lähetystavassa <code>POST</code> arvot tulevat osana pyynnön runkoa.</p>

    <p>Alla on lomake jolla voi visualisoida tietojen lähettämistä palvelimelle. Lomakkeet lähetetään osoitteeseen <a href="http://t-avihavai.users.cs.helsinki.fi/lets/See" target="_blank">http://t-avihavai.users.cs.helsinki.fi/lets/See</a>), jossa on pyynnössä saadut tiedot tulostava web-palvelu.</p>

    <div class="naytto">
      <p>
    <form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See">
      <label>Käyttäjätunnus: <input type="text" name="tunnus" /></label>
      <label>Salasana: <input type="password" name="salasana" /></label>
      <input type="submit" />
    </form>
      </p>
    </div>

<pre class="sh_html">
&lt;form method="POST" action="http://t-avihavai.users.cs.helsinki.fi/lets/See"&gt;
    &lt;label&gt;Käyttäjätunnus: &lt;input type="text" name="tunnus" /&gt;&lt;/label&gt;
    &lt;label&gt;Salasana: &lt;input type="password" name="salasana" /&gt;&lt;/label&gt;
    &lt;input type="submit" /&gt;
&lt;/form&gt;
</pre>

<div class="extra">
  <p><strong>Lisää informaatiota</strong></p>

  <p>Mikään yksittäinen HTML-opas ei itsessään kata kaikkea HTMLään liittyvää. Tässäkin dokumentissa tehtiin pieni pintaraapaisu HTMLn ominaisuuksiin. Erityisesti selainsovelluksia rakennettaessa uusinta informaatiota jaetaan mm. blogeissa ja muissa webissä julkaistavissa artikkeleissa. Web on täynnä timanttisia sivustoja kuten <a href="http://www.html5rocks.com/" target="_blank">http://www.html5rocks.com/</a>, <a href="http://html5-demos.appspot.com/" target="_blank">http://html5-demos.appspot.com/</a>, ... </p>

  <p>Kuten yllä olevista linkeistä huomaat, "puhekielessä" HTML5 sisältää HTML-syntaksin lisäksi CSSn ja JavaScriptin. Avain onneen on pienestä liikkeelle lähteminen: toteutta joku webissä oleva hieno sivu itse sivun lähdekoodia seuraten. Muokkaile lähdekoodia, ja ota selvää mitä eri komennot tekevät. Kun joku komento on epäselvä, <a href="http://lmgtfy.com/?q=Ep%C3%A4selv%C3%A4t+avainsanat" target="_blank"><em>google auttaa</em></a>.</p>
</div>


    <h2>CSS</h2>

    <p>CSS (<em>cascading style sheets</em>)-tyylitiedostot ovat tiedostoja, joissa määritellään miten web-sivun elementit tulee näyttää käyttäjälle. HTML-kuvauskielellä määritellään web-sivun rakenne ja sisältö, tyylitiedostoilla sen ulkoasu.</p>

    <p>Tyylitiedostoilla voi tehdä <em>ison</em> eron siihen, miltä sivu näyttää. Lähdetään kuitenkin pienestä liikkeelle. Tyylitiedosto on HTML-dokumentista erillinen tiedosto, joka sisältää erilaisia tyylimäärittelyjä. Tyylitiedostoja voi olla useita. Jotta HTML-dokumentti saa tyylitiedoston käyttöönsä, tulee tyylitiedoston sijainti määritellä <code>head</code>-elementin sisälle tyylitiedoston lataavaan elementtiin <code>link</code>.</p>


<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" /&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sivun sisältö: näin sivuille saa kommentin --&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <p>Elementille <code>link</code> kerrotaan viitattavan tiedoston tyyli (rel="stylesheet"), tyyppi (type="text/css") ja sijainti (href="sijainti.css"). Sijainnin tulee kertoa tyylitiedoston nimi. Tyylitiedostojen päätteenä käytetään merkkijonoa <code>.css</code>.  Esimerkiksi jos tyylitiedosto tämän tiedoston sisältämän kansion sisällä olevassa kansiossa "stylesheets" ja tyylitiedoston nimi on <code>style.css</code>, asetetaan elementin <code>link</code> attribuutin <code>href</code> arvoksi "stylesheets/style.css".</p>

    <h3>Tyylitiedosto</h3>

    <p>Tyylitiedosto on erillinen tiedosto HTML-dokumentista. Luodaan esimerkiksi tiedosto <code>style.css</code>, jonka sisältö on seuraavanlainen:</p>

<pre class="sh_css">
body {
    background-color: rgb(200, 200, 200);
    margin: 0;
    padding: 0;
}
</pre>

    <p>Yllä olevassa tyylitiedostossa sanotaan, että elementin <code>body</code> (eli HTML-dokumentin rungon) taustaväri on <code>rgb</code>-arvolla kerrottuna 200, 200, 200, eli vaaleahko. Väriarvo <code>rgb</code> tulee sanoista <code>red</code>, <code>green</code>, ja <code>blue</code>, ja jokaisella arvolla kerrotaan värin määrän. Kunkin värin määrä ilmaistaan numerolla nollan ja 255 välillä. Jos jokaisen värin arvo on 0, on väri musta, ja jos jokaisen värin arvo on 255, on väri valkoinen.</p>

    <p>Kukin tyylimäärittely alkaa tyyliteltävän elementin kertovalla valitsimella ja avaavalla aaltosululla <code>{</code>, joita seuraa listaus käytettävistä tyyleistä. Kun käytettävät tyylit on määritelty, tyylimäärittely lopetetaan sulkevalla aaltosululla <code>}</code>. Kullakin tyylillä on nimi ja arvo, jotka erotetaan toisistaan kaksoispisteellä <code>:</code>. Yksittäisen tyylin (nimi ja arvo) jälkeen lisätään puolipiste <code>;</code>. Yhteen tyylimäärittelyyn voi sisällyttää useita tyylejä, ja yksittäinen tyyli voi riippuen tyylistä saada useita arvoja.</p>

<pre class="sh_css">
<em>valitsin</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Tyylimäärittely voi myös sisältää useita tyyliteltäviä elementtejä, tällöin valitsimet erotellaan toisistaan pilkulla.</p>


<pre class="sh_css">
<em>valitsin</em>, <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Valitsimia voi käyttää myös lasten valintaa, esimerkiksi seuraavassa valitaan ensimmäisen valitsimen joukosta toisen valitsimen tyyppinen lapsi.</p>


<pre class="sh_css">
<em>valitsin</em> &gt; <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>


    <h3>Valitsimet</h3>


    <p>Jokaiselle sivun elementille voidaan määritellä oma tyyli. Jos halutaan että sama tyyli esiintyy kaikissa elementeissä, voidaan valitsimena käyttää elementin nimeä. Esimerkiksi seuraava tyylitiedosto muuttaa kaikkien <code>p</code>-elementtien tekstin värin punaiseksi.</p>

<pre class="sh_css">
p {
    color: rgb(255, 0, 0);
}
</pre>


    <h4>Luokka-attribuutti</h4>

    <p>Silloin tällöin tyyli halutaan asettaa vain tietylle elementille tai elementtijoukolle. Elementeille voidaan määritellä luokka-attribuutti <code>class</code>, jonka arvoksi asetetaan joku tietty arvo, esimerkiksi "blue". Luokka-attribuuttien tyylit voi asettaa erillisellä <code>class</code>-attribuutteja valitsevalla valitsimella, pisteellä. Esimerkiksi kaikki elementit, joilla on luokka-attribuutin arvo "blue" voi valita seuraavasti (kaikille asetetaan alla tekstin väriksi sininen):</p>

<pre class="sh_css">
.blue {
    color: rgb(0, 0, 255);
}
</pre>

      <p>Itse sivulla olevat elementit näyttävät seuraavalta luokka-attribuutin kanssa. Osalla elementeistä on luokka-attribuutti "blue", ja osalla ei.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" /&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;


        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
            &lt;p class="blue"&gt;Kuten edellinen elementti, mutta tällä on luokka-attribuutti, jonka arvo on "blue".
            Tyylimäärittely .blue asettaa tekstin värin siniseksi.&lt;/p&gt;
        &lt;/article&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>


<style>
.blue-esim-luokka-attr {
    color: rgb(0, 0, 255);
}
</style>



<div class="naytto">

        <h1>Sivulla näkyvä otsikko</h1>

        <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        <p class="blue-esim-luokka-attr">Kuten edellinen elementti, mutta tällä on luokka-attribuutti, jonka arvo on "blue".</p>

</div>


    <h4>Tunnus-attribuutti</h4>


    <p>Luokka-attribuuttia käytetään joukolle tyylejä. Yksittäisiä elementtejä tyyliteltäessä tapana on käyttää erillistä tunnus-attribuuttia, joka määritellään nimellä <code>id</code>. Kuten luokka-attribuutille, myös tunnus-attribuutille asetetaan arvo. Tunnus-attribuuttiin pääsee käsiksi tyylitiedostossa risuaita (<code>#</code>) -etuliitteellä. Luodaan sivu, jossa on useampia artikkeleita, joista yhtä halutaan korostaa.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" /&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;


        &lt;article id="highlighted-article"&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä.&lt;/p&gt;
        &lt;/article&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Luodaan sivu siten, että artikkeleilla on pyöreät kulmat ja vaaleahko taustaväri. Korostettavalla artikkelilla on oma tyylinsä, jossa sille asetetaan hieman vaaleampi taustaväri.</p>

<pre class="sh_css">
article {
    background-color: rgb(200, 200, 200);
    margin: 1em;
    padding: 1em;
    width: 40%;

    /* pyöreät kulmat -- useampi määrittely sillä tyylispesifikaatio vielä kesken */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#highlighted-article {
    width: 42%;
    background-color: rgb(240, 240, 240);

    /* fiilistellään css3-tyylien kanssa */
    -webkit-transform: rotate(-2deg); /* chrome, safari */
    -moz-transform: rotate(-2deg); /* firefox */
    -o-transform: rotate(-2deg); /* opera */
    transform: rotate(-2deg);
}
</pre>

<style>
.padded-article {
    background-color: rgb(200, 200, 200);
    margin: 1em;
    padding: 1em;
    width: 40%;

    /* pyöreät kulmat -- useampi määrittely sillä tyylispesifikaatio vielä kesken */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#highlighted-article {
    background-color: rgb(240, 240, 240);
    width: 42%;

    /* fiilistellään css3-tyylien kanssa */
    -webkit-transform: rotate(-2deg); /* chrome, safari */
    -moz-transform: rotate(-2deg); /* firefox */
    -o-transform: rotate(-2deg); /* opera */
    transform: rotate(-2deg);
}
</style>

<div class="naytto">
        <header>
            <h1>Sivulla näkyvä otsikko</h1>
        </header>


        <article class="padded-article" id="highlighted-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

        <article class="padded-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

        <article class="padded-article">
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä.</p>
        </article>

</div>



    <h3>Tyylien vaikutus elementteihin</h3>

    <p>Edellä olevassa esimerkissä tyyli <code>#highlighted-article</code> ei sisältänyt reunojen pyöristystä, mutta silti korostetun artikkelin reunat pyöristettiin silti. Miksi?</p>

    <p>Elementti käyttää kaikkia sille määriteltyjä tyylejä. Esimerkiksi tyyli <code>#highlighted-article</code> on osana <code>article</code>-elementtiä, jolla taas on siihen liittyvä tyyli. Mielenkiintoinen kohta liittyy artikkelin leveyteen (tyylimäärittely <code>width</code>): tyylissä <code>#highlighted-article</code> oleva määrittely <code>width</code> korvaa tyylissä <code>article</code> määritellyn leveyden. Jos leveyttä ei olisi korvattu, olisi myös leveys peritty.</p>

    <p>Koska HTML-dokumentti on puu, voi tyylien periytymistä ajatella myös puumaisena periytymisenä. Jos elementille <code>body</code> määritellään tietynlainen tyyli, on kaikilla sen lapsisolmuilla <code>body</code>-elementissä määritelty tyyli, ellei lapsisolmu korvaa tyyliä.</p>

    <p>Kaikki tyylit eivät kuitenkaan periydy. Tutustu tarkemmin tyylimäärittelyihin ja standardiin osoitteessa <a href="http://www.w3.org/TR/CSS/#properties" target="_blank">http://www.w3.org/TR/CSS/#properties</a>.</p>



    <div class="tehtavat">
      <h3>Css Askeleet</h3>

      <p>Luo tehtäväpohjan kansioon <code>src/main/webapp/</code> tyylitiedosto <code>style.css</code>, ja viittaa siihen tiedostosta <code>index.html</code>. Muokkaa tyylitiedostoa <code>style.css</code> siten, että sivu <code>index.html</code> näyttää seuraavanlaiselta.</p>

      <div><img src="img/w1e04-css-askeleet.png" /></div>

      <p>Tässä muutama hyödyllinen väri:</p>

      <ul>
    <li>rgb(242, 242, 242)</li>
    <li>rgb(155, 155, 155)</li>
    <li>rgb(10, 10, 10)</li>
    <li>rgb(252,179,21)</li>
      </ul>

      <p>Sivu käyttää seuraavaa määrittelyä fontin valintaan..</p>

      <pre class="sh_css">    font-family: 'Trebuchet MS', Trebuchet, Arial, sans-serif;</pre>


      <p>Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>
    </div>



    <h3>Case: Listojen tyylit</h3>

    <p>Tyylitiedostoilla saa muokattua oikeastaan kaikkea sivulla olevaa. Listalle voi asettaa taustavärin, ja siitä voi poistaa numeroinnin tai pallot. Luodaan tyyliluokka <code>menu</code>, jossa listan taustaväri on vaalean harmaa, ja listan palloja ei näytetä.</p>

<pre class="sh_css">
.menu {
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;
}
</pre>

<pre class="sh_html">
  &lt;ul class="menu"&gt;
    &lt;li&gt;Eka pallukka&lt;/li&gt;
    &lt;li&gt;Toka pallukka&lt;/li&gt;
    &lt;li&gt;Kolmas pallukka&lt;/li&gt;
  &lt;/ul&gt;
</pre>

    <p>Nyt lista näyttää seuraavalta:</p>

<style>
.menu-ex {
    background-color: rgb(230, 230, 230);
    list-style-type: none;
    padding: 1em;
}
</style>

<div class="naytto">
  <ul class="menu-ex">
    <li>Eka pallukka</li>
    <li>Toka pallukka</li>
    <li>Kolmas pallukka</li>
  </ul>
</div>

    <p>Muutetaan listan elementtejä siten, että ne asetellaan vierekkäin. Luodaan tyyliluokka <code>menuelement</code>, joka asettaa listaelementit vierekkäin, ja lisää niille hieman tilaa sivuille.</p>

<pre class="sh_css">
.menuelement {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}
</pre>

    <p>Lisätään listan elementeille tyyliluokka listaelementti.</p>


<pre class="sh_html">
  &lt;ul class="menu"&gt;
    &lt;li class="menuelement"&gt;Eka pallukka&lt;/li&gt;
    &lt;li class="menuelement"&gt;Toka pallukka&lt;/li&gt;
    &lt;li class="menuelement"&gt;Kolmas pallukka&lt;/li&gt;
  &lt;/ul&gt;
</pre>

    <p>Nyt lista näyttää seuraavalta:</p>


<style>
.menuelement-ex {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    display: inline;
}
</style>

<div class="naytto">
  <ul class="menu-ex">
    <li class="menuelement-ex">Eka pallukka</li>
    <li class="menuelement-ex">Toka pallukka</li>
    <li class="menuelement-ex">Kolmas pallukka</li>
  </ul>
</div>

    <p>Valikkoihin halutaan usein jonkinlaista dynaamista toiminnallisuutta. Lisätään toiminnallisuus, jossa vaihtoehdon taustaväri muuttuu kun sen päälle viedään hiiri. Valitsimen lisämääreellä <code>:hover</code> voidaan määritellä tyyli, joka näkyy vain kun hiiri on tyylitellyn alueen päällä. Lisätään toinen <code>menuelement</code>-tyyliluokka, ja sille lisämääre <code>:hover</code>.</p>


<pre class="sh_css">
.menuelement {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}

.menuelement:hover {
    /* vaaleampi taustaväri kun hiiri on tyylin päällä */
    background-color: rgb(245, 245, 245);
}
</pre>

<style>
.menuelement-ex2 {
    /* 1 standardimerkin leveyden verran tilaa jokaiselle puolelle */
    padding: 1em;
    /* näytetään menuelementit vierekkäin */
    display: inline;
}

.menuelement-ex2:hover {
    /* vaaleampi taustaväri kun hiiri on tyylin päällä */
    background-color: rgb(245, 245, 245);
}
</style>

    <p>Tässä meidän ei tarvitse muokata HTML-dokumenttia, sillä tyyliluokka <code>menuelement</code> on jo määritelty HTML-dokumenttiin.</p>


<div class="naytto">
  <ul class="menu-ex">
    <li class="menuelement-ex2">Eka pallukka</li>
    <li class="menuelement-ex2">Toka pallukka</li>
    <li class="menuelement-ex2">Kolmas pallukka</li>
  </ul>
</div>



    <p>Vielä noin 5 vuotta sitten pyöreät kulmat tehtiin erillisillä kuvilla. Ei enää! Pyöreät kulmat eivät ole vielä ihan helpon komennon takana, vaan niihin tarvitaan kolme erillistä komentoa. Erillisiä komentoja tarvitaan selainyhteensopivuuden varmistamiseksi: pyöreät kulmat määrittelevä standardi ei ole vielä lopullinen...). Pyöreät kulmat saa lisättyä tyyliluokkaan <code>menu</code> seuraavasti:</p>

<pre class="sh_css">
.menu {
    /* tämä on muuten kommentti, eli kone ei tee sillä mitään */
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</pre>

<style>
.menu-ex2 {
    /* tämä on muuten kommentti, eli kone ei tee sillä mitään */
    /* listan tausta on harmaa */
    background-color: rgb(230, 230, 230);

    /* ei näytetä palloja */
    list-style-type: none;

    /* lisätään reunoille hieman tilaa (1em = 1 standardimerkin leveys) */
    padding: 1em;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</style>


    <p>Lista näyttää nyt seuraavalta:</p>

<div class="naytto">
      <ul class="menu-ex2">
    <li class="menuelement-ex2">Eka pallukka</li>
    <li class="menuelement-ex2">Toka pallukka</li>
    <li class="menuelement-ex2">Kolmas pallukka</li>
      </ul>
</div>

    <h4>Tyylivalitsimet ja menu</h4>

    <p>Yllä oleva lähestymistapa, vaikkakin hieno, on hieman kömpelö. Jouduimme lisäämään jokaiselle tyyliteltävälle elementille oman luokkamäärittelyn. Aiemmin näimme, että tyylejä voi määritellä listana seuraavasti:</p>

<pre class="sh_css">
<em>valitsin</em>, <em>valitsin2</em> {
    <em>tyylin-nimi</em>: <em>tyylin-arvo</em>;
    <em>toisen-tyylin-nimi</em>: <em>arvo</em> <em>toinen-arvo</em>;
}
</pre>

    <p>Tutustutaan seuraavaksi toiseen tapaan. Tavoitteenamme on tyylitellä alla olevan sivun <code>header</code>-osio uudestaan. Huomaa jo nyt, että sivun <code>header</code>-osioon ei ole määritelty luokkia tai tunnuksia!</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" /&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;

            &lt;nav&gt;
                &lt;ul&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                    &lt;li&gt;&lt;a href="#"&gt;linkki&lt;/a&gt;&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/nav&gt;

        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>



<div class="naytto">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>


    <p>Toinen tapa valita tyyliteltäviä elementtejä liittyy niiden järjestykseen osana dokumenttia. Voimme tyylitellä <code>header</code>-elementin sisällä olevan <code>h1</code>-elementin seuraavasti. Huomaa että tämä tyylittely <em>ei</em> muuta kaikkia <code>h1</code>-elementtejä, vain vaan ne, jotka ovat <code>header</code>-elementin sisällä.</p>

<pre class="sh_css">
header h1 {
    color: rgb(80, 80, 80);
}
</pre>


<style>
#ex-1 header h1 {
    color: rgb(80, 80, 80);
}

</style>


<div class="naytto" id="ex-1">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>

    <p>Jatketaan esimerkkiä muokkaamalla <code>header</code>-elementissä olevan <code>nav</code>-elementin sisältämää listaa. Listan taustaväriksi asetetaan lähes musta, ja sillä on pyöristetyt kulmat.</p>


<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</pre>


<style>
#ex-2 header h1 {
    color: rgb(40, 40, 40);
}

#ex-2 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}
</style>


<div class="naytto" id="ex-2">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>



    <p>Ei mitenkään kovin komea, muutamat selaimet näyttävät myös listaelementit listan ulkopuolella. Lisätään listaelementeille määrittely, jossa ne asetetaan vierekkäin.</p>


<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}
</pre>


<style>
#ex-3 header h1 {
    color: rgb(40, 40, 40);
}

#ex-3 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#ex-3 header nav ul li {
    float: left;
    display: inline;
}
</style>

<div class="naytto" id="ex-3">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>



    <p>Ei vieläkään komea, mutta selviämme tästä kyllä. Muutetaan linkkielementtien väri valkoiseksi, suurennetaan niiden fonttia, ja asetetaan niille hieman tilaa ympärille.</p>

<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}


header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}
</pre>


<style>
#ex-4 header h1 {
    color: rgb(40, 40, 40);
}

#ex-4 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;


    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}


#ex-4 header nav ul li {
    float: left;
    display: inline;
}

#ex-4 header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}
</style>

    <p>Nyt sivumme yläosa näyttää seuraavalta.</p>


<div class="naytto" id="ex-4">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>

    <p>Lisätään vielä linkkielementeille toiminnallisuus, jossa niiden taustaväri muuttuu kun hiiri viedään elementin päälle. Asetetaan taustaväri tällöin valkoiseksi, ja linkin fontti aiemmin käytetyksi tummaksi väriksi.</p>

<pre class="sh_css">
header h1 {
    color: rgb(40, 40, 40);
}

header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

header nav ul li {
    float: left;
    display: inline;
}

header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}

header nav ul li a:hover {
    background-color: rgb(255, 255, 255);
    color: rgb(40, 40, 40);
}
</pre>


<style>
#ex-5 header h1 {
    color: rgb(40, 40, 40);
}

#ex-5 header nav ul {
    /* fontin koon ym määrittelyä.. */
    font-size: 1.2em;
    height: 40px;
    line-height: 30px;
    margin: 0 auto 2em auto;

    /* taustaväriksi h1-elementin taustaväri */
    background-color: rgb(40, 40, 40);

    /* ei näytetä palloja */
    list-style-type: none;

    /* pyöreät kulmat */
    border-radius: 10px;
    -moz-border-radius: 10px;
    -webkit-border-radius: 10px;
}

#ex-5 header nav ul li {
    float: left;
    display: inline;
}

#ex-5 header nav ul li a {
    color: rgb(255, 255, 255);
    display: inline-block;
    padding: 5px 1.5em;
    text-decoration: none;
}

#ex-5 header nav ul li a:hover {
    background-color: rgb(255, 255, 255);
    color: rgb(40, 40, 40);
}
</style>

<div class="naytto" id="ex-5">
  <header>
    <h1>Sivulla näkyvä otsikko</h1>
    <nav>
      <ul>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
    <li><a href="#">linkki</a></li>
      </ul>
    </nav>
  </header>
</div>


      <p>Done! Tyylimaailman sopivuudesta jokainen saa toki päättää itse :).</p>


    <div class="tehtavat">
      <h3>Suosikit</h3>

      <p>Tehtäväpohjassa on lista suosikkeja. Tehtävänäsi on lisätä sivulle tyyli, joka tekee sivusta seuraavannäköisen. Huomaa, että sivun artikkeli-elementtien tulee kääntyä hieman kun hiiri viedään niiden päälle.</p>

      <img src="img/w1e05-suosikit.png" />

      <p>Edellisessä tehtävässä määrittelemistäsi tyyleistä on hyötyä tässä tehtävässä. Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>

    </div>



<div class="extra">
  <p><strong>Lisää informaatiota</strong></p>

  <p>Web on pullollaan myös CSSään liittyviä sivuja; <a href="http://www.css3.com/" target="_blank">http://www.css3.com/</a>, <a href="http://www.smashingmagazine.com/learning-css3-useful-reference-guide/" target="_blank">http://www.smashingmagazine.com/learning-css3-useful-reference-guide/</a>, ...</p>

  <p>Viimeisin versio löytyy osoitteesta <a href="http://www.w3.org/Style/CSS/current-work" target="_blank">http://www.w3.org/Style/CSS/current-work</a> -- CSS3 on jatkuvasti päivittyvä standardi.</p>
</div>





    <h2>JavaScript</h2>

    <p>Siinä missä HTML on kuvauskieli web-sivujen rakenteen ja sisällön luomiseen, ja CSS on kieli web-sivustojen tyylin määrittelyyn, JavaScript on kieli dynaamisen toiminnan lisäämiselle. Suomen kielioppia ajatellen HTML:ää voi ajatella substantiiveina, CSS:ää adjektiiveina, ja JavaScriptiä verbeinä. Käytännössä JavaScript on ohjelmakoodia, jota suoritetaan tarvittaessa komento kerrallaan -- ylhäältä alas, vasemmalta oikealle.</p>


<script>
function evalElementContent(elementId) {
    eval(document.getElementById(elementId).value);
}
</script>

    <p>Ensimmäinen komento jonka opimme on <code>alert("tulostettava merkkijono")</code>. Funktio <code>alert("jotain")</code> on JavaScriptin valmis funktio, ja se avaa uuden pop-up -ikkunan jossa näkyy funktion <code>alert</code> parametrina saama arvo. Funktiolle alert voi antaa parametrina oikeastaan minkälaisia arvoja tahansa. Voit testata <code>alert</code>-funktion toimintaa alla olevassa laatikossa. Painamalla nappia "Suorita koodi!", selaimesi suorittaa laatikossa olevan koodin.</p>

    <div class="test-js">
      <p><textarea id="js-alert" rows="4" cols="80">alert("heippa!");</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-alert')" value="Suorita koodi!"></input></p>
    </div>

    <p>Ohjelmakoodia suoritettaessa selain käy läpi laatikossa olevat komennot yksi kerrallaan ylhäältä alas, vasemmalta oikealle, ja toimii niiden mukaan. JavaScript-koodi suoritetaan siis omalla koneellasi omassa selaimessasi. Kukin komento loppuu puolipisteeseen (<code>;</code>), ja komentoja voi olla useampia. Mitä käy jos muutat <code>alert</code>-komennossa olevaa tekstiä, tai lisäät useamman <code>alert</code>-komennon?</p>

<div class="extra">
  <p>Vaikkakin käytämme komentoa <code>alert</code> hyvin intensiivisesti, se ei ole osa JavaScript-spesifikaatiota. </p>
  <p>&nbsp;</p>
  <p>&nbsp;</p>
</div>

    <h3>Funktiot</h3>

    <p>Jos ylläoleva koodi asetetaan lähdekooditiedostoon, se suoritetaan <em>heti</em> kun selain lataa tiedoston. Haluamme kuitenkin usein siirtää koodin suoritusta tulevaisuuteen, johonkin tiettyyn tapahtumaan. Tätä varten on olemassa funktiot. Funktioilla määritellään ohjelmakoodia, joka suoritetaan myöhemmin.</p>

    <p>Funktio määritellään merkkijonolla <code>function funktionNimi() { <em>suoritettava koodi</em>}</code>. Ensin avainsana <code>function</code>, joka kertoo että seuraavaksi on tulossa funktion määrittely. Tätä seuraa funktion nimi, ja sulut, joita seuraa aukeava aaltosulku <code>{</code>. Aaltosulun jälkeen tulee funktiota kutsuttaessa suoritettava ohjelmakoodi, jonka jälkeen tulee sulkeva aaltosulku <code>}</code>.</p>

    <p>Alla on määritelty funktio, joka kysyy käyttäjältä nimeä, tallentaa nimen muuttujaan <code>nimi</code>, ja lopulta käyttää funktiota <code>alert</code> nimen tulostamiseen.</p>

    <div class="test-js">
      <p><textarea id="js-kysynimi-funktio" rows="6" cols="80">function kysyNimiJaTervehdi() {
    var nimi = prompt("Mikä on nimesi?");
    alert(nimi);
}
      </textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysynimi-funktio')" value="Suorita koodi!"></input></p>
    </div>

      <p>Kun painat nappia "Suorita koodi!", huomaat ettei mitään tapahdu. Tämä johtuu siitä, että funktiota ei kutsuta mistään, eli funktion suorittamista ei pyydetä. Lisätään funktiokutsu. Funktion kutsuminen onnistuu sanomalla funktion nimi ja sulut, sekä puolipiste. Esimerkiksi <code>funktionNimi();</code>. Alla olevassa koodissa on sekä funktion <code>kysyNimiJaTervehdi</code> määrittely, että funktion <code>kysyNimiJaTervehdi</code> kutsu.</p>

      <div class="js-test">
      <p><textarea id="js-kysynimi-funktio-ja-kutsu" rows="8" cols="80">function kysyNimiJaTervehdi() {
    var nimi = prompt("Mikä on nimesi?");
    alert(nimi);
}

kysyNimiJaTervehdi();</textarea></p>
      </div>
      <p><input type="button" onclick="evalElementContent('js-kysynimi-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>



      <h3>JavaScriptin lisääminen omille sivuille</h3>

      <p>Aivan kuten CSS-tyylimäärittelyt, JavaScript-lähdekoodit tulee erottaa HTML-dokumentista.</p>

      <p>JavaScript-tiedoston pääte on yleensä <code>.js</code> ja siihen viitataan elementillä <code>script</code>. Elementillä <code>script</code> on attribuutti <code>src</code>, jolla kerrotaan lähdekooditiedoston sijainti. Jos lähdekoodi on kansiossa <code>javascript</code> olevassa tiedostossa <code>code.js</code>, käytetään <code>script</code>-elementtiä seuraavasti: <code>&lt;script src="javascript/code.js"&gt;&lt;/script&gt;</code>. Huomaa että <code>script</code>-elementti suljetaan poikkeuksellisesti erikseen vaikka se ei sisälläkään tekstiä.</p>

      <p>Hyvä käytäntö JavaScript-lähdekoodien lataamiseen on ladata ne juuri ennen niiden tarvitsemista. Jos lähdekoodia ei tarvita kuin vasta sivun ollessa kokonaan latautunut, kannattaa lähdekoodien hakeminen asettaa sivun loppuun. Tämä johtuu mm. siitä, että selaimen kohdatessa JavaScript-tiedoston, se lähtee hakemaan tiedostoa ja asettaa kaikki muut toiminnot odottamaan. Kun lähdekooditiedosto ladataan vasta sivun lopussa, käyttäjä <em>näkee</em> sivun sisältöä jo ennen lähdekoodin latautumista: tämä luo tunteen nopeammin reagoivista sivuista.</p>

      <p>Luodaan kansioon <code>javascript</code> lähdekooditiedosto <code>code.js</code>. Tiedostossa <code>code.js</code> on funktio <code>sayHello</code>, joka näyttää käyttäjälle viestin "BAD = browser application development".</p>


<pre class="sh_javascript_dom">
function sayHello() {
    alert("BAD = browser application development");
}
</pre>

      <p>HTML-dokumentti, jossa lähdekooditiedosto ladataan, näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;link rel="stylesheet" type="text/css" href="stylesheets/style.css" /&gt;
        &lt;title&gt;Sivun otsikko (näkyy selaimen palkissa)&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Sivulla näkyvä otsikko&lt;/h1&gt;
        &lt;/header&gt;

        &lt;article&gt;
            &lt;p&gt;Sivuilla näytettävä normaali teksti on p-elementin sisällä. Alla on nappi,
            jota painamalla kutsutaan funktiota "sayHello".&lt;/p&gt;
            &lt;input type="button" value="Tervehdi" onclick="sayHello();" /&gt;
        &lt;/article&gt;

        &lt;!-- ladataan JavaScript-koodit tiedoston lopussa! --&gt;
        &lt;script src="javascript/code.js"&gt;&lt;/script&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Itse sivu näyttää seuraavalta:</p>

<div class="naytto">
        <header>
            <h1>Sivulla näkyvä otsikko</h1>
        </header>

        <article>
            <p>Sivuilla näytettävä normaali teksti on p-elementin sisällä. Alla on nappi,
            jota painamalla kutsutaan funktiota "sayHello".</p>
            <input type="button" value="Tervehdi" onclick="sayHello();" />
        </article>
        <!-- funktio määritelty osana sivua, ei hyvä! pitäisi oikeasti ladata tiedostosta! -->
        <script>
function sayHello() {
    alert("BAD = browser application development");
}
        </script>
</div>


    <div class="tehtavat">

      <h3>Mitä eläin sanoo?</h3>

      <p>Tehtäväpohjassa tulevalla sivulla on kolme erillistä eläintä. Luo tehtäväpohjaan erillinen javascript-tiedosto, ja lataa se sivun käyttöön. Lisää toiminnallisuus, jonka avulla lehmän nappia painettaessa käyttäjälle tulostetaan viesti "muu muu", porsaan nappia painettaessa "nöf nöf", ja kanan nappia painettaessa "kot kot".</p>

      <p>Varmista sivusi toiminnallisuus. Kun olet valmis, palauta tehtävä TMC:lle.</p>
    </div>

      <h3>JavaScriptin alkeita</h3>

      <p>Tässä osiossa käydään pikaisesti läpi JavaScriptin alkeita.</p>

      <h4>Muuttuja</h4>

      <p>Jotta sama tieto olisi käytössä useammassa paikassa, tarvitsemme jonkun tavan tallentaa tietoa. Javascriptissä, kuten lähes kaikissa muissakin ohjelmointikieliessä, tähän käytetään muuttujia. Muuttujat esitellään sanomalla <code>var muuttujanNimi</code>, eli ensin sana <code>var</code>, jota seuraa nimi muuttujalle. Tämän jälkeen seuraa yhtäsuuruusmerkki, jota seuraa muuttujaan asetettava arvo, esimerkiksi <code>var vitonen = 5;</code>. Edellinen komento luo muuttujan <code>vitonen</code>, ja asettaa siihen arvon <code>5</code>.</p>

      <p>Alla olevassa koodissa asetamme ensin muuttujaan <code>kolme</code> arvon <code>3</code>, ja kutsumme aiemmin näkemäämme <code>alert</code>-komentoa siten, että <code>alert</code>-komento saa parametrina muuttujassa <code>kolme</code> olevan arvon.</p>

      <div class="test-js">
      <p><textarea id="js-muuttuja-ja-alert" rows="5" cols="80">var kolme = 3;
alert(kolme);
alert(kolme);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttuja-ja-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Olemassaoleviin muuttujiin voi sijoittaa uuden arvon. Seuraava koodi näyttää ensin numeron <code>3</code>, ja sitten numeron <code>4</code>. Huomaa että sana <code>var</code> esiintyy vain kun muuttuja esitellään ensimmäisen kerran. Tämän jälkeen muuttuja on jo olemassa ja sanaa <code>var</code> ei enää tarvita.</p>

      <div class="test-js">
      <p><textarea id="js-muuttuva-muuttuja-ja-alert" rows="6" cols="80">var kolme = 3;
alert(kolme);
kolme = 4;
alert(kolme);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttuva-muuttuja-ja-alert')" value="Suorita koodi!"></input></p>
      </div>


      <p>Muuttujia voi myös laskea yhteen. Koulussa opittu pluslasku toimii kuten tähänkin mennessä.</p>

      <div class="test-js">
      <p><textarea id="js-muuttujien-yhteenlasku-ja-alert" rows="6" cols="80">var kolme = 3;
var nelja = 4;
var seitseman = kolme + nelja;
alert(seitseman);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-muuttujien-yhteenlasku-ja-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä luodaan ensin muuttuja <code>kolme</code>, ja asetetaan siihen arvo 3. Tämän jälkeen luodaan uusi muuttuja nimeltä <code>nelja</code>, ja asetetaan siihen arvo 4. Tämän jälkeen luodaan uusi muuttuja <code>seitseman</code>, ja asetetaan siihen aiemmin määriteltyjen muuttujien (<code>kolme</code> ja <code>nelja</code>) arvojen summa.</p>


      <h4>Muuttujien tyypit</h4>


      <p>JavaScript, toisin kuin peruskursseillamme käytetty Java, ei ole vahvasti tyypitetty ohjelmointikieli. Tämä tarkoittaa sitä, että ohjelmointikieli ei rajoita muuttujissa käytettävien arvojen tyyppiä. Muuttujan tyyppi voi olla numero, merkkijono tai vaikkapa funktio (palaamme tähän myöhemmin...). Muuttujaan voi siis asettaa myös merkkijonon. Merkkijono aloitetaan ja lopetetaan hipsuilla (<code>""</code>).</p>

      <div class="test-js">
      <p><textarea id="js-merkkijono-muuttujassa-alert" rows="4" cols="80">var teksti = "Silloin kun minä olin nuori, koodattiin basicilla";
alert(teksti);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijono-muuttujassa-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Merkkijonojen katenaatio eli yhdistäminen onnistuu summamerkillä Javasta tutulla tavalla. </p>

      <div class="test-js">
      <p><textarea id="js-merkkijonojen-katenointi-alert" rows="6" cols="80">var eka = "2";
var toka = "3";
var summa = eka + toka;
alert(summa);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijonojen-katenointi-alert')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä muuttujaan <code>summa</code> asetetaan muuttujien <code>eka</code> ja <code>toka</code> liitos, eli merkkijono <code>"23"</code>.</p>

      <p>Jos merkkijonot haluaa muuttaa luvuiksi, tulee muunnoksessa käyttää JavaScriptin <code>parseInt</code>-funktiota. Komento <code>parseInt</code> muuttaa parametrina saadun merkkijonon kokonaisluvuksi.</p>

      <div class="test-js">
      <p><textarea id="js-merkkijonojen-katenointi-parseint-alert" rows="6" cols="80">var eka = "2";
var toka = "3";
var summa = parseInt(eka) + parseInt(toka);
alert(summa);</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-merkkijonojen-katenointi-parseint-alert')" value="Suorita koodi!"></input></p>
      </div>


      <h4>Arvojen vertaileminen ja lisää tyypeistä</h4>

      <p>Ohjelmiin tuodaan vaihtoehtoista toiminnallisuutta muuttujien ja vertailuoperaatioiden yhteistyöllä. Luodaan ohjelma, joka kysyy käyttäjältä numeroa. Jos käyttäjän antama numero on <code>5</code>, sanotaan "Oikein meni!". Vertailu onnistuu <code>if</code>-lauseella ja kahdella yhtäsuuruusmerkillä. Koska funktio <code>prompt</code> palauttaa merkkijonon, muunnetaan saatu luku numeroksi JavaScriptin <code>parseInt</code>-funktiolla.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-funktio-ja-kutsu" rows="8" cols="80">var numero = prompt("Kirjoita numero");
numero = parseInt(numero);

if (numero == 5) {
    alert("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Jos haluamme sanoa "Oikein meni!" kun käyttäjä antaa numeron <code>5</code> tai <code>7</code>, voimme tehdä erillisen <code>else if</code>-vertailun. Vertailu <code>else if</code> tulee aina vertailun <code>if</code> jälkeen, ja vertailua <code>else if</code> ei voi käyttää ilman <code>if</code>-vertailua.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-viisi-tai-seitseman-funktio-ja-kutsu" rows="10" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5) {
    alert("Oikein meni!");
} else if (numero == 7) {
    alert("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-viisi-tai-seitseman-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Lauseita <code>else if</code> voi olla peräkkäin rajoittamaton määrä. Ohjelmakoodissa voi käyttää myös Javasta tuttuja <code>||</code> (<em>tai</em>) ja <code>&&</code> (<em>ja</em>) -operaatioita vertailutulosten yhdistämiseksi.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-joku-funktio-ja-kutsu" rows="8" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5 || numero == 7) {
    alert("Oikein meni!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-joku-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Joskus haluamme tulostaa jotain, vaikka yksikään vertailu ei onnistuisi. Tällöin käytämme ehtoa <code>else</code>, joka tarkoittaa "muutoin". Lisätään yllä olevaan luvun tarkistamiseen <code>else</code>-lause, joka suoritetaan kun yksikään aiemmista ehdoista ei onnistunut.</p>

      <div class="test-js">
      <p><textarea id="js-kysyluku-elsella-funktio-ja-kutsu" rows="10" cols="80">var numero = prompt("Kirjoita joku numero?");
numero = parseInt(numero);

if (numero == 5 || numero == 7) {
    alert("Oikein meni!");
} else {
    alert("Ei onnistunut :(");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-kysyluku-elsella-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Muutkin Javasta tutut vertailuoperaatiot ovat käytössä. Suurempi kuin <code>&gt;</code> merkillä tarkistetaan onko luku suurempi kuin joku luku, ja pienempi kuin <code>&lt;</code> merkillä tarkistetaan onko luku pienempi kuin joku luku. Tehdään ohjelma, joka kysyy ikää, ja sanoo "Huijaat!", jos ikä on pienempi kuin 0 tai suurempi kuin 120. Muulloin ohjelma sanoo &quot;Et huijannut! :)&quot; .</p>


      <div class="test-js">
      <p><textarea id="kysyika-funktio-ja-kutsu" rows="10" cols="80">var ika = prompt("Mikä on ikäsi?");
ika = parseInt(ika);

if (ika < 0 || ika > 120) {
    alert("Huijaat!");
} else {
    alert("Et huijannut!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('kysyika-funktio-ja-kutsu')" value="Suorita koodi!"></input></p>
      </div>

      <p>Yllä olemme vertailleet juurikin <em>muuttujien arvoja</em>. Vertailuoperaattorin <code>==</code> yksi päänvaivaa tuottava ominaisuus on se, että vertailuoperaatio ei välitä muuttujan tyypistä. Esimerkiksi seuraava vertailu tulostaa viestin "Ehdottomasti totta!".</p>

      <div class="test-js">
      <p><textarea id="js-vertailun-tyyppi" rows="7" cols="80">var auton_merkki = "";

if(auton_merkki == false) {
    alert("Ehdottomasti totta!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-vertailun-tyyppi')" value="Suorita koodi!"></input></p>
      </div>

      <p>Jotta vertailussa otettaisiin huomioon myös muuttujan <em>sen hetkinen</em> tyyppi, käytetään kolmatta yhtäsuuri kuin -merkkiä. Jotta muuttujan tyypin saa otettua huomioon, tulee yhtäsuuruusvertailu toteuttaa kolmella yhtäsuuri kuin -merkillä (<code>===</code>).</p>

      <div class="test-js">
      <p><textarea id="js-vertailun-tyyppi-tyypilla" rows="9" cols="80">var auton_merkki = "";

if(auton_merkki === false) {
    alert("Ehdottomasti totta!");
} else {
    alert("Makes sense!");
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-vertailun-tyyppi-tyypilla')" value="Suorita koodi!"></input></p>
      </div>


      <p>Sama pätee myös erisuuri kuin (<code>!=</code>) -vertailulle.</p>

      <h4>Toistolauseet</h4>

      <p>JavaScriptissä on käytössä for- ja while-toistolauseet.</p>

      <div class="test-js">
      <p><textarea id="js-for" rows="5" cols="80">for (var i = 0; i < 5; i++) {
    alert(i);
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-for')" value="Suorita koodi!"></input></p>
      </div>

      <div class="test-js">
      <p><textarea id="js-while" rows="8" cols="80">var i = 0;

while(i < 5) {
    alert(i);
    i++;
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-while')" value="Suorita koodi!"></input></p>
      </div>

      <h4>Funktiot, parametrit, ja arvon palauttaminen</h4>

      <p>Funktioille voi antaa arvoja, joita voidaan käyttää osana funktion lähdekoodia. Tämä on kätevää erityisesti silloin, kun samanlaista toiminnallisuutta tehdään useassa paikassa: toiminnallisuudesta voi tehdä funktion, jota voi kutsua. Funktiot voivat myös palauttaa arvon, joka asetetaan muuttujaan -- muuttujaa taas voidaan käyttää osana muuta ohjelmakoodia.</p>

      <p>Funktioiden parametrit toimivat seuraavasti:</p>

<pre class="sh_javascript_dom">
function tulostaViesti(viesti) {
    alert(viesti);
}
</pre>

      <p>Kun ylläolevaa funktiota kutsutaan, sille tulee antaa parametri. Parametrille luodaan funktiokutsussa oma muuttuja <code>viesti</code>, johon parametrin arvo kopioidaan. Funktiota <code>tulostaViesti</code> suoritettaessa funktiolle <code>alert</code> annetaan aina sen arvon kopio, jonka funktio <code>tulostaViesti</code> saa parametrina.</p>

      <p>Funktiot voivat myös palauttaa arvon. Arvo palautetaan komennolla <code>return</code>, jota seuraa palautettava arvo. Seuraavassa esimerkissä on funktio <code>kysyNumeroJaTarkita</code> kutsuu komentoa <code>return</code> jos käyttäjän syöttämä arvo ei ole numero. Jos komennolle <code>return</code> ei anna palautettavaa arvoa, funktiokutsusta poistutaan ilman arvon palauttamista.</p>

<pre class="sh_javascript_dom">function kysyNumeroJaTarkista() {
    var syote = prompt("Kirjoita numero");

    if(isNaN(Number(syote))) {
        alert("Et kirjoittanut numeroa!");
        return;
    }

    numero = parseInt(syote);

    if (numero == 5 || numero == 7) {
        alert("Oikein meni!");
    }
}
</pre>

      <h4>Muuttujien näkyvyys</h4>

      <p>JavaScriptissä muuttujilla on kaksi näkyvyystyyppiä: paikallinen ja globaali. Paikalliset muuttujat ovat olemassa vain siinä funktiossa missä ne on esitelty. Globaalit muuttujat ovat olemassa kaikkialla. Muuttujia <em>voi</em> esitellä ilman määrettä <code>var</code>, jolloin ne ovat globaaleja. Tämä johtaa ennen pitkää kaaokseen. Testaa alla olevia koodeja, ja huomaa niiden ero!</p>


      <div class="test-js">
      <p><textarea id="js-varscope" rows="11" cols="80">function summaa(eka, toka) {
    summa = eka + toka;
    return summa;
}

summa = 100;
var tulos = summaa(25, 10);

alert(summa);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-varscope')" value="Suorita koodi!"></input></p>
      </div>

      <div class="test-js">
      <p><textarea id="js-varscope-proper" rows="11" cols="80">function summaa(eka, toka) {
    var summa = eka + toka;
    return summa;
}

summa = 100;
var tulos = summaa(25, 10);

alert(summa);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-varscope-proper')" value="Suorita koodi!"></input></p>
      </div>

      <p>Käytä avainsanaa <code>var</code> <strong>aina</strong> kun esittelet muuttujan.</p>


      <h4>Taulukot</h4>

      <p>Taulukkotyyppisiä muuttujia voidaan luoda komennolla <code>new Array()</code>, jolle annetaan parametrina taulukon koko. Esimerkiksi seuraavassa luodaan 3 paikkaa sisältävä taulukko. Taulukkomuuttujan indeksointi tapahtuu hakasuluilla.</p>

<pre class="sh_javascript_dom">
var salasanat = new Array(3);
salasanat[0] = "salasana";
salasanat[1] = "alasanas";
salasanat[2] = "lasanasa";
</pre>


      <p>Jos taulukon arvot tiedetään ennalta, voidaan taulukko luoda myös suoraan konstruktorikutsussa.</p>

<pre class="sh_javascript_dom">
var salasanat = new Array("salasana", "alasanas", "lasanasa");
</pre>

      <p>Taulukot voivat sisältää myös erityyppisiä muuttujia.</p>

<pre class="sh_javascript_dom">
var tiedot = new Array("Mikke", 1984);
</pre>

      <h4>Oliot</h4>

      <p>Taulukoiden lisäksi JavaScriptissä tiedon käsittelyyn käytetään <code>Object</code>-tyyppisiä muuttujia, eli olioita. Olio luodaan komennolla <code>new Object()</code>, jonka jälkeen oliolle voi asettaa arvoja.</p>

<pre class="sh_javascript_dom">
var mikke = new Object();
mikke.nimi = "Mikke";
mikke.syntymavuosi = 1984;
</pre>

      <p>Olioiden luontiin liittyy myös hieman kevyempi syntaksi, joka saattaa olla joillekin palvelinohjelmointi-kurssilla olleille tutun näköinen.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};
</pre>

      <p>Olioiden rakenne ei ole ennalta määrätty. Voimme esimerkiksi luoda muuttujalle <code>mikke</code> vaimon helposti.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};

/* miken vaimo on ikinuori */
var kate = {nimi: "Kate", syntymavuosi: new Date().getFullYear() - 21};

mikke.vaimo = kate;

/* nyt voimme kysyä miken vaimon nimeä seuraavasti */
alert(mikke.vaimo.nimi);
</pre>


      <div class="test-js">
      <p><textarea id="js-mikke-ja-kate" rows="11" cols="80">var mikke = {nimi: "Mikke", syntymavuosi: 1984};

/* miken vaimo on ikinuori */
var kate = {nimi: "Kate", syntymavuosi: new Date().getFullYear() - 25};

mikke.vaimo = kate;

/* nyt voimme kysyä miken vaimon nimeä seuraavasti */
alert(mikke.vaimo.nimi + " on syntynyt vuonna " + mikke.vaimo.syntymavuosi);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-mikke-ja-kate')" value="Suorita koodi!"></input></p>
      </div>


      <h3>Web-sivun elementtien arvojen käsittely</h3>


      <p>Palataan web-maailmaan. JavaScriptiä käytetään ennenkaikkea dynaamisen toiminnallisuuden lisäämiseksi web-sivuille. Esimerkiksi web-sivuilla oleviin elementteihin tulee pystyä asettamaan arvoja. JavaScriptissä pääsee käsiksi dokumentissa oleviin elementteihin komennolla <code>document.getElementById("tunnus")</code>, joka palauttaa elementin, jonka <code>id</code>-attribuutti on "tunnus".</p>

      <p>Alla olevassa esimerkissä on luotu tekstikenttä, jonka HTML-koodi on <code>&lt;input type="text" id="tekstikentta"/&gt;</code>. Kentän tunnus on siis <code>tekstikentta</code>. Javascriptillä on komento <code>document.getElementById("tunnus")</code>, jonka avulla voidaan hakea tietyn nimistä elementtiä. Tekstikenttäelementillä on attribuutti <code>value</code>, joka voidaan tulostaa.</p>


<div class="test-js">
      <p><input type="text" id="tekstikentta"/></p>

      <p><textarea id="js-tulosta-tekstikentan-arvo" rows="4" cols="80">var arvo = document.getElementById("tekstikentta").value;
alert("Tekstikentän arvo oli " + arvo);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-tulosta-tekstikentan-arvo')" value="Suorita koodi!"></input></p>
</div>


      <p>Tekstikentälle voidaan asettaa arvo kuten muillekin muuttujille. Alla olevassa esimerkissä haetaan edellisen esimerkin tekstikenttä, ja asetetaan sille arvo <code>5</code>.</p>

      <div class="test-js">
    <p><textarea id="js-aseta-tekstikenttaan-arvo" rows="3" cols="80">document.getElementById("tekstikentta").value = 5;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-aseta-tekstikenttaan-arvo')" value="Suorita koodi!"></input></p>
      </div>

      <p>Tehdään vielä ohjelma, joka kysyy käyttäjältä syötettä, ja asettaa sen yllä olevan tekstikentän arvoksi.</p>

      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-tekstikenttaan-arvo" rows="3" cols="80">document.getElementById("tekstikentta").value = prompt("Kirjoita jotain!");</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-tekstikenttaan-arvo')" value="Suorita koodi!"></input></p>
      </div>




      <h4>Arvon asettaminen osaksi tekstiä</h4>

      <p>Yllä tekstikentälle asetettiin arvo sen <code>value</code>-attribuuttiin. Kaikilla elementeillä ei ole <code>value</code>-attribuuttia, vaan joillain näytetään niiden elementin <em>sisällä</em> oleva arvo. Elementin sisälle asetetaan arvo muuttujaan liittyvällä attribuutilla <code>innerHTML</code>. Tässä alapuolella on esimerkiksi <code>p</code>-elementti, jonka <code>id</code> on <code>js-hidden-p-element</code>, ja jolla ei ole mitään arvoa.</p>

      <p id="js-hidden-p-element"></p>

      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-phen-arvo" rows="4" cols="80">var syote = prompt("Kirjoita jotain!");
document.getElementById("js-hidden-p-element").innerHTML = syote;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-phen-arvo')" value="Suorita koodi!"></input></p>
      </div>


      <p>Vastaavasti tekstin keskelle voi myös asettaa arvoja. Elementti <code>span</code> on tähän aivan mainio. <strong><span id="spanelementti">Tämä teksti on span-elementin sisällä, jonka tunnus on "spanelementti"</span></strong>.


      <div class="test-js">
    <p><textarea id="js-kysy-ja-aseta-spaniin-arvo" rows="4" cols="80">var syote = prompt("Kirjoita jotain!");
document.getElementById("spanelementti").innerHTML = syote;
</textarea></p>
    <p><input type="button" onclick="evalElementContent('js-kysy-ja-aseta-spaniin-arvo')" value="Suorita koodi!"></input></p>
      </div>


      <h3>Case: Laskin</h3>


      <p>Luodaan oma laskin. Laskimella on kaksi toiminnallisuutta: pluslasku ja kertolasku. Luodaan ensin laskimelle javascriptkoodi, joka on tiedostossa <code>laskin.js</code>. Javascript-koodissa oletetaan, että on olemassa <code>input</code>-tyyppiset elementit tunnuksilla "eka" ja "toka" sekä <code>span</code>-tyyppinen elementti tunnuksella "tulos". Funktiossa <code>plus</code> haetaan elementtien "eka" ja "toka" arvot, ja asetetaan pluslaskun summa elementin "tulos" arvoksi. Kertolaskussa tehdään lähes sama, mutta tulokseen asetetaan kertolaskun tulos. Koodissa on myös apufunktio, jota käytetään arvojen muuttamiseksi numeroiksi.</p>

<pre class="sh_javascript_dom">
function haeNumero(tunnus) {
    return parseInt(document.getElementById(tunnus).value);
}

function asetaTulos(tulos) {
    document.getElementById("tulos").innerHTML = tulos;
}

function plus() {
    asetaTulos(haeNumero("eka") + haeNumero("toka"));
}

function kerto() {
    asetaTulos(haeNumero("eka") * haeNumero("toka"));
}
</pre>

      <p>Laskimen käyttämä HTML-dokumentti näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Laskin&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            &lt;h1&gt;Plus- ja Kertolaskin&lt;/h1&gt;
        &lt;/header&gt;

        &lt;section&gt;
            &lt;p&gt;
                &lt;input type="text" id="eka" value="0"/ &gt;
                &lt;input type="text" id="toka" value="0" /&gt;
            &lt;/p&gt;

            &lt;p&gt;
                &lt;input type="button" value="+" onclick="plus();" /&gt;
                &lt;input type="button" value="*" onclick="kerto();" /&gt;
            &lt;/p&gt;


            &lt;p&gt;Laskimen antama vastaus: &lt;span id="tulos"&gt;&lt/span&gt;&lt;/p&gt;
        &lt;/section&gt;

        &lt;script src="laskin.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Laskin itsessään näyttää seuraavalta:</p>

<div class="naytto">
        <header>
            <h1>Plus- ja Kertolaskin</h1>
        </header>

        <section>
            <p>
                <input type="text" id="eka" value="0"></input>
                <input type="text" id="toka" value="0"></input>
            </p>

            <p>
                <input type="button" value="+" onclick="laskinPlus();"></input>
                <input type="button" value="*" onclick="laskinKerto();"></input>
            </p>


            <p>Laskimen antama vastaus: <span id="tulos"></span></p>
        </section>

        <script>
function laskinHaeNumero(tunnus) {
    return parseInt(document.getElementById(tunnus).value);
}

function laskinAsetaTulos(tulos) {
    document.getElementById("tulos").innerHTML = tulos;
}

function laskinPlus() {
    laskinAsetaTulos(laskinHaeNumero("eka") + laskinHaeNumero("toka"));
}

function laskinKerto() {
    laskinAsetaTulos(laskinHaeNumero("eka") * laskinHaeNumero("toka"));
}
</script>
</div>



<div class="tehtavat">
      <h3>Laskimen jatkokehitys</h3>

      <p>Yllä oleva laskin tulee mukana tehtäväpohjassa. Tehtävänäsi on ensin lisätä laskimelle myös miinus- ja jakolaskut. Kun miinus- ja jakolasku toimii, integroi visualisoinnista tykkäävän kaverisi alla oleva koodi osaksi laskimen toimintaa. Alla oleva koodi lisää laskimeen piirtoelementin, sekä piirtää ruudulle liikkuvan neliön, jonka vauhti riippuu tuloksesta.</p>


      <pre class="sh_html">
        &lt;section&gt;
            &lt;canvas id="alusta" width="300" height="200" &gt;&lt;/canvas&gt;
        &lt;/section&gt;</pre>


      <pre class="sh_javascript_dom">
window.requestAnimFrame = (function(){
    return window.requestAnimationFrame       ||
           window.webkitRequestAnimationFrame ||
           window.mozRequestAnimationFrame    ||
           window.oRequestAnimationFrame      ||
           window.msRequestAnimationFrame     ||
           function(/* kutsuttava funktio */ callback, /* elementti */ element){
               window.setTimeout(callback, 1000 / 60);
           };
    })();


function ajasta() {
    piirra();
    requestAnimFrame( ajasta );
}

function piirra() {
    var piirturi = document.getElementById("alusta").getContext("2d");
    var nopeus = parseInt(document.getElementById("tulos").innerHTML);
    if(!nopeus) {
        nopeus = 2;
    }

    if(nopeus < 0) {
        nopeus = 1 / (nopeus * -1);
    }

    var aika = new Date().getTime() * 0.001 * nopeus;
    var x = Math.sin( aika ) * 100 + 125;

    //  piirretään ensin valkoinen tausta
    piirturi.fillStyle = "rgb(255, 255, 255)";
    piirturi.fillRect( 0, 0, 300, 200 );

    // ja sitten neliö
    piirturi.fillStyle = "rgb(255,0,0)";
    piirturi.fillRect(x, 50, 50, 50);
}

ajasta();
      </pre>

      <p>Kun olet valmis, ja sivun ladatessa näet liikkuvan punaisen neliön, jonka vauhti riippuu laskimen tuloksesta, palauta tehtävä TMC:lle.</p>
    </div>
</div>



      <h3>Case: Tyylien muuttaminen JavaScriptillä</h3>


      <p>JavaScriptiä voi käyttää myös tyylien muokkaamiseen. Attribuutin <code>class</code> arvoa voi muuttaa dokumentista saatavan olion attribuutilla <code>className</code>. Tehdään vielä esimerkki, jossa sivulla oleva tieto vaihtuu linkkiä klikkaamalla, <em>mutta</em> selain ei oikeasti siirry sivulta toiselle. Luodaan ensiksi HTML-dokumentti, jossa on valmiiksi paikat tyylitiedostolle <code>style.css</code> ja lähdekoodille <code>script.js</code>.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;!-- komento return false; estää selaimen siirtymisen toiselle sivulla --&gt;
                &lt;a href="#" onclick="displayArticle(0);return false;"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#" onclick="displayArticle(1);return false;"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;article&gt;
      &lt;h1&gt;Eka artikkeli&lt;/h1&gt;

      &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&lt;/p&gt;
    &lt;/article&gt;

        &lt;article&gt;
      &lt;h1&gt;Toka artikkeli&lt;/h1&gt;

      &lt;p&gt;Morbi a elit enim, sit amet iaculis massa. Vivamus blandit...&lt;/p&gt;
    &lt;/article&gt;

        &lt;article&gt;
      &lt;h1&gt;Kolmas artikkeli&lt;/h1&gt;

      &lt;p&gt;Now that we know who you are, I know who I am. I'm...&lt;/p&gt;
    &lt;/article&gt;


        &lt;script src="script.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Luodaan seuraavaksi sivulle tyylitiedosto. Määritellään <code>article</code>-elementille tyyliluokka "hidden": jos article-elementillä on tyyliluokka hidden, sitä ei näytetä selaimessa.</p>

<pre class="sh_css">
article.hidden {
    display: none;
}
</pre>

      <p>Luodaan seuraavaksi JavaScript-toiminnallisuus. Emme käsittele sivua tunnusten avulla, vaan käytämme elementtien läpikäyntiin niiden tyyppejä. Haluamme käytännössä käsitellä kaikkia sivulla olevia <code>article</code>-elementtejä. Tähän on kätevä komento <code>document.getElementsByTagName("elementinNimi")</code>, joka palauttaa taulukon elementeistä, joiden elementin nimi on "elementinNimi". Haluamme myös, että kun sivu on ladattu, näytetään vain ensimmäinen artikkeli. Tätä varten <code>body</code>-elementille on olemassa attribuutti <code>onload</code>, jolle voi määritellä funktion nimen, jota kutsutaan kun sivun lataaminen on valmis.</p>

<pre class="sh_javascript_dom">
function init() {
    displayArticle(0);
}

function displayArticle(index) {
    var articles = document.getElementsByTagName("article");

    for(var i = 0; i < articles.length; i++) {
        if (index == i) {
            articles[i].className='';
        } else {
            articles[i].className='hidden';
        }
    }
}
</pre>

      <p>Voit tutustua valmiin sivun toiminnallisuuteen <a href="vk1-esim-dynaaminen-sivu.html" target="_blank">täällä</a>.</p>



    <div class="tehtavat">
      <h3>PerusMOOC (3p)</h3>

      <p>Huom! Tämä tehtävä on kolmen pisteen arvoinen: palauta se vain jos teet tehtävän kokonaan.</p>

      <p>Tehtävässä on käytetty seuraavia värejä:</p>

      <ul>
    <li>rgb(233, 229, 217);</li>
    <li>rgb(73, 69, 69);</li>
    <li>rgb(66, 126, 120);</li>
      </ul>

      <p>Fonttien määrittely on muotoa</p>
<pre class="sh_css">
    font-family: 'Trebuchet MS', Trebuchet, Arial, sans-serif;
</pre>


      <p>Tehtävän mukana tuleva sivu näyttää seuraavanlaiselta:</p>

      <img src="img/perusmooc-1.png" border=1/>

      <p>Tehtävänäsi on ensin lisätä sivulle tyylitiedosto, jonka avulla sivusta tulee seuraavannäköinen. Kun lisäät tyylitiedostoa, lisää valikkoon myös toiminnallisuus, jonka avulla linkin tausta muuttuu kun hiiri on sen päällä.</p>

      <img src="img/perusmooc-2.png" border=1/>


      <p>Kun tyylit ovat valmiit, lisää sivulle toiminnallisuus, jossa vain ensimmäinen osio näkyy ensin. Linkkejä klikkaamalla sivulla vaihdetaan osiosta toiseen. Alla olevassa kuvassa osiota "Materiaali" on juuri klikattu.</p>


      <img src="img/perusmooc-3.png" border=1/>

      <p>Kun olet valmis, ja sivusi näyttää oikealta Chromessa, palauta tehtävä TMC:lle.</p>

    </div>
</section>
<section class="week">
    <header>
        <a name="viikko1"></a>
        <h1 data-week-id="2">Viikko 2</h1>
    </header>

    <h2>DOM</h2>

    <p>DOM (<em>Document Object Model</em>) on ohjelmointirajapinta HTML (ja XML) -dokumenttien rakenteen ja sisällön muokkaamiseksi. Se sisältää kuvauksen HTML-dokumentin elementeistä ja niiden asemoinnista dokumentissa. HTML-dokumentti kuvataan usein puumaisena tietorakenteena, jossa jokainen sivun elementti on puun solmu (oksa) tai lehti (solmu, josta ei lähde oksia). Jokaisella elementillä on myös nimi, jolla siihen pääsee käsiksi.</p>

    <p>Suurin osa nykyaikaisista web-selaimista toteuttaa <a href="http://www.w3.org/DOM/" target="_blank">W3C DOM</a>-standardin, sekä usein tarjoavat omia lisävälineitä dokumenttien muokkaamiseen. W3C DOM-standardi sisältää esimerkiksi aiemmin käyttämämme kutsun <code>document.getElementById("tunnus")</code>, jonka avulla päästään käsiksi dokumentin sisältämään elementtiin, jonka attribuutin <code>id</code> arvo on "tunnus".</p>

    <p>HTML-dokumentin elementit ja niihin liittyvät ominaisuudet (attribuutit, tapahtumat, ...) on jäsennelty erilaisiin olioihin. Osaan pääsee käsiksi suoraan. Esimerkiksi <code>window</code>-oliolla päästään käsiksi mm. selainikkunassa tapahtuviin tapahtumiin (esim. näppäimistön kuuntelu), <code>document</code>-olio taas liittyy HTML-dokumenttiin ja sen sisältämiin elementteihin. Kaikkiin dokumentin elementteihin pääsee käsiksi <code>document</code>-elementin kautta.</p>

    <p>Esimerkiksi dokumentissa olevan <code>canvas</code>-elementin saa haettua siihen liittyvällä tunnuksella <code>document</code>-oliota käyttäen. Mozillan sovelluskehittäjien sivustolla on hyvä kuvaus elementteihin liittyvistä rajapinnoista, kts. <a href="https://developer.mozilla.org/en-US/docs/Gecko_DOM_Reference#HTML_element_interfaces" target="_blank">https://developer.mozilla.org/en-US/docs/Gecko_DOM_Reference#HTML_element_interfaces</a>.</p>

    <p>DOM-standardi sisältää useita tasoja, eli versioita. <a href="http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/" target="_blank">Taso 1</a> sisältää mm. dokumentin elementtien luomisen sekä hakemisen <code>getElementsByTagName</code>-komennolla. Kutsu <code>getElementsByTagName</code> attribuutilla <code>*</code> palauttaa listan, joka sisältää kaikki sivun elementit. Lähes kaikki nykyään käytössä olevat selaimet tukevat tason 1 toiminnallisuutta. <a href="http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/" target="_blank">Taso 2</a> sisältää mm. tuen dokumentin tyylien muokkaamiseen DOM-puun kautta sekä erilaisten tapahtumien (mm. hiiri, näppäimistö) käsittelyä tukevan järjestelmän. <a href="http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407/" target="_blank">Taso 3</a> laajentaa tason 2 toiminnallisuutta mm. dokumentin elementtien ja tapahtumien käsittelyssä.</p>

    <p>DOM-spesifikaatio sisältää useita eri komponentteja. Alla kuva DOM-arkkitehtuurista.</p>

    <p><img src="img/dom-architecture.png"></p>

    <p>W3C työskentelee tällä hetkellä (1.11.2012) tason 4 spesifikaation kanssa. <a href="http://www.w3.org/TR/domcore/" target="_blank">Taso 4</a> tulee olemaan laajennus aiempiin tasoihin, joka tarjoaa mm. selvennyksiä tapahtumien käsittelyyn ja lisätoiminnallisuuksia dokumentin identifiointiin.</p>

    <div class="extra">
      <p><strong>Selaintuki</strong></p>

      <p>Uusimpien DOM-spesifikaatioiden ja lisäosien tuki on rikkinäinen osassa selaimia. Selainvalmistajat eivät usein kiinnitä huomiota vanhempiin selainversioihin, jolloin uudet ominaisuudet ovat käytössä vasta uudemmissa selaimissa. Sivusto "Can I Use..." (<a href="http://caniuse.com" target="_blank">http://caniuse.com</a> on yksi monista sivustoista, jotka tarjoavat spesifikaatioiden ja lisäosien yhteensopivuuslistauksia eri selaimille.</p>

    </div>


<!--
query selectorit http://www.w3.org/TR/selectors-api/
-->

    <h3>Elementtien valinta</h3>

    <p>Olemme käyttäneet dokumentin <code>getElementById</code>-kutsua tietyn elementin hakemiseen. Kaikki sivun elementit voi taas hakea esimerkiksi <code>getElementsByTagName("*")</code>-kutsulla. Molemmat ovat kuitenkin hieman kömpelöjä jos tiedämme mitä haluamme hakea verrattuna esimerkiksi CSS:n käyttämään elementtien valintatyyliin (kts. <a href="http://www.w3.org/TR/selectors/#selectors" target="_blank">http://www.w3.org/TR/selectors/#selectors</a>.</p>

    <p>W3C DOM-määrittely sisältää myös paremman ohjelmointirajapinnan elementtien läpikäyntiin. <a href="http://www.w3.org/TR/selectors-api/" target="_blank">Selectors API</a> sisältää mm. <code>querySelector</code>-kutsun, jolla saadaan CSS-valitsinten kaltainen kyselytoiminnallisuus.</p>

    <p>Selector APIn tarjoamien <code>querySelector</code> (yksittäisen osuman haku) ja <code>querySelectorAll</code> (kaikkien osumien haku) -komentojen avulla kyselyn rajoittaminen vain <code>header</code>-elementissä oleviin <code>a</code>-elementteihin on helppoa.</p>

<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("nav a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat nav-elementin sisällä
</pre>

    <p>Vastaavasti <code>header</code>-elementin sisällä olevat linkit voi hakea seuraavanlaisella kyselyllä.</p>

<pre class="sh_javascript_dom">
var linkit = document.querySelectorAll("header a");
// linkit-muuttuja sisältää nyt kaikki a-elementit, jotka ovat header-elementin sisällä
</pre>


    <p>Myös tietyn luokan toteuttavien elementtien haku on helppoa. Alla olevassa esimerkissä on kolme tekstikenttää, joista 2 on piilotettu. Piilotettujen tekstikenttien tyyliluokka on <code>dom-esim-1-hidden</code>.</p>

<style>
.dom-esim-1-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="dom-esim-1">
    <p class="dom-esim-1-hidden">text 1</p>
    <p>text 2</p>
    <p class="dom-esim-1-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="dom-esim-1-js" rows="4" cols="80">var elementit = document.querySelectorAll(".dom-esim-1-hidden");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-1-js')" value="Suorita koodi!"></input></p>
    </div>


    <p>Voimme hakea querySelectorin avulla myös elementtejä, joilta puuttuu tietty ominaisuus. Alla haemme kaikki tyyliluokan <code>dom-esim-2</code> toteuttavan elementin sisällä olevat <code>p</code>-elementit, joilla ei ole tyyliluokkaa <code>dom-esim-2-hidden</code>. Lopuksi lisäämme kyselyssä löydetyille elementeille tyyliluokan <code>dom-esim-2-hidden</code>, jolloin elementit piilotetaan.</p>

    <p>Alla olevan sivun lähdekoodi on seuraavanlainen (tyyliluokkien oudot nimet johtuvat tämän dokumentin rakenteesta -- haluamme että esimerkit eivät vaikuta toisiin esimerkkeihin).</p>

<pre class="sh_html">
  &lt;article class="dom-esim-2"&gt;
    &lt;p class="dom-esim-2-hidden"&gt;text 1&lt;/p&gt;
    &lt;p&gt;text 2&lt;/p&gt;
    &lt;p class="dom-esim-2-hidden"&gt;text 3&lt;/p&gt;
  &lt;/article&gt;
</pre>

<style>
.dom-esim-2-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="dom-esim-2">
    <p class="dom-esim-2-hidden">text 1</p>
    <p>text 2</p>
    <p class="dom-esim-2-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="dom-esim-2-js" rows="5" cols="100">var elementit = document.querySelectorAll(".dom-esim-2 p:not(.dom-esim-2-hidden)");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "dom-esim-2-hidden";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-2-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Mitä käy jos poistat ylläolevasta kyselystä alkuosan <code>dom-esim-2</code> ja suoritat kyselyn? Pohdi ennen kokeilemista!</p>


    <h3>Elementtien lisääminen</h3>

    <p>HTML-dokumenttiin lisätään uusia elementtejä <code>document</code>-olion <code>createElement</code>-metodilla. Esimerkiksi alla luodaan <code>p</code>-elementti, joka asetetaan muuttujaan <code>tekstiElementti</code>. Tämän jälkeen luodaan tekstisolmu, joka sisältää tekstin "o-hai". Lopulta tekstisolmun lisätään tekstielementtiin.</p>

<pre class="sh_javascript_dom">
var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-hai");

tekstiElementti.appendChild(tekstiSolmu);
</pre>

    <p>Ylläoleva esimerkki ei luonnollisesti muuta HTML-dokumentin rakennetta sillä uutta elementtiä ei lisätä osaksi HTML-dokumenttia. Olemassaoleviin elementteihin voidaan lisätä sisältöä elementin <code>appendChild</code>-metodilla. Alla olevan tekstialue sisältää <code>article</code>-elementin, jonka tunnus on <code>dom-esim-3</code>. Voimme lisätä siihen elementtejä elementin <code>appendChild</code>-metodilla.</p>

    <div class="naytto">
      <div id="dom-esim-3">
      </div>
    </div>

    <div class="test-js">
      <p><textarea id="dom-esim-3-js" rows="7" cols="80">var tekstiElementti = document.createElement("p");
var tekstiSolmu = document.createTextNode("o-noes!");

tekstiElementti.appendChild(tekstiSolmu);

var alue = document.getElementById("dom-esim-3");
alue.appendChild(tekstiElementti);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-3-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Artikkelielementin sekä sen sisältämien tekstielementtien lisääminen onnistuu vastaavasti. Alla olevassa esimerkissä käytössämme on seuraavanlainen <code>section</code>-elementti.</p>

<pre class="sh_html">
&lt;!-- .. dokumentin alkuosa .. --&gt;
    &lt;section id="dom-esim-4"&gt;&lt;/section&gt;
&lt;!-- .. dokumentin loppuosa .. --&gt;
</pre>

    <p>Uusien artikkelien lisääminen onnistuu helposti aiemmin näkemällämme <code>createElement</code>-metodilla.</p>

    <div class="naytto">
      <section id="dom-esim-4">
      </section>
    </div>

    <div class="test-js">
      <p><textarea id="dom-esim-4-js" rows="12" cols="80">var artikkeli = document.createElement("article");

var teksti1 = document.createElement("p");
teksti1.appendChild(document.createTextNode("Lorem ipsum... 1"));
artikkeli.appendChild(teksti1);

var teksti2 = document.createElement("p");
teksti2.appendChild(document.createTextNode("Lorem ipsum... 2"));
artikkeli.appendChild(teksti2);

document.getElementById("dom-esim-4").appendChild(artikkeli);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-4-js')" value="Suorita koodi!"></input></p>
    </div>

    <div class="tehtavat">
      <NEXTWEEK></NEXTWEEK>

      <h3>DOM Walker</h3>

      <p>Luo tehtäväpohjaan koodi, joka käy läpi kaikki sivun <code>body</code>-elementin sisällä olevat elementit, ja tulostaa niiden tägien nimet elementtiin, jonka tunnus on "dom". Älä tulosta "dom"-tunnuksella varustettuun elementtiin "dom"-tunnuksellista elementtiä tai sen sisällä olevia elementtejä. Koodi tulee suorittaa kun sivu on ladattu.</p>

      <p>Tehtäväpohjan mukana olevan sivun kanssa koodi tulostaa sivun loppuun seuraavanlaisen listan elementtejä. Voit käyttää <code>p</code>-elementtiä tägien nimien erotteluun.</p>

<pre>
HEADER

H1

NAV

UL

LI

A

LI

A

SECTION

HEADER

H1

ARTICLE

P

SECTION

HEADER

H1

ARTICLE

P

SCRIPT
</pre>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>


    </div>

<!--
elementtien lisääminen ja poistaminen js:llä
elementtien lapset ja niiden läpikäynti
-->

    <h3>Elementtien poistaminen</h3>

    <p>Dokumentin puumaisen rakenteen takia elementin lisääminen tapahtuu elementin vanhempaan liittyvällä <code>appendChild</code>-metodilla. Koska elementin vanhempi pitää kirjaa kaikista sen lapsista, tulee elementti myös poistaa sen vanhemman kautta.</p>

    <p>DOM-puun elementtien toteuttamat <a href="https://developer.mozilla.org/en-US/docs/DOM/element#Methods" target="_blank">metodit</a> sisältävät metodin <code><a href="https://developer.mozilla.org/en-US/docs/DOM/Node.removeChild" target="_blank">removeChild</a></code>, jota voi käyttää lapsielementin poistamiseen. Alla olevassa esimerkissä haluamme poistaa elementin, jonka tunnus on "poistettava".</p>

<pre class="sh_javascript_dom">
// myös document.getElementById("poistettava") käy
var poistettava = document.querySelector("#poistettava");
poistettava.parentNode.removeChild(poistettava);
</pre>


<pre class="sh_html">
&lt;!-- .. dokumentin alkuosa .. --&gt;
    &lt;article id="poistettava"&gt;
        &lt;p&gt;Lorem Ipsum jne..&lt;/p&gt;
    &lt;/article&gt;
&lt;!-- .. dokumentin loppuosa .. --&gt;
</pre>

<div class="naytto">
  <article id="poistettava">
    <p>Lorem Ipsum jne..</p>
  </article>
</div>


    <div class="test-js">
      <p><textarea id="dom-esim-5-js" rows="3" cols="80">var poistettava = document.querySelector("#poistettava");
poistettava.parentNode.removeChild(poistettava);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('dom-esim-5-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Yllä olevan koodin suorituksen jälkeen elementti on poistettu DOM-puusta. Nykyaikaisissa selaimissa oleva roskienkeruumekanismi poistaa myös poistettavien elementtien lapsielementit.</p>

    <h3>Tapahtumien käsittely</h3>

    <p>Tason 2 DOM-spesifikaatiossa määriteltiin tuki tapahtumien käsittelylle, kts. <a href="http://www.w3.org/TR/DOM-Level-2-Events/" target="_blank">http://www.w3.org/TR/DOM-Level-2-Events/</a>. Tason 3 spesifikaatio ei ole vielä valmis, mutta sen viimeisin versio löytyy <a href="http://www.w3.org/TR/DOM-Level-3-Events/" target="_blank">täältä</a>).</p>

    <p>Jokaisella tapahtumalla on kohde, johon se liittyy. Kun sivuilla tapahtuu tapahtuma, esimerkiksi hiirellä klikataan nappia, DOM-toteutus ohjaa tapahtuman napin tapahtumankuuntelijalle. Jos napille on rekisteröity tapahtumankuuntelija, suoritetaan tapahtumankuuntelijan koodi. Tapahtumien käsittelyä varten sivuille tulee määritellä funktioita. Olemme aiemmin määritelleet tapahtumien sattuessa kutsuttavat osana HTML-dokumenttia seuraavasti.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;!-- komento return false; estää selaimen siirtymisen toiselle sivulla --&gt;
                &lt;a href="#" onclick="displayArticle(0);return false;"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#" onclick="displayArticle(1);return false;"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Vastuiden erottamisen näkökulmasta yllä oleva lähestymistapa on väärä. Haluamme eriyttää sovelluslogiikan käyttöliittymästä. Ainoa HTML-dokumentissa sallittu JavaScript-kutsu on <code>body</code>-elementin <code>onload</code>-attribuutille määriteltävä kutsu, joka suoritetaan kun sisältö on ladattu.</p>

    <p>Yksi tapa poistaa ylläolevassa dokumentissa olevat JavaScript-kutsut on lisätä init-metodiin tapahtumankäsittelijöiden lisääminen. Käytetään aiemmin oppimaamme <code>querySelector</code>-toteutusta siihen, että lisäämme tapahtumankäsittelijät vain menuvalikon linkkeihin. Jotta saisimme tapahtumankäsittelijän toimimaan oikein <code>a</code>-elementissä, meidän tulee myös kieltää linkin seuraaminen. Tämä onnistuu tapahtumaan liittyvällä kutsulla <code>preventDefault()</code>.</p>

<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        link.onclick = function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }
    }

    // ...
}
</pre>

    <p>Nyt aiempi sivumme toimii myös seuraavannäköisenä.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body onload="init();" &gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;a href="#"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Toka artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

        &lt;!-- muu sisältö --&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Oikeastaan yllä käyttämämme lähestymistapa on myös hieman hölmö. Kun määrittelemme <code>onclick</code>-funktion, korvaamme aiemman funktion. Fiksumpaa olisi lisätä uusi funktio aiempien lisäksi. Tämä onnistuu elementteihin liittyvällä metodilla <code>addEventListener</code>. Metodille <code>addEventListener</code> määritellään tapahtuman nimi (esim <code>click</code>, huomaa ero!), funktio jota kutsutaan (joko funktion nimi tai konkreettinen toteutus), ja totuusarvoinen muuttuja, jolla kerrotaan tuleeko muun dokumentin reagoida tapahtumaan. Tällöinkin tapahtumaan reagoivat vain elementit, jotka ovat tapahtuman laukaisevan elementin vanhempia.</p>


<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
}
</pre>

    <p>Tapahtumankäsittelyyn liittyvän funktion voi määritellä myös erikseen, jolloin tapahtumankäsittelijää lisättäessä funktioon viitataan sen nimellä.</p>


<pre class="sh_javascript_dom">
function handleLinkClick(eventInformation) {
    var origin = eventInformation.target;

    // kutsutaan erillistä displayArticle-funkiota, joka
    // näyttää halutun artikkelin
    displayArticle(origin.id);

    // kielletään selainta tekemästä oletustoiminto (siirtyminen)
    eventInformation.preventDefault();
}

function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', handleLinkClick, false);
    }

    // ...
}
</pre>

    <p>Lisää eri tapahtumatyypeistä ja tapahtumankäsittelystä löydät esim. <a href="http://www.w3.org/TR/DOM-Level-2-Events/events.html" target="_blank">täältä</a>.</p>


    <div class="tehtavat">
      <h3>PerusMOOC, jatkoa</h3>

      <p>Tehtäväpohjassa on viime viikon loppupuolelta alustava PerusMOOC-sivu. Sivulla on kuitenkin vielä ongelma: html-sivu sisältää JavaScriptiä enemmän kuin on sallittu.</p>

      <p>Muuta sivustoa siten, että ainoa <code>index.html</code>-sivun JavaScript-kutsu on <code>body</code>-elementin <code>onload</code>-attribuutille asetettu <code>init();</code>-funktiokutsu. Sivun toiminnallisuuden tulee pysyä ennallaan.</p>
      <p>Varaudu myös siihen, että linkeille saatetaan asettaa myöhemmin toteutettavissa koodeissa uusia tapahtumankäsittelijöitä.</p>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>

    </div>


    <h2>Lisää JavaScriptistä</h2>

    <p>Käydään läpi hieman tarkemmin JavaScriptiin liittyviä mielenkiintoisuuksia, sekä tutustutaan hyviin ohjelmointikäytänteisiin.</p>

    <h3>Muuttujien näkyvyys</h3>

    <p>Olemme aiemmin todenneet, että JavaScriptissä muuttujilla on kaksi eri näkyvyystyyppiä, paikallinen ja globaali. Paikallisella näkyvyydellä tarkoitetaan että muuttujat ovat olemassa vain funktion sisällä, ja globaalilla sitä, että muuttujat ovat näkyvissä kaikkialla. Kun muuttuja määritellään <code>var</code>-etuliitteellä, on se olemassa funktiossa, jossa se on määritelty.</p>

    <p>Mitä tarkoittaa "muuttuja on olemassa funktiossa, jossa se on määritelty"? Pohdi seuraavaa ohjelmaa ja päättele mitä tapahtuu kun painat "Suorita koodi!"-nappia.</p>

    <div class="test-js">
      <p><textarea id="js-nakyvyys" rows="11" cols="80">var summa = 21;

function mitaKay() {
    if (false) {
        var summa = 42;
    }

    alert(summa);
}

mitaKay();</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-nakyvyys')" value="Suorita koodi!"></input></p>
    </div>


    <p>Uskoisimme, että et arvannut lopputulosta, jollet tuntenut JavaScriptiä ennalta.</p>

    <p>Käytännössä JavaScript siirtää muuttujien määrittelyt funktion alkuun, mutta muuttujien arvon asetus tapahtuu alkuperäisen koodin määrittelemässä kohdassa. Ylläoleva koodi tulkitaan JavaScript-tulkin toimesta seuraavasti.</p>

<pre class="sh_javascript_dom">
var summa = 21;

function mitaKay() {
    var summa;

    if (false) {
        summa = 42;
    }

    alert(summa);
}

mitaKay();
</pre>

    <p>Koska ylläolevassa ohjelmakoodissa funktion <code>mitaKay</code> sisällä määritellylle muuttujalle <code>summa</code> ei koskaan aseteta arvoa, on sen arvo <code>undefined</code>.</p>


    <h3>Olio-ohjelmointi ja prototyyppimalli</h3>

    <p>Olio-ohjelmoinnissa kyse on ennen kaikkea ongelma-alueen käsitteiden mallintamisesta osana ohjelmakoodia. Olio-ohjelmoinnissa ohjelmoijat pyrkivät puhumaan samoilla käsitteillä kuin ohjelmistoa tilaavat asiakkaat. Käsitteet liittyvät maailmassa olevaan dataan, ja ovat interaktiossa toisten käsitteiden kanssa olioihin liittyvien metodien kautta.</p>

    <p>Kommunikaation ja käsitemaailman helpottamisen lisäksi olio-ohjelmoinnissa ohjelma hajoitetaan hallittaviksi osiksi, jotka kapseloivat pienempää toiminnallisuutta. Kukin olio voi sisältää dataa sekä lähettää ja vastaanottaa informaatiota.</p>

    <p>JavaScriptissä ei ole mm. Javasta tuttuja luokkia, vaan uusien olioiden luominen tapahtuu funktiokutsuilla. JavaScript-kielen oliomalli perustuu funktioihin, joiden prototyyppeihin voidaan liittää uusia funktioita.</p>

    <p>Tutkitaan hieman erilaisia koodiesimerkkejä.</p>

    <p>Luodaan uusi olio <code>new Object()</code>-kutsulla. Oliolle asetetaan muuttujat <code>nimi</code> ja <code>ika</code>.</p>

<pre class="sh_javascript_dom">
var mikke = new Object();
mikke.nimi = "Michael Knight";
mikke.ika = 17;

alert(mikke.nimi);
</pre>

    <p>Ylläoleva ohjelmakoodi vastaa allaolevaa olion luomista.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael Knight", ika: 17};
alert(mikke.nimi);
</pre>

    <p>Olion muuttujiin pääsee käsiksi myös seuraavanlaisen notaation avulla. Notaatio saattaa olla tuttu mikäli on aiemmin ohjelmoinut esimerkiksi PHP:llä tai perlillä.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael Knight", ika: 17};
alert(mikke["nimi"]);
</pre>

    <p>Käytännössä oliot JavaScriptissä ovat kokoelmia avain-arvo -pareja. Jokaisella oliolla voi olla omanlaisensa avaimet ja niiden arvot. Kaikki JavaScriptin oliot laajentavat valmista <code>Object</code>-oliota.</p>


    <h4>Omien olioiden luonti</h4>

    <p>Omien olioiden luonti tapahtuu funktioiden avulla. Huomaa heti alkuun hyvä nimeämiskäytäntö: funktiot, joita käytetään olioiden luomiseen nimetään isolla alkukirjaimella. Luodaan funktio <code>Opiskelija</code>, jota käytetään opiskelija-olioiden luomiseen. Opiskelijalla on kaksi attribuuttia: nimi ja opintopisteet.</p>

<pre class="sh_javascript_dom">
function Opiskelija(nimi) {
    this.nimi = nimi;
    this.opintopisteet = 0;
}
</pre>

    <p>Huomaa ylläolevan määrittelyn määre <code>this</code>. Määreellä <code>this</code> kerrotaan, että käsitellyn muuttujan arvo liittyy juuri tähän olioon. Kun funktio <code>Opiskelija</code> on määritelty, voimme luoda uusia opiskelijaolioita seuraavasti.</p>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

alert("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
alert("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

    <p>Ohjelma näyttää pop-up -ikkunat, joissa on viestit</p>

<pre>
Nimi Michael, noppia: 0
Nimi Casper, noppia: 400
</pre>

    <p>Jokaisella funktiolla on prototyyppi, joka sisältää tiedon funktioon liittyvistä attribuuteista. Prototyypin kautta lisättävien funktioiden avulla pääsemme käsiksi olioiden this-viitteeseen, mikä mahdollistaa olion sisäisen tilan muuttamisen.</p>

    <p>Koska attribuutit voivat olla myös funktioita, funktion prototyypille voidaan määritellä uusia metodeja, joilla olion tilaa voidaan muokata. Lisätään funktiolle <code>Opiskelija</code> prototyyppifunktio <code>opiskeleYksin</code>, joka kasvattaa opintopisteiden määrää yhdellä.</p>

<pre class="sh_javascript_dom">
Opiskelija.prototype.opiskeleYksin = function() {
    this.opintopisteet++;
}
</pre>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

mikke.opiskeleYksin();

alert("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
alert("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

    <p>Nyt näemme ylläolevalla koodilla pop-up -ikkunat, joissa on viestit</p>

<pre>
Nimi Michael, noppia: 1
Nimi Casper, noppia: 400
</pre>

    <p>Lisätään funktiolle <code>Opiskelija</code> vielä toinen prototyyppifunktio <code>opiskeleYhdessa</code>, joka saa parametrina toisen opiskelijan. Voimme tarkistaa että parametrina saatu muuttuja on jotain tiettyä tyyppiä <code>instanceof</code>-vertailuoperaatiolla. Viitettä <code>this</code> voi käyttää olioon liittyvien funktioiden kutsumisessa.</p>

<pre class="sh_javascript_dom">
Opiskelija.prototype.opiskeleYhdessa = function(kanssaOpiskelija) {
    if(!(kanssaOpiskelija instanceof Opiskelija)) {
        this.opiskeleYksin();
        return;
    }

    this.opintopisteet += 2;
    kanssaOpiskelija.opintopisteet += 2;
}
</pre>

<pre class="sh_javascript_dom">
var mikke = new Opiskelija("Michael");
var kasper = new Opiskelija("Casper");
kasper.opintopisteet = 400;

mikke.opiskeleYksin();
mikke.opiskeleYhdessa(kasper);

mikke.opiskeleYhdessa("porkkana");

alert("Nimi " + mikke.nimi + ", noppia: " + mikke.opintopisteet);
alert("Nimi " + kasper.nimi + ", noppia: " + kasper.opintopisteet);
</pre>

<pre>
Nimi Michael, noppia: 4
Nimi Casper, noppia: 402
</pre>


    <div class="tehtavat">
      <h3>Oliolaskuri</h3>

      <p>Luo tehtäväpohjan mukana tulevalle HTML-sivulle toiminnallisuus, jossa nappia painettaessa sivulla näkyvässä tekstissä olevan numeron arvo kasvaa aina yhdellä. HTML-sivulle saa asettaa vain yhden JavaScript-kutsun, joka tulee <code>body</code>-elementin <code>onload</code>-attribuuttiin.</p>

      <p>Toteuta apuvälineeksi olion luova funktio <code>Laskin</code> jolla on muuttuja <code>luku</code>. Lisää funktiolle <code>Laskin</code> funktiot <code>kasvata</code>, joka kasvattaa olion luvun arvoa yhdellä, ja <code>annaLuku</code>, joka palauttaa olion luvun arvon.</p>

      <p>Varaudu siihen, että napille voidaan asettaa myöhemmin uusia tapahtumankäsittelijöitä.</p>

      <p>Kun sovellus toimii toivotusti, palauta se TMC:lle.</p>

    </div>


    <h4>Esimerkki: Kurssikirjanpito</h4>

    <p>Luodaan Opiskelijan lisäksi vielä funktiot Kurssin ja Kurssisuorituksen luomiseen. Kurssilla on nimi ja opintopistemäärä, kurssisuoritus sisältää viitteen suoritettuun kurssiin ja opiskelijaan sekä suorituspäivämäärän ja arvosanan. Suorituspäivämääränä käytetään suoritusolion luontipäivämäärää.</p>

<pre class="sh_javascript_dom">
function Kurssi(nimi, opintopisteet) {
    this.nimi = nimi;
    this.opintopisteet = opintopisteet;
}

function Kurssisuoritus(opiskelija, kurssi, arvosana) {
    this.opiskelija = opiskelija;
    this.kurssi = kurssi;
    this.arvosana = arvosana;
    this.paivamaara = new Date();
}
</pre>

    <p>Näiden lisäksi käytössämme on Kirjanpito, johon voi lisätä opiskelijoiden suorituksia. Kirjanpito tarjoaa nopean pääsyn kurssiin liittyviin suorituksiin ja opiskelijan suorituksiin. Alla oletetaan, että kurssien ja opiskelijoiden nimet ovat yksikäsitteiset.</p>

<pre class="sh_javascript_dom">
function Kirjanpito() {
    // kaikki suoritukset
    this.kurssisuoritukset = new Array();

    // opiskelijakohtaiset suoritukset
    this.opiskelijanSuoritukset = {};

    // kurssikohtaiset suoritukset
    this.kurssinSuoritukset = {};
}

Kirjanpito.prototype.lisaaSuoritus = function(kurssi, opiskelija, arvosana) {
    var suoritus = new Kurssisuoritus(opiskelija, kurssi, arvosana);

    // metodilla push lisätään listaan
    this.kurssisuoritukset.push(suoritus);

    // erilliset metodit opiskelijakohtaisten ja kurssikohtaisten suoritusten
    // lisäämiseen
    this.lisaaOpiskelijanSuoritus(opiskelija.nimi, suoritus);
    this.lisaaKurssinSuoritus(kurssi.nimi, suoritus);
}

Kirjanpito.prototype.lisaaOpiskelijanSuoritus = function(opiskelijanNimi, suoritus) {
    // jos opiskelijan nimellä ei ole yhtäkään suoritusta, on nimellä
    // saatava arvo false -- luodaan tällöin lista suorituksille
    if(!this.opiskelijanSuoritukset[opiskelijanNimi]) {
        this.opiskelijanSuoritukset[opiskelijanNimi] = new Array();
    }

    this.opiskelijanSuoritukset[opiskelijanNimi].push(suoritus);
}

Kirjanpito.prototype.lisaaKurssinSuoritus = function(kurssinNimi, suoritus) {
    if(!this.kurssinSuoritukset[kurssinNimi]) {
        this.kurssinSuoritukset[kurssinNimi] = new Array();
    }

    this.kurssinSuoritukset[kurssinNimi].push(suoritus);
}

Kirjanpito.prototype.haeOpiskelijanKurssisuoritukset = function(opiskelijanNimi) {
    return this.opiskelijanSuoritukset[opiskelijanNimi];
}

Kirjanpito.prototype.haeKurssinSuoritukset = function(kurssinNimi) {
    return this.kurssinSuoritukset[kurssinNimi];
}

Kirjanpito.prototype.haeKaikkiSuoritukset = function() {
    return this.kurssisuoritukset;
}
</pre>


    <p>Kirjanpidon käyttäminen on helpohkoa. Alla olevassa esimerkissä luodaan kurssi, opiskelija ja kirjanpito-olio, sekä lisätään suoritus kirjanpitoon. Tämän jälkeen kaikki suoritukset lisätään dokumentissa olevaan "data"-tunnuksella merkittyyn elementtiin. Käytössämme on myös apufunktio <code>lisaaSuoritusteksti</code>, joka lisää annettuun elementtiin tekstielementin, jossa on suorituksen tiedot.</p>

<pre class="sh_javascript_dom">
function lisaaSuoritusteksti(elementti, suoritus) {
   var teksti = suoritus.kurssi.nimi + " " + suoritus.opiskelija.nimi + " " + suoritus.arvosana;
   elementti.appendChild(document.createTextNode(teksti));
}

var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");
var kirjanpito = new Kirjanpito();

kirjanpito.lisaaSuoritus(weso, mikke, 1);

var suoritukset = kirjanpito.haeKaikkiSuoritukset();
var data = document.getElementById("data");

for(var i = 0; i < suoritukset.length; i++) {
    var elementti = document.createElement("p");

    lisaaSuoritusteksti(elementti, suoritukset[i]);
    data.appendChild(elementti);
}
</pre>

    <p>Ylläolevaa sovellusta voisi käyttää hyvin myös käyttöliittymästä. Käytännössä tällöin HTML-dokumenttiin luotaisi lomake, jonka kautta kurssisuorituksia lisättäisiin. Näiden lisäksi todennäköisesti käytössä olisi omat lomakkeet kurssien ja opiskelijoiden lisäämiselle, jolloin kurssin ja opiskelijan voisi hakea kätevästi listasta.</p>

    <div class="tehtavat">

      <h3>Tavara, Matkalaukku, Ruuma</h3>

      <p>Jokaisella tavaralla on nimi ja paino. Matkalaukkuun lisätään tavaroita, ja matkalaukulla on maksimipaino. Ruumaan taas lisätään matkalaukkuja, ja myös ruumalla on maksimipaino. Matkalaukkuun voi lisätä vain tavaroita, ja ruumaan vain matkalaukkuja. Jos matkalaukun ja uuden tavaran yhteispaino on suurempi kuin matkalaukun maksimipaino, ei tavaraa voida lisätä. Vastaavasti ruumalle.</p>

      <p>Toteuta olioita luovat funktiot <code>Tavara</code>, <code>Matkalaukku</code>, ja <code>Ruuma</code> lähdekooditiedostoon <code>code.js</code>. Voit käyttää alla olevaa (ja tehtäväpohjassa tulevaa) testikoodia toteutustesi testaamiseen.</p>

<pre class="sh_javascript_dom">
var kivi = new Tavara("kivi", 3);
var kirja = new Tavara("kirja", 7);
var pumpuli = new Tavara("pumpuli", 0.001);

var laukku = new Matkalaukku(10);
var vuitton = new Matkalaukku(3);

var schenker = new Ruuma(15);


laukku.lisaa(kivi);
alert("laukun paino, pitäisi olla 3: " + laukku.paino());
laukku.lisaa(kivi); // virhe: "Tavara lisätty jo, ei onnistu!"

laukku.lisaa(kirja);
alert("laukun paino, pitäisi olla 10: " + laukku.paino());

laukku.lisaa(pumpuli); // virhe: "Liian painava, ei pysty!"

alert("laukun paino, pitäisi olla 10: " + laukku.paino());


schenker.lisaa(laukku);
schenker.lisaa(pumpuli); // virhe: Vääränlainen esine, ei onnistu!

alert("Ruuman paino, pitäisi olla 10: " + schenker.paino());

vuitton.lisaa(pumpuli);
schenker.lisaa(vuitton);
alert("Ruuman paino, pitäisi olla noin 10.001: " + schenker.paino());

pumpuli.paino = 300;
alert("Ruuman paino, pitäisi olla 310: " + schenker.paino()); // hups!</pre>



      <p>Palauta tehtävä TMC:lle kun se toimii toivotusti.</p>

    </div>



    <h3>Moduulit</h3>


    <p>Kun tutkimme edellistä esimerkkiä tarkemmin, huomaamme että prototyyppien avulla määritelty oliotoiminnallisuus ei kapseloi olioiden muuttujia, vaan niihin pääsee käsiksi suoraan. Attribuuttien kapseloinnista on kuitenkin monia hyötyjä, joista tärkein lienee se, että olion sisäistä rakennetta voidaan muuttaa ilman että sitä käyttäviä sovelluksia tarvitsee muuttaa.</p>

    <p>Ylläolevaa kirjanpitoa käyttävä ohjelmoija voisi epähuomiossa lisätä uusia kurssisuorituksia esimerkiksi suoraan kirjanpidon sisäiseen muuttujaan <code>kurssisuoritukset</code>, jolloin opiskelijakohtaisia suoritustietoja ei löytyisi nykyisellä toteutuksella.</p>

<pre class="sh_javascript_dom">
var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");
var kirjanpito = new Kirjanpito();

kirjanpito.kurssisuoritukset.push(new Kurssisuoritus(weso, mikke, 1));
</pre>

    <p>Kun ohjelmoijat käyttävät Kirjanpito-funktion määrittelemää ohjelmointirajapintaa, eli sen funktioita, on ohjelman laajentaminen helpompaa. Tällöin ei tarvitse huolehtia siitä, että esimerkiksi suorituspäivämäärän perusteella tapahtuva haku olisi rikki jo alusta lähtien koska joku käyttää valmista koodia väärin.</p>

    <p>Eräs tapa tiedon kapselointiin on Module Pattern-suunnittelumallia. Ennen siihen tutustumista, tutustutaan kuitenkin anonyymeihin funktioihin ja sulkeumiin (<em>Closure</em>).</p>


    <h4>Anonyymit funktiot</h4>


    <p>Anonyymit funktiot ovat funktioita, joita ei kiinnitetä muuttujiin, jolloin ne eivät saa nimeä. Esimerkiksi seuraavassa ohjelmassa käytetään anonyymiä funktiota lukuvälin lukujen summan laskemiseen. Mielenkiintoista alla olevassa koodissa on se, että funktio on olemassa vain sen suorituksen ajan.</p>


<pre class="sh_javascript_dom">
var lopputulos = (function(alku, loppu) {
                      var summa = 0;
                      for (var i = alku; i < loppu; i++) {
                          summa += i;
                      }
                      return summa;
                  })(1, 3);

alert(lopputulos); // 3
</pre>


    <h4>Sulkeumat</h4>


    <p>Sulkeumat ovat yleisesti ottaen lauseita, jotka voivat sisältää muuttujia, mutta jotka piilottavat muuttujat sisäänsä. Käytännössä sulkeumia luodaan luomalla funktioita funktion sisään, jolloin ulompi funktio kapseloi sisältönsä. Tutustutaan sulkeumiin hieman tarkemmin.</p>

    <p>Olemme aiemmin huomanneet, että funktioiden sisällä määritellyt <code>var</code> -muuttujat eivät näy koko ohjelmalle, vaan ne ovat näkyvillä vain sen funktion sisällä, jossa ne on määritelty. Esimerkiksi seuraavassa funktiossa <code>rajoitettuSumma</code> funktio sisältää muuttujan <code>summa</code>, jota ei näy funktion ulkopuolelle. Kun funktio palauttaa arvon, se palauttaa kopion <code>summa</code>-muuttujan sisällöstä.</p>

<pre class="sh_javascript_dom">
function rajoitettuSumma(alku, loppu) {
    var summa = 0;
    for (var i = alku; i < loppu; i++) {
        summa += i;
    }

    return summa;
}
</pre>

<pre class="sh_javascript_dom">
var tulos = rajoitettuSumma(1, 2);
alert(tulos); // 1
</pre>

    <p>Koska JavaScriptissä muuttujat voivat olla funktioita, voimme palauttaa funktiosta toisen funktion.</p>

<pre class="sh_javascript_dom">
function pankki() {
    return function(alku, loppu) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    }
}
</pre>

    <p>Kun käyttäjä kutsuu ylläolevaa funktiota, palauttaa funktio toisen funktion. Palautettu funktio toteuttaa aiemmin näkemämme funktion <code>rajoitettuSumma</code> toiminnallisuuden.</p>

<pre class="sh_javascript_dom">
var funktio = pankki();
alert(funktio(1, 2)); // 1
</pre>

    <p>Oikeastaan, funktion <code>pankki</code> sisälle voi luoda muuttujan <code>rajoitettuSumma</code>, jonka voimme palauttaa.</p>

<pre class="sh_javascript_dom">
function pankki() {

    var rajoitettuSumma = function(alku, loppu) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    };

    return rajoitettuSumma;
}
</pre>

    <p>Yllä oleva toiminnallisuus vastaa aiempaa funktiota. Muutetaan funktion <code>rajoitettuSumma</code> toimintaa siten, että muuttuja <code>loppu</code> määritellään funktion <code>pankki</code> sisällä paikalliseksi muuttujaksi.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        return summa;
    };

    return rajoitettuSumma;
}
</pre>

    <p>Koska JavaScriptissä on funktionäkyvyys, näkyy muuttuja <code>loppu</code> funktion <code>pankki</code> sisällä olevalle funktiolle. Funktiossa <code>rajoitettuSumma</code> voidaan muuttaa muuttujan <code>loppu</code> arvoa -- itseasiassa muuttuja loppu on olemassa useamman <code>rajoitettuSumma</code>-funktiokutsun ajan.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    return rajoitettuSumma;
}
</pre>

<pre class="sh_javascript_dom">
var funktio = pankki();
alert(funktio(1)); // tulostaa 1
alert(funktio(1)); // tulostaa 3
alert(funktio(1)); // tulostaa 6
alert(funktio(1)); // tulostaa 10
</pre>

    <p>Voimme palauttaa pankista olion. Alla olevassa esimerkissä palautamme olion, jonka attribuutti <code>alhaaltaRajoitettuSumma</code> käyttää funktiota <code>rajoitettuSumma</code>.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma
    };
}
</pre>

    <p>Nyt funktio <code>pankki</code> palauttaa olion, jolla on attribuutti <code>alhaaltaRajoitettuSumma</code>. Attribuuttiin pääsee käsiksi aivan kuten olioiden attribuutteihin normaalistikin.</p>


<pre class="sh_javascript_dom">
var funktio = pankki();
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 1
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 3
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 6
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 10

// MUTTA!
alert(funktio.rajoitettuSumma(1)); // ei onnistu!
</pre>

    <p>Funktioon <code>rajoitettuSumma</code> ei kuitenkaan pääse suoraan käsiksi!</p>

    <p>Luodaan pankille vielä toinen funktio, joka asettaa muuttujan <code>loppu</code> arvon.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    var rajoitettuSumma = function(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    var asetaLoppu = function(uusiLoppu) {
        loppu = uusiLoppu;
    }

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma,
        asetaLoppu: asetaLoppu
    };
}
</pre>

<pre class="sh_javascript_dom">
var funktio = pankki();
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 1

funktio.asetaLoppu(4);
alert(funktio.alhaaltaRajoitettuSumma(1)); // tulostaa 10
</pre>

    <p>Yllä olevat funktiot voidaan kirjoittaa myös siten, että niille määritellään nimi osana funktiomäärittelyä. Tällöin erilliselle muuttujalle ei ole tarvetta.</p>

<pre class="sh_javascript_dom">
function pankki() {
    var loppu = 2;

    function rajoitettuSumma(alku) {
        var summa = 0;
        for (var i = alku; i < loppu; i++) {
            summa += i;
        }

        loppu++;
        return summa;
    };

    function asetaLoppu(uusiLoppu) {
        loppu = uusiLoppu;
    }

    return {
        alhaaltaRajoitettuSumma: rajoitettuSumma,
        asetaLoppu: asetaLoppu
    };
}
</pre>



    <h4>Moduulit</h4>

    <p>Module Pattern hyödyntää sekä anonyymejä funktioita että sulkeumia sovelluksen toimintalogiikan kapselointiin. Ajatuksena on luoda ensin nimiavaruudessa käytettävä muuttuja, jonka kautta sovelluksen eri osia käytetään. Luodaan olio <code>hallinta</code>, johon lisätään kirjanpitotoiminnallisuus.</p>

<pre class="sh_javascript_dom">
// huom! luodaan tyhjä olio, jolle voi lisätä attribuutteja
var hallinta = {};

hallinta.kirjanpito = (function() {
    var kurssisuoritukset = new Array();
    var opiskelijanSuoritukset = {};
    var kurssinSuoritukset = {};

    function lisaaSuoritus(kurssi, opiskelija, arvosana) {
        var suoritus = new Kurssisuoritus(opiskelija, kurssi, arvosana);

        // metodilla push lisätään listaan
        kurssisuoritukset.push(suoritus);

        // erilliset metodit opiskelijakohtaisten ja kurssikohtaisten suoritusten
        // lisäämiseen
        lisaaOpiskelijanSuoritus(opiskelija.nimi, suoritus);
        lisaaKurssinSuoritus(kurssi.nimi, suoritus);
    }

    function haeOpiskelijanKurssisuoritukset(opiskelijanNimi) {
        return opiskelijanSuoritukset[opiskelijanNimi];
    }

    function haeKurssinSuoritukset(kurssinNimi) {
        return kurssinSuoritukset[kurssinNimi];
    }

    function haeKaikkiSuoritukset() {
        return kurssisuoritukset;
    }

    // apufunktiot
    function lisaaOpiskelijanSuoritus(opiskelijanNimi, suoritus) {
        // jos opiskelijan nimellä ei ole yhtäkään suoritusta, on nimellä
        // saatava arvo false -- luodaan tällöin lista suorituksille
        if(!opiskelijanSuoritukset[opiskelijanNimi]) {
            opiskelijanSuoritukset[opiskelijanNimi] = new Array();
        }

        opiskelijanSuoritukset[opiskelijanNimi].push(suoritus);
    }

    function lisaaKurssinSuoritus(kurssinNimi, suoritus) {
        if(!kurssinSuoritukset[kurssinNimi]) {
            kurssinSuoritukset[kurssinNimi] = new Array();
        }

        kurssinSuoritukset[kurssinNimi].push(suoritus);
    }

    // julkaistava rajapinta
    return {
        lisaaSuoritus: lisaaSuoritus,
        haeOpiskelijanSuoritukset: haeOpiskelijanKurssisuoritukset,
        haeKurssinSuoritukset: haeKurssinSuoritukset,
        haeKaikkiSuoritukset: haeKaikkiSuoritukset
    };
})();
</pre>

    <p>Yllä oleva moduuli kapseloi kurssihallinnan siten, että hallinnan kapseloimiin tietueisiin ei pääse käsiksi. Voimme jatkossa käyttää kirjanpito-ohjelmaa seuraavasti:</p>

<pre class="sh_javascript_dom">
var weso = new Kurssi("Web-selainohjelmointi");
var mikke = new Opiskelija("Michael");

// EI ONNISTU!
// hallinta.kirjanpito.kurssisuoritukset.push(new Kurssisuoritus(weso, mikke, 1));

// ONNISTUU!
hallinta.kirjanpito.lisaaSuoritus(weso, mikke, 1);
</pre>

<div class="pohdi">
  <p><strong>Module Pattern ja Oliot</strong></p>

  <p>Miten module pattern liittyy olioihin? Voiko module patternia käytettäessä samasta moduulista luoda useampia olioita?</p>

  <p>&nbsp;</p>
  <p>&nbsp;</p>
</div>

    <div class="tehtavat">
      <h3>Kapseloitu laskuri</h3>

      <p>Toteuta tehtäväpohjaan laskin aiemmin esitellyllä Module Patternilla. Laskimen tulee kapseloida muuttuja <code>luku</code> ja tarjoata funktiot <code>kasvata</code>, joka kasvattaa luvun arvoa yhdellä, ja <code>annaLuku</code>, joka palauttaa luvun. Luo laskin tehtäväpohjassa esiteltyyn muuttujaan <code>var laskin;</code>.</p>

      <p>Huom! Laskimen sisäiseen rakenteeseen ei tule voida vaikuttaa muuten kuin funktioiden <code>kasvata</code> ja <code>annaLuku</code> kautta.</p>

      <p>Palauta sovelluksesi TMC:lle kun se toimii toivotusti.</p>


      <h3>PersonManager</h3>

      <p>Tehtäväpohjaan on hahmoteltu henkilöiden hallintaan sopivan sovelluksen rakennetta. Tehtäväsi on jatkaa sitä eteenpäin siten, että henkilöiden lisääminen sovellukseen onnistuu.</p>

      <img src="img/w2e06-personmanager.png" border=1/>

      <p>Tehtävänäsi on toteuttaa:</p>

      <ol>
    <li>Lomakkeen napin käsittelytoiminnallisuus (manager.gui.buttonPressed())</li>
    <li>Henkilön lisääminen (manager.data.addPerson(person))</li>
    <li>Henkilöiden listaaminen (manager.data.list())</li>
      </ol>

      <p>Sekä lisätä manager.data-moduuliin funktioiden sopiva näkyvyys. Tehtäväpohjassa on lisää ohjeita.</p>

      <p>Huom! Älä poikkea jo hahmotellusta module pattern-suunnittelumallia seuraavasta rakenteesta. Ainoa <code>manager</code>-nimialueen ulkopuolella oleva funktiokutsu on sovellukseen jo määritelty <code>init</code>.</p>

      <p>Kun sovelluksesi toimii palauta se TMC:lle.</p>

      <p><strong>Huom!</strong> Maanantaina julkaistussa tehtäväpohjassa oli virhe, joka korjattiin tiistaina klo 15:25. Jos hait tehtävän ennen päivitystä ja haluat käynnistää sen palvelimella, joudut muuttamaan WEB-INF -kansiossa olevan web.xml-tiedoston versioksi version 2.4. Tiedoston pitäisi siis olla muotoa:</p>

<pre class="sh_xml">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee"
    ...
</pre>

    </div>



    <h2>Keskustelu palvelimen kanssa</h2>


    <p>Selaimessa toimivia ohjelmistoja rakennettaessa yhdeksi kysymykseksi tulee sovelluksen käyttämän datan säilöminen. Jotta sovelluksen sisältämä tieto olisi kaikkien käyttäjien saatavilla, tulee se tallentaa erilliselle palvelimelle, jonne kaikilla on pääsy. Palvelinohjelmistojen suunnittelu ja toteuttaminen on hyvin laaja alue, jota esimerkiksi viime periodissa järjestetty kurssi Web-palvelinohjelmointi raapaisee. Kurssin materiaali löytyy osoitteesta <a href="http://www.cs.helsinki.fi/group/java/s12-wepa/" target="_blank">http://www.cs.helsinki.fi/group/java/s12-wepa/</a>.</p>

    <p>Käytännössä keskustelu palvelimen kanssa tapahtuu HTTP-protokollaa käyttäen. HTTP-protokolla on tekstimuotoinen protokolla, joka sisältää pyyntötyyppejä erilaisten pyyntöjen tekemiseen. Pyyntötyypillä GET haetaan dataa, POST lähetetään dataa palvelimelle, ja DELETE poistetaan dataa. Selaimet tarjoavat abstraktiokerroksen HTTP-protokollan päälle -- itseasiassa kun selaimessa haetaan web-sivua jostain osoitteesta, esimerkiksi osoitteesta <code>http://www.cs.helsinki.fi/group/java/s12-wepa/</code>, selain tekee HTTP-pyynnön osoitteessa <code>www.cs.helsinki.fi</code> -olevalle palvelimelle, ja pyytää sieltä polussa <code>/group/java/s12-wepa/</code> olevaa resurssia.</p>

    <p>Selainohjelmistoja rakennettaessa palvelimelta voidaan pyytää kokonaista HTML-dokumenttia, tai pienempää datamäärää. Nykyään uusissa sovelluksissa suosituin datan siirtoformaatti on JSON.</p>

    <h3>JSON</h3>

    <p><a href="http://www.json.org/" target="_blank">JSON</a> (<em>JavaScript Object Notation</em>) on JavaScriptin käyttämä tiedonsiirtoformaatti, jonka suosio perustuu helppoon JavaScript-olioiksi muuttamiseen. Olemme aiemmin luoneet JavaScript-olioita seuraavanlaisella notaatiolla.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Mikke", syntymavuosi: 1984};
</pre>

    <p>JSON-formaatti on hyvin samannäköinen. JSON-muodossa data kuvataan merkkijonoina. Luodaan ylläolevaa oliota kuvaava JSON-merkkijono <code>mikkeData</code>. Huomaa kahden erilaisen hipsun käyttö!</p>

<pre class="sh_javascript_dom">
var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
</pre>


    <p>Nyt käytössämme on merkkijono, jonka sisältö näyttää lähes samalta kuin aiemmin olion luontiin käyttämämme notaatio. Miten tästä saa olion?</p>

    <p>JavaScript tarjoaa toiminnallisuuden merkkijonon JavaScript-olioksi ja takaisin muuttamiseen. Funktio <code>JSON.parse</code> muuttaa parametrina annetun merkkijonon JavaScript-olioksi, ja funktio <code>JSON.stringify</code> muuttaa parametrina annetun JavaScript olion merkkijonoksi.</p>

<pre class="sh_javascript_dom">
var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
var mikke = JSON.parse(mikkeData);
alert(mikke.nimi);

var mikkeKlooni = JSON.stringify(mikke);
alert(mikkeKlooni);
</pre>

    <div class="test-js">
      <p><textarea id="js-json-muunnos" rows="7" cols="80">var mikkeData = '{"nimi": "Mikke", "syntymavuosi": 1984}';
var mikke = JSON.parse(mikkeData);
alert(mikke.nimi);

var mikkeKlooni = JSON.stringify(mikke);
alert(mikkeKlooni);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-json-muunnos')" value="Suorita koodi!"></input></p>
    </div>

    <p>Helppoa kuin heinänteko.</p>



    <h3>Datan hakeminen palvelimelta</h3>


    <p>Datan noutamiseen palvelimelta käytetään muutamaa erillistä lähestymistapaa. Suurin osa selaimista tukee <a href="http://www.w3.org/TR/XMLHttpRequest/" target="_blank">XMLHttpRequest</a>-oliota, jonka avulla voidaan luoda pyyntöjä palvelimelle. Käytännössä pyynnön lähettäminen ja käsittely tapahtuu kolmessa vaiheessa. Ensin luodaan XMLHttpRequest-olio, sitten määritellään oliolle vastauksen käsittelevä funktio, ja lopuksi lähetetään pyyntö.</p>

<pre class="sh_javascript_dom">
// pyyntöolion luonti
var req = new XMLHttpRequest();

// mitä tehdään kun saadaan vastaus (vastauksia voi olla useita)
req.onreadystatechange = function() {
    // jos tila ei ole 4 (valmis), ei käsitellä
    if (req.readyState !== 4) {
        alert("state " + req.readyState);
        return false;
    }

    // jos statuskoodi ei ole 200 (ok), ei käsitellä
    if (req.status !== 200) {
        alert("status " + req.status);
        return false;
    }

    // näytetään vastaus
    alert(req.responseText);
}

req.open("GET", "data.json", true);
req.send("");
</pre>

    <p>Tutkitaan yllä olevaa koodia hieman tarkemmin. Palvelin voi palauttaa XMLHttpRequest-pyyntöön useamman vastauksen. Attribuutti <code>readyState</code> sisältää arvon väliltä [0, 4], missä 4 tarkoittaa pyynnön olevan valmis. Jos attribuutin <code>readyState</code> arvo ei ole neljä, odotamme lopullista vastausta. Attribuutti <code>status</code> kertoo HTTP-pyynnön statuskoodin. Statuskoodi 200 kertoo pyynnön onnistuneen. Lisää tietoa statuskoodeista löytyy esimerkiksi googlella ja <a href="http://httpstatuscats.com/" target="_blank">täältä</a>.</p>

    <p>Ylläolevassa esimerkiksi vastaus näytetään <code>alert</code>-komennon avulla. Käytännössä JSON-dataa sisältävän vastauksen voisi muuttaa <code>JSON.parse</code>-funktiolla olioksi.</p>

    <p>Tärkeä osa liittyy pyynnön avaamiseen. Komento <code>req.open("GET", "data.json", true);</code> avaa GET-tyyppisen HTTP-yhteyden <em>nykyiseen sivustoon</em> liittyvään osoitteeseen <code>data.json</code>. Koska viimeinen parametri on <code>true</code>, on pyyntötyyppi asynkroninen, eikä selain jää odottamaan vastausta. Vastaukseen reagoidaan kun vastaus saapuu.</p>


    <div class="test-js">
      <p><textarea id="js-xmlhttpreq-haku" rows="9" cols="80">var req = new XMLHttpRequest();

req.onreadystatechange = function() {
    alert(req.readyState + ", " + req.status + ", " + req.responseText);
}

req.open("GET", "data.json", true);
req.send("");
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-xmlhttpreq-haku')" value="Suorita koodi!"></input></p>
    </div>

    <p>Kun kokeilet ylläolevaa koodia eri osoitteilla, huomaat että datan hakeminen ei aina onnistu. XMLHttpRequest-pyyntöihin liittyy tietoturvarajoitteita, jotka oletuksena rajoittavat pyynnön tekemisen samaan osoitteeseen.</p>


    <h4>Pyyntöjen tekeminen oman palvelimen ulkopuolelle</h4>

    <p>Pyyntöjen tekemistä eri osoitteisiin rajoittaa ns. "Same origin policy", jolla pyritään rajoittamaan muunmuassa pyynnön mukana lähetettävän datan (evästeet, kirjautumistiedot ym.) päätymistä vääriin käsiin. Sivustot, jotka koostavat useampia palveluita yhteen kuitenkin tarvitsevat pääsyn ulkopuoliseen dataan.</p>

    <p>W3C työskentelee <a href="http://www.w3.org/TR/cors/" target="_blank">CORS</a> (<em>Cross-origin resource sharing</em>)-spesifikaation kanssa parhaillaan. CORS-spesifikaation tavoitteena on määritellä tuki domain-riippumattomalle resurssien jakamiselle. Käytännössä tuki vaatii sen, että palvelinohjelmiston vastauksessa on otsakkeet, jotka kertovat osoitteet, joissa haettua dataa voi käyttää.</p>

    <p>Rajoituksen kiertämiseen on kehitetty useita tekniikoita, mm. proxy-mekanismi, iframe-elementtien kanssa toimiminen, ja JSONP. Proxy-mekanismissa paikalliselle palvelimelle luodaan skripti, joka hakee kolmannen osapuolen datan paikalliselle palvelimelle, jolloin selaimen näkökulmasta data on paikallista. IFrame-elementtiä käytettäessä taas sivu haetaan erilliseen iframe-elementtiin, josta haetaan tarvitut osat.</p>

<div class="extra">
  <p><strong>Pyyntöjen tekeminen omalle koneelle</strong></p>

  <p>Osa selaimista kieltää pyyntöjen tekemisen suoraan tiedostojärjestelmään. Voit kiertää tämän esimerkiksi chromessa käynnistämällä chromen parametrilla "--disable-web-security".</p>
</div>

    <h4>JSONP</h4>

    <p>JSONP (<em>JSON with padding</em>) hyödyntää tietoa siitä, että <code>script</code>-elementin osoite, eli paikka josta JavaScript-lähdekoodi haetaan, ei ole rajoitettu. Data haetaan asettamalla JavaScriptillä luotavalle <code>script</code>-elementille <code>src</code>-attribuutti, johon asetetaan JSONP-muotoista dataa tarjoavan palvelimen osoite.</p>

    <p>Dataa haettaessa pyynnölle annetaan parametrina funktion nimi, jonka nimisellä funktiolla data tulee kapseloida palvelinpäässä. Esimerkiksi, jos pyyntö tehdään osoitteeseen <code><em>palvelin</em>/data.jsonp?callback=handleResponse</code>, on vastauksessa tulevan datan oltava muotoa <code>handleResponse(<em>data</em>)</code>. Funktio <code>handleResponse</code> on määritelty osana dataa hakevaa sivua.</p>

<pre class="sh_javascript_dom">
// aiemmin määritelty funktio handleResponse
function handleResponse(content) {
    alert(content);
}
</pre>



<pre class="sh_javascript_dom">
// dataa haettaessa tehtävä kutsu. Haetaan tietyssä osoitteessa olevasta palvelusta
// jsonp-muotoista dataa.
var script = document.createElement("script");
script.setAttribute("src", "<em>osoite</em>/data.jsonp?callback=handleResponse");
document.body.appendChild(script);
</pre>

    <p>Sivu voi palauttaa esimerkiksi seuraavanlaisen vastauksen vastauksen.</p>

<pre>
handleResponse({"nimi":"mikke", "ika":17})
</pre>

<script>
function handleResponse(data) {
    alert(data);
}
</script>

    <div class="test-js">
      <p><textarea id="js-jsonp-haku" rows="4" cols="80">var script = document.createElement("script");
script.setAttribute("src", "data.jsonp?callback=handleResponse");
document.body.appendChild(script);
</textarea></p>
      <p><input type="button" onclick="evalElementContent('js-jsonp-haku')" value="Suorita koodi!"></input></p>
    </div>


    <div class="tehtavat">
      <h3>TweetTweet</h3>

      <p><a href="http://www.twitter.com" target="_blank">Twitter</a> tarjoaa JSONP-apin, jonka avulla pääsemme käsiksi twitter-viesteihin. Tässä tehtävässä toteutat osan twitter-viestien lataamiseen ja näyttämiseen tarkoitetusta palvelusta. Tehtävänäsi on toteuttaa viestien palvelimelta lukemiseen liittyvä toiminnallisuus.</p>

      <p>Toteuta tehtäväpohjassa olevaan moduuliin <code>tweet.data</code> funktiot <code>load</code>, <code>parse</code>, ja <code>list</code>. Funktiolle <code>load</code> annetaan parametrina osoite, josta viestit ladataan. Funktiota <code>parse</code> kutsutaan kun viestien lataaminen on valmis, ja funktio <code>list</code> palauttaa ladatut viestit. Kutsu funktion <code>parse</code> lopussa funktiota <code>displayHook</code>, jolloin haettu data näytetään käyttäjälle.</p>

      <p>Käytä osoitetta <code>http://api.twitter.com/1/statuses/user_timeline/rageresearch.json?count=4</code> testaamiseen. Saat callback-funktioksi funktion <code>tweet.data.parse</code> esimerkiksi seuraavalla osoitteella:</p>

<pre>
http://api.twitter.com/1/statuses/user_timeline/rageresearch.json?count=4&callback=tweet.data.parse
</pre>

      <p>Yllä olevalla osoitteella sivun tulee näyttää seuraavalta.</p>

<img src="img/w2e07-tweettweet.png" border=1 />

      <p>Kun sovelluksesi toimii, ja näet twitter-viestit <code>index.html</code>-sivulla, palauta se TMC:lle.</p>

    </div>


    <h3>Datan lähettäminen palvelimelle</h3>

    <p>Datan lähettämiseen liittyy samat haasteet kuin datan vastaanottamiseen. Yksinkertaisin tapa lähettää tietoa palvelimelle on XMLHttpRequest-olion GET-pyyntö siten, että lähetettävä data asetetaan mukaan pyynnön osoitteeseen. Käytännössä parametrina oleva data käsitellään palvelinpuolella pyyntöä kuuntelevassa ohjelmistossa.</p>

<pre class="sh_javascript_dom">
// pyyntöolion luonti
var req = new XMLHttpRequest();
var parametrit = "nimi=mikke&ika=17";
req.open("GET", "dataprocessor.html?" + parametrit, true);
req.send("");
</pre>

    <p>GET-pyyntö on hieman huono siinä mielessä, että lähetettävä data näkyy kaikkialle. Esimerkiksi jos pyyntö kulkee useamman reitittimen läpi ennen pääsyä palvelimelle, jokainen reititin näkee parametrit. Toinen vaihtoehto on POST-pyyntö, jossa data lähetetään osana pyynnön runkoa. Tällöin pyynnölle tulee myös määritellä lähetettävän datan muoto. Allaolevassa esimerkissä sanomme datan olevan lomakkeelta.</p>

<pre class="sh_javascript_dom">
var req = new XMLHttpRequest();
var data = "nimi=mikke&ika=17";
req.open("POST", "dataprocessor.html", true);

req.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
req.setRequestHeader("Content-Length", data.length);
req.setRequestHeader("Connection", "close");

req.send(data);
</pre>

    <p>JSON-muotoisen datan lähettäminen osana POST-pyyntöä onnistuu vastaavasti.</p>

<pre class="sh_javascript_dom">
var mikke = {nimi: "Michael", ika: 17};
var data = JSON.stringify(mikke);

var req = new XMLHttpRequest();
req.open("POST", "jsonprocessor.html", true);

req.setRequestHeader("Content-Type","application/json");
req.setRequestHeader("Content-Length", data.length);
req.setRequestHeader("Connection", "close");

req.send(data);
</pre>

    <div class="tehtavat">
      <h3>Submission</h3>

      <p>Toteuta tehtäväpohjassa olevaan lähdekooditiedostoon <code>submission.io</code>-moduuli, jolla on kaikille näkyvä funktio <code>send</code>. Funktio <code>send</code> saa parametrina JavaScript-olion, joka tulee lähettää palvelimelle JSON-muodossa.</p>

      <p>Lähetä data osoitteeseen <code>http://bad.herokuapp.com/app/in</code>. Voit tarkistaa menikö data perille osoitteessa <code>http://bad.herokuapp.com/app/out</code>. Ennenkuin aloitat, kannattaa vierailla sivulla <a href="http://bad.herokuapp.com/" target="_blank">http://bad.herokuapp.com/</a> niin varmistat että sovellus on päällä.</p>

      <p>Kun sovelluksesi lähettää dataa palvelimelle, ja näet lähetetyn datan palvelimella, palauta tehtävä TMC:lle. Jos data menee palvelimelle, ja näet virheen "XMLHttpRequest cannot load http://bad.herokuapp.com/app/in. Origin null is not allowed by Access-Control-Allow-Origin." -- älä välitä siitä. Sovellus herokussa ei ole konfiguroitu täysin oikein.</p>


      <h3>Chat-chat (4p)</h3>

      <p>Tämä on avoin tehtävä, jonka tekemisestä saa 4 pistettä. Tehtävästä saa pisteet vain jos sovellus toimii kokonaisuudessaan.</p>

      <p>Osoitteessa <a href="http://bad.herokuapp.com/app/" target="_blank">http://bad.herokuapp.com/app/</a> toimii chat-sovelluksen backend-toiminnallisuus. Tässä tehtävässä rakennetaan chatille selainpuolen toiminnallisuus.</p>

      <p><strong>Huom!</strong> Käytä tehtävässä vain yhtä HTML-dokumenttia. Tehtäväpohjassa on mukana tiedosto <code>index.html</code>, jonka sisään toiminnallisuutta voi toteuttaa. Toteuta chatin logiikka luonnollisesti erillisinä JavaScript-tiedostoina.</p>

      <h4>Sisäänkirjautuminen</h4>

      <p>Kun käyttäjä avaa chat-sivun, näytetään hänelle login-näkymä, joka näyttää seuraavalta.</p>

      <p><img src="img/w2e09-chat-login.png" border="1" /></p>

      <p>Kun käyttäjä kirjoittaa käyttäjätunnuksen ja painaa Login-nappia, selainsovellus lähettää palvelimelle JSON-merkkijonon, joka on muotoa <code>{ "nickname": nick }</code>, missä <code>nick</code> on käyttäjän kirjoittama käyttäjätunnus. Kirjautumispyyntö tehdään HTTP POST-pyyntönä osoitteeseen <code>http://bad.herokuapp.com/app/auth</code>. Jos kirjautuminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu. Ilman kirjautumista palvelimelle ei voi lähettää viestejä.</p>

      <h4>Viestien listaaminen</h4>

      <p>Kirjautumisen onnistuessa käyttäjälle näytetään chat-näkymä, joka näyttää tyhjänä seuraavalta:</p>

      <p><img src="img/w2e09-chat-1.png" border="1" /></p>

      <p>Kirjautumisen yhteydessä palvelimelta tulee myös hakea lista viimeisimmistä viesteistä, jotka näytetään näkymässä. Viestit saa haettua HTTP GET-pyynnöllä osoitteesta <code>http://bad.herokuapp.com/app/messages</code>. Jos viestien hakeminen onnistuu, palvelin palauttaa statuskoodin 200, muuten statuskoodi on jokin muu.</p>

      <p>Palvelin palauttaa viimeisimmät viestit JSON-taulukossa (array). Yksittäinen viesti sisältää seuraavat tiedot:</p>

<pre>
{
    "id": 4,
    "timestamp": 1352114153691,
    "nickname": "El Barto",
    "message": "Hello world!"
}
</pre>

      <p>Viestin aikaleima kuvaa millisekunteja epoch-ajankohdasta (1.1.1970). Esimerkiksi JavaScriptin <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date"><code>Date</code></a>-oliot osaavat tulkita tällaista lukua ja palauttaa normaalin päivämäärän ja kellonajan sen perusteella. Palvelin palauttaa viestit siten, että uusin viesti on ensimmäinen.</p>

      <p>Jos palvelimelle on jo lähetetty aiemmin viestejä, kirjautumisen jälkeen chat-näkymä näyttää esimerkiksi seuraavalta:</p>

      <p><img src="img/w2e09-chat-2.png" border="1" /></p>

      <h4>Viestin lähetys</h4>

      <p>Toteuta viestin lähettäminen chat-näkymään. Send-nappia painettaessa sovelluksen tulee lähettää tekstikentässä oleva viesti palvelimelle. Uusi viesti tulee lähettää HTTP POST-pyynnöllä osoitteeseen <code>http://bad.herokuapp.com/app/messages</code>. Pyynnössä lähetettävä viesti näyttää esimerkiksei seuraavalta:</p>

<pre>
{
    "nickname": "El Barto",
    "message": "Huh-huh!"
}
</pre>

      <p>Hae viestin lähettämisen jälkeen palvelimelta uusimmat viestit ja päivitä chat-näkymä saaduilla viesteillä, jotta juuri lähetetty viesti näkyy sivulla.</p>

      <h4>Viestien päivittäminen ja uloskirjautuminen</h4>

      <p>Toteuta chat-näkymän Refresh-napin toiminnallisuus. Napin painalluksen tulee hakea palvelimelta uusimmat viestit ja näyttää ne chat-näkymässä.</p>

      <p>Toteuta chat-näkymän Logout-napin toiminnallisuus. Napin painalluksen tulee piilottaa chat-näkymä ja palauttaa login-näkymä sivulle, jotta chattiin voi kirjautua uudella nimimerkillä. Nimimerkille varatun tekstikentän tulee olla tyhjä. Samoin uudelleen kirjauduttaessa sisään chat-näkymän viestille varatun tekstikentän tulee olla tyhjä.</p>

      <p>Kun olet valmis, lähetä toteutuksesi TMC:lle. Tehtävän ratkaisuehdotus käyttää hieman erilaista lähestymistapaa, jossa module patternia käytetään olioiden luomiseen. Palaamme siihen seuraavalla viikolla.</p>
    </div>

</section>
    <section class="week">
      <header>
        <a name="viikko1"></a>
        <h1 data-week-id="3">Viikko 3</h1>
      </header>

    <h2>Oliot ja Moduulit</h2>

    <p>Syvennytään lisää olioihin ja moduuleihin.</p>

    <h3>Oliot</h3>

    <p>Oliot ovat funktioiden ilmentymiä, jotka luodaan <code>new</code>-avainsanalla. Oliolla on oma oliokohtainen tila, mihin pääsee käsiksi <code>this</code>-operaattorilla. Esimerkiksi alla on luotu funktio <code>Kirja</code>, josta voi luoda olioita. Kirjalle on määritelty attribuutit nimi ja julkaisuvuosi.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);
</pre>

    <p>Olioille määritellään metodeja prototyyppiperinnän avulla. Prototyypin muokkauksen jälkeen olioilla on käytössä juuri määritellyt funktiot.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

Kirja.prototype.tulostaNimi = function() {
    alert(this.nimi);
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);
kalevala.tulostaNimi(); // Kalevala

elefantinMatka = new Kirja("Elefantin matka", 2008);
elefantinMatka.tulostaNimi(); // Elefantin matka
</pre>


    <p>Metodit määritellään käytännössä aina heti olion luovan funktion määrittelyn jälkeen. Käytännössä <code>new Kirja("Kalevala", 1835)</code>-kutsun suorituksessa uusi kalevala-olio peritään <code>Kirja.prototype</code> -prototyypistä. Tämän jälkeen sen konstruktori suoritetaan, ja sille allokoidaan olion attribuuttien tarvitsema tila. Lopulta konstruktori palauttaa viitteen uuteen olioon.</p>

    <p>JavaScript ei mahdollista <code>this</code>-operaattorilla esiteltyjen attribuuttien kapselointia, vaan ne ovat julkisia.</p>

<pre class="sh_javascript_dom">
function Kirja(nimi, julkaisuvuosi) {
    this.nimi = nimi;
    this.julkaisuvuosi = julkaisuvuosi;
}

Kirja.prototype.tulostaNimi = function() {
    alert(this.nimi);
}

// funktiosta luodaan olio new-operaattorilla
kalevala = new Kirja("Kalevala", 1835);

// olion attribuutteihin pääsee käsiksi suoraan
kalevala.nimi = "Valekala";

kalevala.tulostaNimi(); // Valekala
</pre>


    <p>Konstruktorifunktiot nimetään isolla alkukirjaimella, olioiden nimet pienellä alkukirjaimella.</p>


<div class="tehtavat">
<NEXTWEEK></NEXTWEEK>

    <h3>Puhelinmuistio</h3>

    <p>Toteuta funktio Puhelinmuistio, joka luo puhelinmuistio-olion. Puhelinmuistioon voi lisätä nimiä ja numeroita. Jokaiseen nimeen voi liittyä useampi numero. Numeroiden lisäämisen tulee tapahtua <code>lisaaNumero</code>-funktiolla, ja puhelinmuistion tulee tarjota metodi <code>annaNumerot</code>, jolle annetaan parametrina nimi.</p>

    <p>Jos samalle henkilölle yritetään asettaa sama numero useampaan kertaan, numero tallennetaan henkilölle vain kerran. Useammalla henkilöllä voi olla sama numero.</p>

    <p>Tehtäväpohjan mukana olevalle HTML-sivulle ei tarvitse tehdä mitään. Voit hyödyntää tehtäväpohjassa tulevaa Array-funktion laajennusta <code>contains</code> omassa toteutuksessasi. Kun tehtävä toimii seuraavilla esimerkeillä, palauta se TMC:lle.</p>

<pre class="sh_javascript_dom">
muistio = new Puhelinmuistio();
muistio.lisaaNumero("mikke", "044-33669933");
muistio.lisaaNumero("mikke", "044-33669933");
alert(muistio.annaNumerot("mikke")); // numero 044-33669933 vain kerran

muistio.lisaaNumero("mikke", "231");
alert(muistio.annaNumerot("mikke")); // numerot 044-33669933 ja 231

alert(muistio.annaNumerot("matti")); // tyhjä lista
muistio.lisaaNumero("matti", "1111");
alert(muistio.annaNumerot("matti")); // numero 1111

alert(muistio.annaNumerot("mikke")); // numerot 044-33669933 ja 231
</pre>


</div>


    <h3>Moduulit</h3>


    <p>Moduulit toteutetaan anonyymin funktion avulla. Muuttujien funktionäkyvyyden takia muuttujat voidaan kapseloida anonyymin funktion sisään, jolloin niihin ei pääse käsiksi funktion ulkopuolelta. Anonyymin funktion sisälle määritellyt funktiot pääsevät käsiksi muuttujiin, jolloin sisäfunktioissa voidaan muokata muuttujien arvoja.  Moduuli palauttaa moduulissa määritellyn rajapinnan, jossa on viittaukset sisäfunktioihin.</p>

    <p>Hahmotellaan kaupan hallinnointiin tarvittavaa järjestelmää. Luodaan ostoskorimoduuli, joka tarjoaa julkisen rajapinnan tuotteiden lisäämiseen ja tuotteiden lukumäärän laskemiseen.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.ostoskori = (function() {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa
    };
})();
</pre>

    <p>Ostoskoria voi käyttää nyt seuraavasti:</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori.lisaa("keksi");
kauppa.ostoskori.lisaa("keksi");
kauppa.ostoskori.lisaa("omena");
alert(kauppa.ostoskori.tuotteidenLukumaara()); // 3
</pre>

    <p>Anonyymille funktiolle voi antaa parametreja. Luodaan hinnastomoduuli, joka palauttaa tuotteen nimen perusteella sen hinnan. Vaikka hinnastomoduulimme palauttaa kaikkien tuotteiden hinnaksi 3, voisi sen toteutus myös hakea hinnat esimerkiksi erilliseltä palvelimelta.</p>

<pre class="sh_javascript_dom">
kauppa.hinnasto = (function() {
    function annaHinta(tuote) {
        return 3;
    }

    return {
        hinta: annaHinta
    };
})();
</pre>

    <p>Laajennetaan ostoskorimoduulia siten, että se saa hinnaston parametrina. Lisätään ostoskorille myös funktio ostoskorissa olevien tuotteiden hinnan laskemiseen.</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori = (function(hinnasto) {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    function yhteishinta() {
        var summa = 0;
        for(var tuotteenNimi in ostokset) {
            summa += ostokset[tuotteenNimi] * hinnasto.hinta(tuotteenNimi);
        }

        return summa;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa,
        yhteishinta: yhteishinta
    };
})(kauppa.hinnasto);
</pre>


    <p>Huomaa miten riippuvuus hinnastoon nimetään moduulin sisällä uudestaan anonyymin funktion parametrien kautta. Moduulin sisällä hinnastoon viitataan muuttujalla <code>hinnasto</code>.</p>

<div class="tehtavat">
  <h3>Ostoskorin tilaaminen ja varasto</h3>

  <p>Jatkokehitetään yllä olevaa esimerkkiä. Tehtävänäsi on luoda varastokirjanpitoa varten moduuli <code>kauppa.varasto</code>, joka tarjoaa seuraavat funktiot:</p>
  <ol>
    <li><code>lisaa(tuote, lukumaara)</code> lisää annetun lukumärään tuotteita varastoon.</li>
    <li><code>ota(tuote, lukumaara)</code> ottaa varastosta tuotteita halutun lukumäärän.</li>
    <li><code>saldo(tuote)</code> palauttaa tuotteen varastosaldon.</li>
  </ol>

  <p>Varastosaldo voi olla myös negatiivinen.</p>

  <p>Lisää lisäksi ostoskorille funktio <code>tilaa</code>, jonka avulla käyttäjä voi tilata ostoskorista olevat tuotteet. Kun ostoskori tilataan, varastosta otetaan tuotteita ostoskorissa oleva määrä. Tyhjennä tilauksen lopuksi myös ostoskori.</p>

  <p>Kytke varasto ostoskoriin siten, että ostoskori tietää varastosta. Kun sovelluksesi toimii seuraavalla koodilla, palauta se TMC:lle.</p>

<pre class="sh_javascript_dom">
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
alert(kauppa.ostoskori.tuotteidenLukumaara()); // 3
alert(kauppa.varasto.saldo("kivi")); // 0

kauppa.ostoskori.tilaa();
alert(kauppa.ostoskori.tuotteidenLukumaara()); // 0
alert(kauppa.varasto.saldo("kivi")); // -3

alert(kauppa.varasto.saldo("paperi")); // 0

kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("kivi");
kauppa.ostoskori.lisaa("paperi");

kauppa.ostoskori.tilaa();
alert(kauppa.varasto.saldo("kivi")); // -5
alert(kauppa.varasto.saldo("paperi")); // -1

kauppa.varasto.lisaa("kivi", 7);
alert(kauppa.varasto.saldo("kivi")); // 2
</pre>

  <p>Tilaamisen tulee vain vähentää tavarat varastosta ja tyhjentää ostoskori, muuta toiminnallisuutta ei vielä tarvitse.</p>

</div>

    <p><em>Moduulista ei voi tehdä olioita, joten ostoskoreja voi olla vain yksi. Tämä ei kuitenkaan ole toivottavaa.</em></p>


    <h3>Olioiden tila ja new</h3>


    <p>Operaatiota <code>new</code> kutsuttaessa funktiosta luodaan kopio, jolloin käytännössä varataan tilaa oliolle ja sen <code>this</code>-operaattorilla merkatuille muuttujille. Uusi, juuri luotava olio, on käytännössä joukko avain-arvo -pareja, jossa arvo voi olla funktio, muuttuja, tai olio. Koska muuttujat voivat olla funktioita, voi <code>this</code>-operaattorilla viitata funktioon.</p>

    <p>Luodaan funktio <code>Laskuri</code>, jonka sisällä on muuttuja <code>luku</code>. Muuttujaa <code>luku</code> ei määritellä <code>this</code>-operaatiolla, vaan se on funktion sisälle kapseloitu.</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;
}
</pre>

    <p>Ylläolevaa funktiota voi kutsua sekä <code>new</code>-operaation avulla tai ilman. Jos funktiota kutsutaan ilman <code>new</code>- kutsua, kutsu on normaali funktiokutsuna. Toisaalta, jos funkitiota kutsutaan <code>new</code>-operaation kanssa, funktiosta luodaan uusi olio.</p>

<pre class="sh_javascript_dom">
Laskuri(); // suorittaa funktion sisällä olevan koodin

var olio = new Laskuri(); // suorittaa funktion sisällä olevan koodin, luo olion, ja palauttaa sen erilliseen muuttujaan
</pre>

    <p>Yllä olio on <em>kopio</em> Laskuri-funktion sisäisestä tilasta. Tilaan ei kuitenkaan pääse mitenkään käsiksi.</p>

    <p>Lisätään funktioon <code>Laskuri</code> kaksi <code>this</code>-operaatiolla määriteltyä funktiota. Koska operaatiolla <code>this</code> määritellyt muuttujat ovat oliokohtaisia, ovat myös funktiot oliokohtaisia.</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    this.kasvata = function() {
        luku++;
    }

    this.tulosta = function() {
        alert(luku);
    }
}
</pre>

    <p>Tutkitaan nyt mitä tapahtuu kun kutsumme <code>Laskuri</code>-funktiota sekä ilman <code>new</code>-operaatiota, että <code>new</code>-operaation kanssa. Kutsutaan funktiota ensin ilman <code>new</code>-operaatiota.</p>

<pre class="sh_javascript_dom">
Laskuri(); // yrittää suorittaa funktion sisällä olevan koodin, ei toimi
</pre>

    <p>Kun funktiota <code>Laskuri</code> kutsutaan ilman <code>new</code>-operaatiota, näemme virheen "Cannot set property 'kasvata' of undefined". Tämä johtuu siitä, että <code>this</code>-operaatio liittyy aina olioon. Käytännössä yritämme lisätä oliolle uutta muuttujaa <code>kasvata</code>. Tämä epäonnistuu, sillä oliota, mille muuttujaa yritetään asettaa ei ole.</p>

    <p>Kutsutaan seuraavaksi funktiota <code>Laskuri</code> <code>new</code>-operaation kanssa, eli luodaan siitä olio.</p>

<pre class="sh_javascript_dom">
var laskin = new Laskuri();
</pre>

    <p>Yllä olevassa kutsussa luodaan klooni funktion <code>Laskuri</code> sisällöstä, ja palautetaan viite klooniin. Klooni kapseloi muuttujan <code>luku</code>, mutta siihen pääsee käsiksi oliomuuttujien <code>kasvata</code> ja <code>tulosta</code> kautta. Voimme luoda yllä olevasta funktiosta useamman kopion.</p>

<pre class="sh_javascript_dom">
var laskin = new Laskuri();
laskin.kasvata();
laskin.tulosta(); // 1

var toinen = new Laskuri();
toinen.tulosta(); // 0
laskin.tulosta(); // 1

laskin.kasvata();
laskin.tulosta(); // 2
toinen.tulosta(); // 0
</pre>

    <p>Palataan ihan alkuun. Javascriptiin tutustuessa huomasimme, että uusia JavaScript-olioita voi luoda aaltosulkujen avulla. Oikeastaan, operaatio <code>this</code>-lisää oliolle uusia muuttujia aivan kuten aaltosulkunotaatiolla luotavalle oliolle lisätään uusia muuttujia. Yllä olevan laskurin voi toteuttaa myös seuraavasti:</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    return {
        kasvata: function() {
            luku++;
        },
        tulosta: function() {
            alert(luku);
        }
    };
}
</pre>

    <p>Ja seuraavasti:</p>

<pre class="sh_javascript_dom">
function Laskuri() {
    var luku = 0;

    function kasvata() {
        luku++;
    }

    function tulosta() {
        alert(luku);
    }

    return {
        kasvata: kasvata,
        tulosta: tulosta
    };
}
</pre>


    <p>Oleellista on se, että Kutsu <code>new Laskuri()</code> palauttaa uuden olion. Uudella oliolla on funktion Laskuri kapseloima muuttuja <code>luku</code>, sekä luodun olion tarjoamat julkiset funktiot <code>kasvata</code> ja <code>tulosta</code>. Huomaa että kutsu <code>{}</code> luo uuden <em>Object</em>-tyyppisen olion -- yllä olevan olion tyyppi ei siis ole Laskin!</p>

<div class="extra">
  <p><strong>Monta tapaa sanoa sama asia</strong></p>

  <p>JavaScriptiä on monimuotoisuutensa takia helposti hyvin vaikea ymmärtää. Yhden asian voi helposti sanoa viidelläkin eri tavalla, joka voi johtaa väärinkäsityksiin tai väärinymmärryksiin. Oleellista on kuitenkin ymmärtää että oliot ovat avain-arvo -pareja, joilla jokaisella voi olla <em>erilaiset</em> sisällöt. Arvot voivat olla funktioita, jotka muokkaavat toisia arvoja.</p>

  <p>Funktionäkyvyys mahdollistaa tiedon kapseloinnin. Sulkeumien takia sisäfunktioilla on pääsy niiden kapseloivan funktion sisältämiin muuttujiin, myös silloin kun kapseloivan funktion suoritus on ohi.</p>

</div>

<div class="tehtavat">
<!--
    <h3>OstoskoriOlio</h3>

    <p>Muokkaa tehtäväpohjassa tulevaa ostoskoria siten, että ostoskoreja voi luoda useita. Tehtäväpohjan ostoskorin lähdekoodi on osion 9.2. esimerkistä. Anna jokaiselle ostoskorille parametrina hinnasto, jota ostoskori käyttää yhteishinnan laskemiseen.</p>

    <p>Kun ohjelmasi toimii alla olevalla esimerkillä, palauta se TMC:lle. Voit hyvin toteuttaa ostoskorin yllä esitetyillä tekniikoilla. Myöhemmin esitetty esimerkki voi olla tarpeettoman monimutkainen.</p>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori(kauppa.hinnasto);
kori.lisaa("kivi");
kori.lisaa("kivi");
kori.lisaa("kivi");
kori.lisaa("parsa");

alert(kori.tuotteidenLukumaara()); // 4
alert(kori.yhteishinta()); // 12

var vuitton = new kauppa.Ostoskori(kauppa.hinnasto);
vuitton.lisaa("pumpuli");

alert(vuitton.tuotteidenLukumaara()); // 1
alert(vuitton.yhteishinta()); // 3

alert(kori.tuotteidenLukumaara()); // 4
alert(kori.yhteishinta()); // 12
</pre>
-->

  <h3>Tavara ja Matkalaukku</h3>

    <p>Muokataan viime viikolla ollutta tehtävää siten, että käytetään edellä esitettyä olioiden esitystapaa. Muokkaa tehtäväpohjassa olevia konstruktorifunktiota <code>Tavara</code> ja <code>Matkalaukku</code> siten, että konstruktorifunktiot sisältävät luotaviin olioihin liitettävät metodit. Muokkaa ohjelmaa siten, että se toimii alla olevalla esimerkillä.</p>

    <p>Kun ohjelmasi toimii kuten toivottu, lähetä se TMC:lle. Huom! Viimeiset 2 riviä saavat rikkoa ohjelman. Älä (vieläkään) aseta matkalaukkuun omaa paino-muuttujaa, vaan laske matkalaukun paino tavaroiden painosta.</p>

<pre class="sh_javascript_dom">
var kivi = new Tavara("kivi", 3);
var kirja = new Tavara("kirja", 7);
var pumpuli = new Tavara("pumpuli", 0.001);

var laukku = new Matkalaukku(10);
var vuitton = new Matkalaukku(3);

laukku.lisaa(kivi);
alert("laukun paino, pitäisi olla 3: " + laukku.paino());
laukku.lisaa(kivi); // virhe: "Tavara lisätty jo, ei onnistu!"

laukku.lisaa(kirja);
alert("laukun paino, pitäisi olla 10: " + laukku.paino());

laukku.lisaa(pumpuli); // virhe: "Liian painava, ei pysty!"

alert("laukun paino, pitäisi olla 10: " + laukku.paino());

vuitton.lisaa(pumpuli);
alert("vuittonin paino, pitäisi olla 0.001: " + vuitton.paino());

// seuraavien komentojen ei pitäisi ainakaan muuttaa vuittonin painoa
pumpuli.paino = 300; // jos tavaralla on metodi paino, hajottaa ohjelman seuraavassa, muuten ei
alert("vuittonin paino, pitäisi olla vieläkin 0.001: " + vuitton.paino()); // paino ei ole muuttunut
</pre>

</div>


  <h3>Moduulien ja olioiden yhdistäminen</h3>

  <p>Suurimmat syyt moduulien käyttöön ovat käytettävien globaalien muuttujanimien vähentäminen sekä tiedon kapselointi. Aiemmin käyttämämme moduulit voidaan nähdä singleton-suunnittelumallia seuraavina olioina tai staattisina funktioina, jotka muokkaavat staattista tilaa. Moduuleista ei ole voinut luoda ilmentymiä.</p>

  <p>Pohditaan aiempaa kauppakassaesimerkkiä, jossa olimme varanneet kaupan toiminnallisuutta varten muuttujan <code>kauppa</code>. Aiempi toteutuksemme ostoskorista oli moduuli, joka tarkoitti sitä, että ostoskoreja voi olla vain yksi kerrallaan. Alustava toteutus näytti seuraavalta:</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.ostoskori = (function() {
    var ostokset = [];

    function lisaaOstos(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    function tuotteitaYhteensa() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }

    // rajapinta
    return {
        lisaa: lisaaOstos,
        tuotteidenLukumaara: tuotteitaYhteensa
    };
})();
</pre>

    <p>Muutetaan ylläoleva moduuli funktioksi siten, että ostoskorista voi tehdä uusia olioita. Muokataan funktioita <code>lisaaOstos</code> ja <code>tuotteitaYhteensa</code> myös siten, että niiden nimet vastaavat yllä määriteltyä rajapintaa.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.Ostoskori = function() {
    var ostokset = [];

    this.lisaa = function(tuotteenNimi) {
        if(!ostokset[tuotteenNimi]) {
            // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
            ostokset[tuotteenNimi] = 0;
        }

        // kasvatetaan tuotteen lukumäärää yhdellä
        ostokset[tuotteenNimi]++;
    }

    this.tuotteidenLukumaara = function() {
        var lukumaara = 0;
        for(var tuotteenNimi in ostokset) {
            lukumaara += ostokset[tuotteenNimi];
        }

        return lukumaara;
    }
}
</pre>


    <p>Voimme nyt luoda uusia ostoskoreja <code>new</code>-operaatiolla.</p>

<pre class="sh_javascript_dom">
var a = new kauppa.Ostoskori();
a.lisaa("kekseja");
a.lisaa("kekseja");
alert(a.tuotteita()); // 2

var b = new kauppa.Ostoskori();
alert(b.tuotteita()); // 0
alert(a.tuotteita()); // 2
</pre>

    <p>Aiemmassa esimerkissämme ostoskorilla oli tiedossa hinnasto, jota ei ylläolevassa esimerkissä ole. Hinnaston lisääminen jokaisen ostoskorin konstruktorikutsun yhteydessä ei ole miellyttävää, joten muokataan edellisestä ostoskorista moduuli, joka kapseloi hinnaston. Haluamme myös säilyttää mahdollisuuden useamman ostoskorin luomiseen. Muokataan ensin ostoskoritoteutusta siten, että se on kapseloitu moduulin sisälle. Luodaan moduuli <code>Ostoskori</code>, joka funktiokutsun yhteydessä <em>palauttaa</em> moduulin kapseloiman konstruktorifunktion nimeltä <code>Kori</code>.</p>

<pre class="sh_javascript_dom">
var kauppa = {};

kauppa.Ostoskori = (function() {

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }
    }

    return Kori;
})();
</pre>

    <p>Ylläolevassa koodissa määritellään anonyymin funktion sisällä konstruktorifunktio <code>Kori</code>, joka kapseloi ostoskorin toiminnallisuuden. Anonyymi funktio suoritetaan heti, sillä sen lopussa on sulut. Käytännössä funktio palauttaa konstruktorifunktion, joka asetetaan olion <ocde>kauppa</code> muuttujaan <code>Ostoskori</code>. Aiemmin tekemämme ohjelma toimii vieläkin.</p>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
alert(kori.tuotteidenLukumaara()); // 2

var laukku = new kauppa.Ostoskori();
alert(laukku.tuotteidenLukumaara()); // 0
alert(laukku.tuotteidenLukumaara()); // 2
</pre>

    <p>Lisätään ostoskorille hinnasto. Käytämme hinnaston toteutuksena aiemmin luomaamme seuraavanlaista hinnastoa.</p>

<pre class="sh_javascript_dom">
kauppa.hinnasto = (function() {
    function annaHinta(tuote) {
        return 3;
    }

    return {
        hinta: annaHinta
    };
})();
</pre>

    <p>Hinnaston lisääminen onnistuu antamalla se parametriksi anonyymille funktiolle.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {
    // moduulin sisäinen muuttuja, joka näkyy kaikille moduulin sisällä
    var hinnat = hinnasto;

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

    <p>Nyt ostoskorilla on käytössä hinnasto. Lisätään ostoskorille vielä metodi ostoskorissa olevien tuotteiden hinnan laskemiseen.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {
    // moduulin sisäinen muuttuja, joka näkyy kaikille moduulin sisällä
    var hinnat = hinnasto;

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }

        this.yhteishinta = function() {
            var summa = 0;
            for(var tuotteenNimi in ostokset) {
                summa += ostokset[tuotteenNimi] * hinnat.hinta(tuotteenNimi);
            }

            return summa;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
alert(kori.tuotteidenLukumaara()); // 2
alert(kori.yhteishinta()); // 6

var laukku = new kauppa.Ostoskori();
alert(laukku.tuotteidenLukumaara()); // 0
alert(laukku.yhteishinta()); // 0

alert(kori.tuotteidenLukumaara()); // 2
alert(kori.yhteishinta()); // 6
</pre>

    <p>Ylläolevassa esimerkissä käytetään moduulille parametrina annettua hinnastoa hintojen laskemiseen. Itseasiassa, koska hinnasto on moduulin parametrina, on se käytössä myös moduulin sisällä. Moduuli ei siis tarvitse erillistä <code>hinnat</code>-muuttujaa.</p>

<pre class="sh_javascript_dom">
kauppa.Ostoskori = (function(hinnasto) {

    // konstruktori
    function Kori() {
        // oliokohtaiset muuttujat
        var ostokset = [];

        // oliokohtaiset metodit
        this.lisaa = function(tuotteenNimi) {
            if(!ostokset[tuotteenNimi]) {
                // jos tuotetta ei ole lisätty ostoskoriin, lisätään se sinne
                ostokset[tuotteenNimi] = 0;
            }

            // kasvatetaan tuotteen lukumäärää yhdellä
            ostokset[tuotteenNimi]++;
        }

        this.tuotteidenLukumaara = function() {
            var lukumaara = 0;
            for(var tuotteenNimi in ostokset) {
                lukumaara += ostokset[tuotteenNimi];
            }

            return lukumaara;
        }

        this.yhteishinta = function() {
            var summa = 0;
            for(var tuotteenNimi in ostokset) {
                summa += ostokset[tuotteenNimi] * hinnasto.hinta(tuotteenNimi);
            }

            return summa;
        }
    }

    return Kori;
})(kauppa.hinnasto);
</pre>

<pre class="sh_javascript_dom">
var kori = new kauppa.Ostoskori();
kori.lisaa("kekseja");
kori.lisaa("kekseja");
alert(kori.tuotteidenLukumaara()); // 2
alert(kori.yhteishinta()); // 6

var laukku = new kauppa.Ostoskori();
alert(laukku.tuotteidenLukumaara()); // 0
alert(laukku.yhteishinta()); // 0

alert(kori.tuotteidenLukumaara()); // 2
alert(kori.yhteishinta()); // 6
</pre>


<!--
<div class="tehtavat">
    <h3>Kirjat ja niiden hinnat</h3>

  <p>kirjalla nimi ja sivujen määrä, hinnat haetaan erillisestä palvelusta.</p>

</div>
-->



    <h2>MV* ja Web-sovelluksen rakenne</h2>


    <p>Termi MVC (<em>Model, View, Controller</em>) esiintyy lähes kaikkialla ohjelmistotekniikassa. MVC on suunnittelumalli, joka pilkkoo sovelluksen kolmeen osaan: dataan (model), näkymään (view), ja käyttäjän interaktioita hallinnoivaan sovelluslogiikkaan eli kontrolleriin (controller). MVC-mallia on käytetty <a href="http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html" target="_blank">alunperin</a> työpöytäsovelluksissa, mutta se on otettu käyttöön myös palvelin- ja selainpuolen ohjelmistoihin niiden kehittyessä. </p>

    <p>Perusideat ovat säilyneet samoina. Käyttäjän tehdessä jotain, esimerkiksi painaessa sivulla olevaa nappia, toimintoon liittyvä tieto välittyy kontrollerille, joka päättää mitä seuraavaksi tehdään. Yleisin toiminto on mallin muokkaaminen tai korvaaminen palvelimelta haetulla datalla, ja uuden näkymän näyttäminen muokattuun malliin perustuen. Palvelinohjelmistoja rakennettaessa tämä tapahtuu esimerkiksi lähettämällä web-sivulla olevan lomakkeen data tiettyyn osoitteeseen, jossa kontrolleri odottaa pyyntöä. Kontrollerin vastaanottaessa pyynnön, pyyntöön liittyvä mahdollinen data tallennetaan. Tämän jälkeen luodaan uusi model, johon haetaan tietoa esimerkiksi tietokantapalvelusta. Model ohjataan näkymän luovalle komponentille, joka lopulta palauttaa uuden näkymän käyttäjälle.</p>

    <p>Dynaamista toiminnallisuutta sisältävissä selainohjelmistoissa erityisesti vastaukset voivat sisältää paljon vähemmän dataa. Koko näkymää ei tarvitse hakea uudestaan jokaisen kyselyn yhteydessä.</p>

    <h3>Esimerkki: Muistuttaja</h3>

    <p>Luodaan sovellus, johon käyttäjä voi lisätä päiväkohtaisia tapahtumia. Jokaiseen tapahtumaan liittyy nimi ja aika. Luodaan aluksi sovellukselle nimiavaruus <code>muistutus</code>, johon sovelluksen toiminnallisuus lisätään.</p>

    <p>Vaikka sovelluksessa käydään läpi sovelluksen osat termeillä Model, View, Controller, ei sovelluksen arkkitehtuuri seuraa MVC-mallia sen perinteisessä mielessä.</p>

<pre class="sh_javascript_dom">
var muistutus = {};
</pre>

    <h4>View</h4>

    <p>MVC-mallissa näkymä vastaanottaa dataa, ja päättää miten se näytetään. Näkymä voi käyttää olemassaolevaa HTML-dokumenttia, ja asettaa siihen dataa, tai se voi luoda uusia elementtejä DOMin avulla. Huomaa että näkymä ja data on erotettu toisistaan, eli näkymä ei tiedä -- eikä välitä -- mallista. Se käsittelee vain dataa, jota sille annetaan. Luodaan HTML-dokumentti, jossa on paikka tapahtumille ja kentät uuden tapahtuman lisäämiselle.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;What's Happening?!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body onload="muistutus.init();" &gt;

        &lt;section id="tapahtumat"&gt;
    &lt;/section&gt;

        &lt;section id="uusitapahtuma"&gt;
            &lt;label&gt;Nimi: &lt;input type="text" id="nimi" /&gt;&lt;/label&gt;
            &lt;label&gt;Aika (vvvv-kk-pp): &lt;input type="text" id="aika" /&gt;&lt;/label&gt;
            &lt;input type="button" id="lisaa" /&gt;
    &lt;/section&gt;


        &lt;script src="muistutus.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Luodaan näkymää varten oma nimiavaruus <code>muistutus.view</code>, ja lähdetään rakentamaan näkymän generointiin tarvittavaa toiminnallisuutta.</p>

<pre class="sh_javascript_dom">
muistutus.view = {};
</pre>

    <p>Luodaan tapahtumien listaamiseen tarvittava näkymä. Huomaa, että näkymä voi tarkoittaa myös sivun sisällä olevaa elementtiä. Luodaan listaus siten, että sille annetaan parametrina elementti, johon tapahtumia lisätään. Tapahtumien listaaminen tapahtuu metodissa <code>listaaTapahtumat</code>. Metodin <code>listaaTapahtumat</code> lisäksi näkymällä on metodi <code>paivita</code>, jota kutsutaan kun näkymä halutaan päivittää. Päivitä-metodille annetaan parametrina data, joka halutaan näyttää näkymässä.</p>

<pre class="sh_javascript_dom">
muistutus.view.Listaus = function(elementti) {

    // julkiset metodit
    this.listaaTapahtumat = function(tapahtumat) {
        tyhjenna();

        for (var i = 0; i < tapahtumat.length; i++) {
            lisaaTapahtuma(tapahtumat[i]);
        }
    }

    this.paivita = function(tapahtumat) {
        // päivitysoperaatio kutsuu listausoperaatiota
        this.listaaTapahtumat(tapahtumat);
    }

    // kapseloidut apufunktiot
    function lisaaTapahtuma(tapahtuma) {
        var tapahtumaElementti = document.createElement("h2");
        var teksti = tapahtuma.nimi + ' (' + tapahtuma.aika + ')';

        tapahtumaElementti.appendChild(document.createTextNode(teksti));
        elementti.appendChild(tapahtumaElementti);
    }

    function tyhjenna() {
        while(elementti.firstChild) {
            elementti.removeChild(elementti.firstChild);
        }
    }
}
</pre>

    <p>Huomaa, että ylläoleva näkymässä aiheutuviin tapahtumiin liittyvää koodia ei sisällytetä näkymän koodiin. Jätetään ne kontrollerille. Koska elementti, johon tapahtumat lisätään, annetaan konstruktorifunktiolle parametrina, on se käytössä myös olion metodeissa.</p>

    <h4>Model</h4>

    <p>Tapahtumakalenteriin liittyvän mallin luominen on helpohkoa. Luodaan ensin oma nimiavaruus <code>muistutus.domain</code>.</p>

<pre class="sh_javascript_dom">
muistutus.domain = {};
</pre>

    <p>Luodaan nimiavaruuteen <code>muistutus.domain</code> konstruktori <code>Tapahtumalista</code>, joka tarjoaa toiminnallisuuden tapahtumien lisäämiseen ja kapselointiin. Tapahtumalista tietää <em>jostain</em>-näkymästä, jonka päivitysoperaatiota se kutsuu kun tapahtumia lisätään.</p>

<pre class="sh_javascript_dom">
muistutus.domain.Tapahtumalista = function(view) {
    var tapahtumat = [];

    this.lisaaTapahtuma = function(tapahtuma) {
        tapahtumat.push(tapahtuma);

        view.paivita(tapahtumat);
    }

    this.annaTapahtumat = function() {
        return tapahtumat;
    }
}
</pre>

    <p>Vaikka haluaisimme myös tehdä erillisen konstruktorin tapahtumalle, käytetään tapahtumia varten JavaScriptin omia olioita. Näin olioiden tallentamistoiminnallisuuden mahdollinen toteutus on helpompaa, sillä funktiota <code>JSON.parse</code> voi käyttää suoraan <code>tapahtumat</code>-muuttujaan.</p>

    <h4>Controller</h4>

    <p>Luodaan seuraavaksi kontrolleri. Kontrollerin tehtävänä on reagoida käyttöliittymässä tapahtuviin tapahtumiin, sekä toimia niiden pohjalta jotenkin. Luomme kontrollereille ensin oman nimiavaruuden <code>muistutus.controller</code>.</p>

<pre class="sh_javascript_dom">
muistutus.controller = {};
</pre>

    <p>Kontrolleri <code>LomakeKontrolli</code> tarjoaa rajapinnan lomake-elementtien käsittelyyn. Kontrollerille voi lisätä elementtejä, joita se kuuntelee. Se tarjoaa myös metodin <code>lisaaTapahtuma</code>, jota voi kutsua tapahtumankäsittelyn yhteydessä. Metodi <code>lisaaTapahtuma</code> käy läpi rekisteröidyt elementit, ja luo niiden pohjalta olion. Olio lähetetään lopulta mallille.</p>

<pre class="sh_javascript_dom">
muistutus.controller.LomakeKontrolli = function(model) {
    var elementit = {};

    this.lisaaDataelementti = function(nimi, elementti) {
        elementit[nimi] = elementti;
    }

    this.lisaaTapahtuma = function(eventInformation) {
        var data = haeData();

        model.lisaaTapahtuma(data);

        tyhjennaElementit();
    }

    function haeData() {
        var data = {};
        for (var nimi in elementit) {
            data[nimi] = elementit[nimi].value;
        }

        return data;
    }

    function tyhjennaElementit() {
        for (var nimi in elementit) {
            elementit[nimi].value = "";
        }
    }
}
</pre>

    <p>Kontrolleri sisältää toiminnallisuuden kontrolloitavien elementtien lisäämiseen, sekä elementtien sisältämän datan lähettämiseen tapahtumalistalle. Huomaa, että kontrolleri ei oikeastaan tiedä tapahtumien muodosta. Se vain kontrolloi lomakkeen elementtejä.</p>

    <h4>Sovelluksen alustaminen</h4>

    <p>Luodaan lopuksi alustusfunktio, joka luo sovelluksessa käytetyt oliot, sekä kytkee HTML-dokumentin elementit kontrolleriin.</p>

<pre class="sh_javascript_dom">
muistutus.init = function() {
    // luodaan palaset
    var listausnakyma = new muistutus.view.Listaus(document.getElementById("tapahtumat"));

    var lista = new muistutus.domain.Tapahtumalista(listausnakyma);
    listausnakyma.listaaTapahtumat(lista.annaTapahtumat());

    var kontrolli = new muistutus.controller.LomakeKontrolli(lista);

    // kytketään kontrolli elementteihin
    kontrolli.lisaaDataelementti("nimi", document.getElementById("nimi"));
    kontrolli.lisaaDataelementti("aika", document.getElementById("aika"));

    document.getElementById("lisaa").addEventListener("click", kontrolli.lisaaTapahtuma, false);
}
</pre>

    <p>Toimii! Sovellusta voisi esimerkiksi jatkokehittää siten, että se sisältäisi datan lähettämisen erilliselle palvelinkomponentille. Tämän lisäksi tapahtumia tulisi pystyä poistamaan.</p>



<div class="tehtavat">

  <h3>Validointi</h3>

  <p>Tehtäväpohjan mukana tulee edellä käsitelty muistutussovellus. Jatkokehitä sovellusta siten, että sovelluksessa on validointitoiminnallisuus. Kun käyttäjä yrittää lisätä tapahtumaa, tulee tapahtuman tiedot validoida.</p>

  <p>Toteuta validointitoiminnallisuus siten, että kontrolleriin voi lisätä validoijia. Kun käyttäjä lisää tapahtumaa, kaikki validoijat käydään läpi yksitellen siten, että data annetaan kullekin validoijalle vuorollaan. Jos validoijan palauttama viesti ei ole tyhjä, eli validoijalla on jotain valitettavaa, viesti tulostetaan <code>alert</code>-komennolla ja validointi lopetetaan. Tällöin tapahtuman lisääminen keskeytetään. Toteuta validoijat tehtäväpohjassa annetun Validoija-konstruktorin pohjalta siten, että kukin validoija on olio, jolla on validoitavan kentän nimen lisäksi validointifunktio, jota kontrollerin tulee kutsua dataa validoitaessa. Validoijan sisältämälle funktiolle annetaan parametrina kentän arvo, ja se palauttaa merkkijonon.</p>

  <p>Esimerkki validoijaoliosta:</p>

<pre class="sh_javascript_dom">
var validoija = new Validoija("nimi", function(data) {
    if(!data) {
        return "Nimi ei saa olla tyhjä!";
    }

    return "";
});

</pre>

  <p>Jos ylläoleva validoija on lisätty kontrollerille, datan lisäyksen ei tule toimia jos nimikenttä on tyhjä.</p>

  <p>Kun kontrolleri tukee validoijien lisäämistä, lisää sinne yllä oleva validoija. Luo myös validoija , joka tarkastaa että aika on muotoa <code>yyyy-MM-dd</code>, esimerkiksi 2012-12-24. Kukin numero saa olla mitä tahansa numeroiden 0 ja 9 välillä. Kannattaa tutustua säännöllisiin lausekkeisiin (google esim.  "javascript regular expressions date").</p>

  <p>Kun sovelluksesi toimii kuten haluttu, palauta se TMC:lle.</p>

</div>


    <h3>Kontrollerin rooli selainohjelmistoissa</h3>


    <p>Yllä olevaa sovellusta luodessa huomaamme, että kontrollerin rooli ei ole kovin selkeä. Muistutus-esimerkissä sovelluksessa kontrolleri toimi elementtien rekisterinä siihen asti, kunnes käyttäjä painoi käyttöliittymän nappia. Napin painalluksenkin rekisteröinti tapahtui kontrollerin ulkopuolella. Sovelluksen voi toteuttaa myös ilman kontrolleria siten, että kontrollerin toiminnallisuus sisällytettäisiin alustukseen.</p>


<pre class="sh_javascript_dom">
muistutus.init = function() {
    // luodaan palaset
    var listausnakyma = new muistutus.view.Listaus(document.getElementById("tapahtumat"));

    var lista = new muistutus.domain.Tapahtumalista(listausnakyma);
    listausnakyma.listaaTapahtumat(lista.annaTapahtumat());

    document.getElementById("lisaa").addEventListener('click', function() {
        var tapahtuma = {
            nimi: document.getElementById("nimi").value,
            aika: document.getElementById("aika").value
        };

        lista.lisaaTapahtuma(tapahtuma);

        document.getElementById("nimi").value = "";
        document.getElementById("aika").value = "";
    }, false);
}
</pre>

    <p>Onko kontrolleri tarpeellinen?</p>

    <p>Jos sovelluksessa on useampia näkymiä, joiden välillä haluaisimme siirtyä, kontrollerista on hyötyä. Pienessä sovelluksessa erillisen kontrollerin käyttö saattaa kuitenkin monimutkaistaa sovelluksen rakennetta -- esimerkiksi yllä kontrollerin toiminnallisuuden pystyi lisäämään osaksi init-funktiota. Kontrollereita käytetään myös erityisesti käyttäjän ohjaamiseen useamman näkymän välillä.</p>


    <h3>Esimerkki: Spoilaaja</h3>

    <p>Toteutetaan seuraavaksi sovellus, jossa ei ole eksplisiittistä kontrolleria. Sovelluksessa näkymässä tapahtuvat päivitykset siirtyvät mallille näkymään liitettyjen tapahtumankäsittelijöiden kautta. Tapahtumankäsittelijät luodaan sovelluksen alustusvaiheessa, jolloin tapahtumankäsittelijät toimivat siltana mallin ja näkymän välillä. Käytännössä näkymä ei tiedä mallista, eikä malli näkymästä.</p>

<pre>

   VIEW    &lt;--- näytä ---    MODEL LISTENER
     |                             |
   muutos                        muutos
     |                             |
VIEW LISTENER --- päivitä --&gt;    MODEL

</pre>


    <p>Sovelluksen aihepiiri on spoilaaja, eli sillä näytetään kirjoihin liittyviä spoilauksia. Hahmotellaan ensin sovelluksen käyttöliittymä. HTML-dokumentin rakenne näyttää seuraavalta:</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8"/&gt;
        &lt;title&gt;Spoilerit!&lt;/title&gt;
    &lt;/head&gt;
    &lt;body onload="spoilaaja.init();"&gt;
        &lt;header&gt;
            &lt;h1&gt;Spoilerit&lt;/h1&gt;
        &lt;/header&gt;

        &lt;section id="spoilaukset"&gt;
        &lt;/section&gt;

        &lt;section id="input"&gt;
            &lt;h2&gt;Syötä uusi&lt;/h2&gt;
            &lt;label&gt;kirja &lt;input type="text" id="kirja"/&gt;&lt;/label&gt;
            &lt;label&gt;spoilaus &lt;input type="text" id="spoilaus"/&gt;&lt;/label&gt;
            &lt;input type="button" id="button" value="Lisää!"/&gt;
        &lt;/section&gt;

        &lt;script src="spoilaus.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

      <p>Ohjelmakoodi lisätään nimiavaruuteen <code>spoilaaja</code>.</p>

<pre class="sh_javascript_dom">
var spoilaaja = {};
</pre>

     <h4>View</h4>

      <p>Luodaan sovelluksen näkymään liittyvä koodi. Ainoa alue, josta olemme kiinnostuneet, on tunnuksella <code>spoilaukset</code> merkitty alue. Näkymälle asetetaan <code>init</code>-funktiolla alueen tunnus, jonka sisälle se lisää dataa. Kun näkymään lisätään dataa, se luo jokaista kirjaa varten oman tekstikentän, joka sisältää kyseisen kirjan spoilauksen. Kun spoilauksen sisältö muuttuu, kutsutaan erillistä näkymälle asetettavaa tapahtumankuuntelijafunktiota muutokseen liittyvällä datalla.</p>

      <p>Tapahtumankuuntelija lisätään sovellukseen sovellusta käynnistettäessä funktiolla <code>setListener</code>. Aina kun näkymään lisätään uutta spoilausta, lisätään tekstikenttään myös tapahtumankuuntelija. Tapahtumankuuntelija lähettää viestin mallille, jos data muuttuu.</p>

<pre class="sh_javascript_dom">
spoilaaja.View = function(containerId) {
    var container = document.getElementById(containerId);
    var listener;

    // julkiset metodit
    this.render = function(data, key, value) {
        if(data !== false) {
            renderAll(data);
        } else {
            renderSingle(key, value);
        }
    }

    this.setListener = function(actionListener) {
        listener = actionListener;
    }

    // apufunktiot
    function renderAll(data) {
        clear();

        for (var key in data) {
            renderSingle(key, data[key]);
        }
    }

    function clear() {
        while(container.firstChild) {
            container.removeChild(container.firstChild);
        }
    }

    function renderSingle(key, value) {
       var element = document.getElementById(key);

       if(!element) {
           // jos elementtiä ei ole vielä olemassa, luodaan sellainen
           createElement(key, value);
       }

       document.getElementById(key).value = value;
    }

    function createElement(key, value) {
        var article = document.createElement("article");
        var label = document.createElement("label");
        var textField = document.createElement("input");
        textField.type="text";

        label.appendChild(document.createTextNode(key));
        textField.id = key;
        textField.value = value;

        article.appendChild(label);
        article.appendChild(textField);

        container.appendChild(article);

        // jokaiseen elementtiin lisätään tapahtumankuuntelija
        if(listener) {
            textField.addEventListener("change", function(eventInformation) {
                var textField = eventInformation.target;
                listener(textField.id, textField.value);
            }, false);
        }
    }
}
</pre>

    <p>Seuraavaksi datan säilytys ja esitys.</p>

    <h4>Model</h4>

    <p>Model kapseloi sovelluksessa käytettävän datan sisäänsä. Tämän lisäksi se tarjoaa aksessorit dataan, sekä tapahtumankäsittelijäfunktion, jota kutsutaan, jos mallin sisältämään dataan tehdään muutoksia. Sovelluksen sisältämä data on käytännössä olio, eli joukko avain-arvo -pareja. Avain on aina kirjan nimi, ja arvo kirjaan liittyvä spoilaus.</p>

<pre class="sh_java">
spoilaaja.Model = function(initialData) {
    var data = initialData;
    var listener;

    this.update = function(key, value) {
        data[key] = value;

        if(!listener) {
            console.log("Model update called, but listener has not been set :(");
            return;
        }

        listener(key, value);
    }

    this.get = function(key) {
        return data[key];
    }

    this.getAll = function() {
        return data;
    }

    this.setListener = function(action) {
        listener = action;
    }
}
</pre>

      <p>Tässä vaiheessa saatat huomata, että ylläolevassa Model-toteutuksessa ei ole minkäänlaista viittausta sovelluksen käyttötarkoitukseen. Tämä on tarkoituskin. Itseasiassa, ylläolevaa toteutusta voisi käyttää monissa muissakin yhteyksissä...</p>

      <h4>Sovelluksen alustaja</h4>

      <p>Luodaan seuraavaksi sovelluksen alustaja. Alustajan tehtävänä on alustaa sovellus, ja kytkeä näkymä ja malli toisiinsa tapahtumankäsitelijöiden kautta. Luodaan ensin sovelluksessa käytettävä data, jonka jälkeen lisätään näkymälle tapahtumankuuntelija. Näkymään liitettävä tapahtumankuuntelija kutsuu mallin update-funktiota jos käsitelty data on muuttunut. Huomaa, että tapahtumalogiikka ei ole osa näkymää, vaan osa sovelluksen alustusta.</p>


<pre class="sh_javascript_dom">
spoilaaja.init = function() {
    var data = {};
    data["Running Blind"] = "Murhaaja on nainen!";
    data["Cat's cradle"] = "se jäätävä homma...";

    var model = new spoilaaja.Model(data);
    var view = new spoilaaja.View("spoilaukset");

    // tapahtuman kuuntelijat viewlle (näin alustava tulostus ei muuta modelia
    view.setListener(function(key, value) {
        console.log("Listener in view called");
        if(model.get(key) !== value) {
            model.update(key, value);
        }
    });
</pre>

      <p>Kun näkymässä on toiminnallisuus mallin päivittämiseen, kutsutaan näkymän <code>render</code>-metodia. Metodi <code>render</code> luo näkymän annetun datan pohjalta.</p>

<pre class="sh_javascript_dom">
    view.render(model.getAll(), false, false);
</pre>

      <p>Lisätään vielä tapahtumankuuntelija modelille. Nyt jos modelissa tapahtuu muutos, se päivitetään myös näkymälle. Tällöin näkymä saa tietoonsa muutokset, jotka tapahtuvat muualla. Luotava tapahtumankuuntelija ja kuuntelijan käsittelyn toteutus mallissa aiheuttaa käytännössä sen, että näkymä saa tietoonsa mallin muutokset.</p>

<pre class="sh_javascript_dom">
    model.setListener(function(key, value) {
        view.render(false, key, value);
    });
</pre>

      <p>Kytketään lopuksi käyttöliittymässä olevaan nappiin spoilauksen lisäystoiminnallisuus.</p>

<pre class="sh_javascript_dom">
    // kytketään nappi toimimaan
    var nappi = document.querySelector("#input #button");
    nappi.addEventListener("click", function(eventInformation) {
        var kirja = document.querySelector("#input #kirja").value;
        if(!kirja) {
            return;
        }
        var spoilaus = document.querySelector("#input #spoilaus").value;

        model.update(kirja, spoilaus);
    }, false);
}
</pre>


<div class="extra">
  <p><strong>Observer Pattern</strong></p>

  <p>Suunnittelumallia, jossa komponenttiin voi lisätä muiden komponenttien kutsufunktioita siten, että niitä kutsutaan komponentin päivittyessä kutsutaan <a href="http://en.wikipedia.org/wiki/Observer_pattern" target="_blank">Observer Patterniksi</a>. Käytännössä komponentti ei tiedä muista komponenteista mitään, sillä on vain pääsy niiden tarjoamassa rajapinnassa olevaan yksittäiseen kutsufunktioon.</p>

</div>

<div class="tehtavat">
    <h3>Spoilaajan Backend (2p)</h3>

    <p>Muistellaan taas JSON-kyselyjen tekemistä palvelimelle. Käy kertaamassa kappale 8 ennen tätä tehtävää. Tehtävänäsi on tässä lisätä edellä esitettyyn ohjelmaan backend-toiminnallisuus. Backend-toiminnallisuuden tehtävänä on sovelluksen käynnistyessä hakea olemassaolevat spoilaukset palvelimelta, sekä lähettää palvelimelle mahdolliset muutokset.</p>

    <p>Spoilausten tallentamiseen käytetty palvelinsovellus toimii osoitteessa <a href="http://bad.herokuapp.com/app/" target="_blank">http://bad.herokuapp.com/app/</a>. Kannattaa tehdä kysely palvelimelle selaimella ennen tehtävän tekemistä, jotta palvelin on varmasti käynnissä. Palvelin tarjoaa osoitteessa <code>http://bad.herokuapp.com/app/spoilers/</code> toimivan rajapinnan. Kun rajapintaan tehdään GET-kysely, palvelin palauttaa kaikki tallennetut spoilaukset.</p>

    <p>Uusien spoilausten lisääminen tai olemassaolevien muokkaaminen tapahtuu POST-pyynnöllä rajapintaan. POST-pyyntö tehdään siten, että sen mukana lähetetään JSON-muotoista dataa merkkijonomuodossa. JSON-datan tulee näyttää seuraavalta oliomuodossa:</p>

<pre class="sh_javascript_dom">
var lahetettava = {
    name: "spoilattava",
    spoiler: "spoilaus"
};
</pre>

    <p>Toteuta sovellus aluksi niin, että toteutat vain Backend-komponentin, joka tallettaa dataa. Kun saat sovelluksen kommunikoimaan backend-komponentin kanssa, lisää backendille viestien lähetys ja vastaanottaminen palvelimelle. Tässä kohdassa voi olla hyödyllistä tutustua synkronoituihin XMLHttpRequest-pyyntöihin (google esim. "synchronous xmlhttprequest send").</p>

</div>

    <h3>MVC, MVP, MVVM, ...</h3>

    <p>Käytännössä kaikissa MV* -suunnittelumalleissa ajatuksena on näkymän ja sovelluslogiikan erottaminen toisistaan. Näimme aiemmin MVC-mallin, jossa pyyntö käytännössä kulkee näkymältä kontrollerille, joka ohjaa pyynnön mallille. Malli taas päivittää näkymää tarpeen vaatiessa. Käytännössä pyynnön kulku MVC-mallissa näyttää seuraavalta:</p>

<pre>
                  <em>kliksu</em>
                    ||
                    \/
                   VIEW
               /         /\
              /           \
<em>ohjauspyyntö</em> /             \  <em>päivitys</em>
            /               \
           \/                \
  CONTROLLER  - muokkaus - >  MODEL

</pre>

   <p>Kaksi viime aikoina päätänsä nostanutta MVC-varianttia ovat MVP (<em>Model, View, Presenter</em>) ja MVVM (<em>Model, View, ViewModel</em>). Tutustutaan niihin pikaisesti.</p>

   <h4>MVP</h4>

   <p>Joissain tapauksissa sovelluksissa ei ole suoraa mahdollisuutta näkymän ja mallin toisiinsa kytkemiseen. Tällöin sovellus tarvitsee näkymän ja mallin välille erillisen komponentin, joka ohjaa pyyntöjä näkymältä malliin ja mallilta näkymään. ASCII-kaaviona sovelluksen MVP näyttää seuraavalta:</p>

<pre>
               <em>kliksu</em>
                 ||
                 \/
                VIEW
                / /\
               /  /
              /  /
<em>ohjauspyyntö</em> /  /  <em>päivitys</em>
            /  /
           \/ /
        PRESENTER
            \  /\
             \  \
              \  \
    <em>muokkaus</em>   \  \   <em>muutos/tapahtuma</em>
                \  \
                 \  \
                 \/  \
                  MODEL
</pre>

   <p>Voimme muokata aiemmin tekemäämme muistutussovellusta seuraamaan MVP-mallia poistamalla mallilta riippuvuuden näkymään, ja lisäämällä kontrolleriin päivityksen tekemisen näkymälle. Käytännössä Presenter-oliolle tulisi lisätä myös tapahtumankuuntelija, jota model voisi kutsua tarvittaessa.</p>


   <h4>MVVM</h4>

   <p>MVVM on muunnos MVP:hen, jossa ViewModel on mallista valittua näkymää varten muokattu esitys käytössä olevasta datasta. ViewModel on kytkeytynyt näkymään näkymän tarjoaman funktion kautta. Kun ViewModelissa oleva data muuttuu, se kutsuu näkymän tarjoamaa funktiota siten, että näkymä päivittää itsensä ViewModel-olion pohjalta.</p>


<pre>
               <em>kliksu</em>
                 ||
                 \/
                VIEW
                / /\
               /  /
              /  /
<em>ohjauspyyntö</em> /  /  <em>tapahtumakutsu</em>
            /  /
           \/ /
        VIEWMODEL
            \  /\
             \  \
              \  \
    <em>muokkaus</em>   \  \   <em>muutos/tapahtuma</em>
                \  \
                 \  \
                 \/  \
                  MODEL
</pre>


<!--
<div class="tehtavat">
  <h3>TBA</h3>

  <h3>MV?</h3>

  <p>Sovelluksen mukana tulee Model ja View. Toteuta liima, joka yhdistää ne keskenään.</p>

</div>
-->



    <h2>Valmiit JavaScript-kirjastot</h2>


    <p>Osa aiemmin toteuttamistamme ohjelmista ei toimi kaikilla nykyaikaisilla selaimilla. Osassa taas toistetaan samoja asioita uudestaan ja uudestaan. Yhteensopivuusongelmat johtuvat suurelta osin selainvalmistajien heikosta standardien seuraamisesta, ja innottomuudesta vanhempien selainten päivittämiseen. Selainohjelmistoja kehitettäessä tulee huomioida myös vanhempien selainten käyttäjät -- sovelluksen tilaajan määrittelemään pisteeseen asti.</p>

    <p>Selainohjelmistojen tekemiseen on huomattava määrä valmiita kirjastoja, joiden yksi tarkoitus on poistaa joidenkin selainten tietynlaiset JavaScript-syntaksin vaatimukset. Kirjastot tarjoavat myös apufunktioita toistuvan koodin ja toiminnallisuuden vähentämiseen. Mielenkiintoista JavaScript-kirjastojen ilmentymisessä on se, että JS-yhteisössä on havaittavissa samanlaista käyttäytymistä kuin palvelinpuolen yhteisöissä muutamia vuosia sitten.</p>

    <p><em>Kyllähän se kirjasto <strong>xxx</strong> on parempi kun se tekee tän yhdellä rivillä, sun sovelluskehyksellä menee seitsemän!</em></p>

   <p>Aivan kuten ohjelmointikielten tapauksessa, tietyt ohjelmistokirjastot sopivat joihinkin asioihin paremmin, toiset toisiin. Tutustutaan seuraavaksi tällä hetkellä ehkäpä eniten käytettyyn JavaScript-kirjastoon, <a href="http://jquery.com/" target="_blank">jQueryyn</a>.</p>


    <h3>jQuery</h3>

    <p><a href="http://jquery.com/" target="_blank">jQuery</a> on JavaScript-kirjasto, jonka tarkoitus on helpottaa selainohjelmistojen toteutusta. Se tarjoaa tuen mm. DOM-puun muokkaamiseen, tapahtumien käsittelyyn sekä palvelimelle tehtäviin kyselyihin, ja sen avulla toteutettu toiminnallisuus toimii useimmissa selaimissa.</p>

    <p>Uusimman jQuery-version saa ladattua <a href="http://jquery.com/download/" target="_blank">täältä</a>. Käytännössä jQuery on JavaScript-tiedosto, joka ladataan sivun latautuessa. Tiedoston voi asettaa esimerkiksi <code>head</code>-elementin sisään, tai ennen omia lähdekooditiedostoja.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" /&gt;
        &lt;title&gt;Selaimen palkissa ja suosikeissa näkyvä otsikko&lt;/title&gt;
     &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sivun sisältö --&gt;

        &lt;script src="javascript/jquery-1.8.2.min.js"&gt;&lt;/script&gt;
        &lt;script src="javascript/koodi.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>


    <h4>Valitsimet</h4>

    <p>Olemme tähän mennessä käyttäneet valmiita JavaScriptin DOM-toiminnallisuuksia. Elementtien etsimiseen on käytetty mm. Selectors APIn <code>querySelector</code>-kutsua, esimerkiksi komennolla <code>var elementti = document.querySelector("#nimi");</code> haetaan elementti, jonka tunnus on "nimi". JQuery käyttää <a href="http://sizzlejs.com/" target="_blank">Sizzle</a>-kirjastoa elementtien valinnan helpottamiseen. Esimerkiksi sivun elementti, jonka tunnus on "nimi", löytyy seuraavalla komennolla.</p>

<pre class="sh_javascript_dom">
var elementti = $("#nimi");
</pre>

    <p>Kyselyiden formaatti on siis <code>$("<em>kysely</em>")</code>, missä kysely on hyvin samankaltainen kuin aiemmin käyttämämme Selector APIn kyselyrajapinta. Vastaavasti kaikki <code>header</code>-elementissä olevat <code>a</code>-elementteihin löytyy komennolla.</p>

<pre class="sh_javascript_dom">
var elementit = $("header a");
</pre>

    <p>Myös tietyn luokan toteuttavien elementtien haku on helppoa. Alla olevassa esimerkissä on kolme tekstikenttää, joista 2 on piilotettu. Piilotettujen tekstikenttien tyyliluokka on <code>jquery-dom-1-hidden</code>.</p>

<style>
.jquery-dom-1-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="jquery-dom-1">
    <p class="jquery-dom-1-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-1-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-1-js" rows="6" cols="80">var elementit = $(".jquery-dom-1-hidden");
for(var i = 0; i < elementit.length; i++) {
    elementit[i].className = "";
}
</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-1-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Huomaa, että koodi toimii, sillä jQuery on ladattu osaksi tätä sivua. Huomaa myös, että ylläolevan koodin voi tehdä huomattavasti tehokkaammin.</p>

<div class="extra">
  <p><strong>jQueryn valitsimet</strong></p>

  <p>Tarkempi kuvaus jQueryn valitsimista löytyy osoitteesta <a href="http://api.jquery.com/category/selectors/" target="_blank">http://api.jquery.com/category/selectors/</a>.</p>
  <p>&nbsp;</p>
</div>

    <h4>DOM-puun muokkaus</h4>

    <p>JQuery lisää DOM-puun elementteihin toiminnallisuuksia, jotka helpottavat DOM-puun muokkausta. Esimerkiksi metodi <code>removeClass</code> poistaa elementiltä tai kokoelmalta elementtejä halutun luokan. Alla on sama esimerkki kuin yllä, mutta nyt piilotettujen elementtien tyyliluokka on <code>jquery-dom-2-hidden</code>.</p>

<style>
.jquery-dom-2-hidden {
    display: none;
}
</style>

<div class="naytto">
  <article class="jquery-dom-2">
    <p class="jquery-dom-2-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-2-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-2-js" rows="4" cols="80">var elementit = $(".jquery-dom-2-hidden");
elementit.removeClass("jquery-dom-2-hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-2-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Yllä olevassa esimerkissä haetaan kaikki elementit, joiden tyyliluokka on "jquery-dom-2-hidden", ja poistetaan niiltä haluttu tyyli. Koska uudet toiminnallisuudet on lisätty elementteihin, voidaan kyselyt myös ketjuttaa. Alla haetaan ensin kaikki elementit, joiden tyyliluokka on <code>jquery-dom-3-hidden</code>, jonka jälkeen haluttu tyyliluokka poistetaan.</p>

<style>
.jquery-dom-3-hidden {
    display: none;
}
</style>

<style>
.hidden {
    display: none;
}
</style>


<div class="naytto">
  <article class="jquery-dom-3">
    <p class="jquery-dom-3-hidden">text 1</p>
    <p>text 2</p>
    <p class="jquery-dom-3-hidden">text 3</p>
  </article>
</div>

    <div class="test-js">
      <p><textarea id="jquery-dom-3-js" rows="2" cols="80">$(".jquery-dom-3-hidden").removeClass("jquery-dom-3-hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-3-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Kyselyiden avulla voidaan luoda myös monimutkaisen näköisiä rakenteita. Alla haetaan kaikki <code>body</code>-elementin sisällä olevat solmut, joilla ei ole tunnusta "jquery-dom-4-js-esim", ja jotka eivät ole sen alla olevia <code>textare</code> tai <code>input</code>-elementtejä. Kun solmut on haettu, solmuille lisätään tyyliluokka "hidden".</p>

    <div class="test-js" id="jquery-dom-4-js-esim">
      <p><textarea id="jquery-dom-4-js" rows="2" cols="80">$("body > :not(#jquery-dom-4-js-esim,#jquery-dom-4-js-esim textarea,#jquery-dom-4-js-esim input)").addClass("hidden");</textarea></p>
      <p><input type="button" onclick="evalElementContent('jquery-dom-4-js')" value="Suorita koodi!"></input></p>
    </div>

    <p>Jos klikkaat ylläolevaa nappia, joutunet muokkaamaan koodia jotta saat sivun takaisin näkyville.</p>


<div class="extra">
  <p><strong>DOM-puun muokkaus</strong></p>

  <p>Tarkempi kuvaus operaatioista DOM-puun muokkaamiseen löytyy osoitteesta <a href="http://api.jquery.com/category/Manipulation/" target="_blank">http://api.jquery.com/category/Manipulation/</a>.</p>
  <p>&nbsp;</p>
</div>


    <h4>Tapahtumien käsittely</h4>

    <p>JQuery rakentaa JavaScriptin valmiiden komponenttien päälle, joten sillä on toiminnallisuus myös tapahtumankäsittelijöiden rekisteröimiseen sivun komponenteille. Tutkitaan seuraavaa jo tutuhkoa HTML-dokumenttia. </p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Kindler&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body onload="init();"&gt;
        &lt;header&gt;
            &lt;h1&gt;Kindler&lt;/h1&gt;

            &lt;nav&gt;
                &lt;a href="#"&gt;Eka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Toka artikkeli&lt;/a&gt;
                &lt;a href="#"&gt;Kolmas artikkeli&lt;/a&gt;
            &lt;/nav&gt;
        &lt;/header&gt;

    &lt;section&gt;
          &lt;article&gt;
        &lt;h1&gt;Eka artikkeli&lt;/h1&gt;

        &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit...&lt;/p&gt;
      &lt;/article&gt;

          &lt;article&gt;
        &lt;h1&gt;Toka artikkeli&lt;/h1&gt;

        &lt;p&gt;Morbi a elit enim, sit amet iaculis massa. Vivamus blandit...&lt;/p&gt;
      &lt;/article&gt;

          &lt;article&gt;
        &lt;h1&gt;Kolmas artikkeli&lt;/h1&gt;

        &lt;p&gt;Now that we know who you are, I know who I am. I'm...&lt;/p&gt;
      &lt;/article&gt;
    &lt;/section&gt;

        &lt;!-- lähdekooditiedostojen lataus --&gt;
    &lt;script type="text/javascript" src="javascripts/jquery-1.8.2.min.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodit.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Olemme aiemmin määritelleet tapahtumankäsittelyn osana HTML-dokumenttia siten, että JavaScript-kutsut on lisätty erillisessä init-metodissa (unohdamme MVC-mallin hetkeksi esimerkin yksinkertaistamiseksi). Alla oleva lähdekoodi käyttää aiemmin oppimaamme <code>querySelector</code>-toteutusta siihen, että tapahtumankäsittelijät lisätään vain menuvalikon linkkeihin. Kutsu <code>preventDefault()</code> estää linkin seuraamisen.</p>

<pre class="sh_javascript_dom">
function init() {
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
}

function displayArticle(index) {
    var articles = document.getElementsByTagName("article");

    for(var i = 0; i < articles.length; i++) {
        if (index == i) {
            articles[i].className='';
        } else {
            articles[i].className='hidden';
        }
    }
}
</pre>


    <p>Muokataan ylläolevaa esimerkkiä siten, että käytämme JQueryä.</p>

    <p>Muokataan ensin funktio <code>displayArticle</code> toiminnallisuutta. Toteutetaan se siten, että funktiokutsussa piilotamme aina ensin kaikki artikkelit, jonka jälkeen näytämme indeksin määräämän artikkelin. Valitsimella ":eq(<em>indeksi</em>)" voimme valita elementin tietystä indeksistä.</p>

<pre class="sh_javascript_dom">
function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>Lähdetään seuraavaksi pilkkomaan function <code>init</code>-toiminnallisuutta. Asetetaan funktion <code>init</code> toiminnallisuus ensin <code>$(document).ready(function(){    });</code>-lohkon sisään. Lohkon sisältö suoritetaan kun sivun lataaminen on valmis -- emme enää tarvitse <code>body</code>-elementin <code>onload</code>-attribuuttia. Koodi näyttää nyt seuraavalta:</p>

<pre class="sh_javascript_dom">
$(document).ready(function(){
    var navLinks = document.querySelectorAll("header nav a");
    for(var i = 0; i < navLinks.length; i++) {
        var link = navLinks[i];

        // lisätään elementille id, josta päätellään näytettävä artikkeli
        link.id = i;

        // lisätään tapahtumankuuntelija tapahtumalle click. huom! ero onclick-attribuuttiin
        link.addEventListener('click', function(eventInformation) {
            var origin = eventInformation.target;

            // kutsutaan erillistä displayArticle-funkiota, joka
            // näyttää halutun artikkelin
            displayArticle(origin.id);

            // kielletään selainta tekemästä oletustoiminto (siirtyminen)
            eventInformation.preventDefault();
        }, false);
    }

    // ...
});

function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>Luodaan ensin toiminnallisuus, jolla linkkeihin asetetaan tunnus-attribuutit. JQueryssä on kätevä kokoelman iterointiin tarkoitettu <code><a href="http://api.jquery.com/each/" target="_blank">each</a></code>-komento, joka saa JQueryltä parametrinaan iteroitavan elementin indeksin. Muuttuja <code>$(this)</code> viittaa kyseisellä hetkellä läpikäytävään muuttujaan. Allaoleva komento käy läpi jokaisen linkki-elementin, ja kutsuu kullekin <code>each</code>-komennolle parametrina antamaamme funktiota. Komento <code>attr</code> asettaa (tai hakee jos toista parametria ei määritellä) elementin komennossa määritellyn attribuutin.</p>

<pre class="sh_javascript_dom">
    $("header nav a").each(function(index) {
        $(this).attr("id", index);
    });
</pre>


    <p>Lisätään seuraavaksi jokaiselle linkille tapahtumankäsittelijä. Komento <code><a href="http://api.jquery.com/click/" target="_blank">click</a></code> auttaa tässä huomattavasti. Voimme hyödyntää myös aiemmin huomaamaamme <code>each</code>-komentoa. Alla lisäämme jokaiseen linkkiin funktion, joka kuuntelee klikkausta. Funktion sisältö lienee tuttu.</p>

<pre class="sh_javascript_dom">
    $("header nav a").each(function(index) {
        $(this).click(function(eventInformation) {
            displayArticle(eventInformation.target.id);
            eventInformation.preventDefault();
        });
    });
</pre>


    <p>Each-komento tarjoaa meille indeksin, joten muokataan edellistä vielä hieman. Käytetään suoraan each-komennon tarjoamaa indeksiä artikkelin näyttämiseen.</p>

<pre class="sh_javascript_dom">
    $("header nav a").each(function(index) {
        $(this).click(function(eventInformation) {
            displayArticle(index);
            eventInformation.preventDefault();
        });
    });
</pre>

    <p>Huomaamme vielä, että voimme yhdistää linkin tunnuksen lisäämisen ja tapahtumankäsittelyn lisäämisen saman <code>each</code>-komennon sisään.</p>

<pre class="sh_javascript_dom">
    $("header nav a").each(function(index) {
        $(this).attr("id", index);
        $(this).click(function(eventInformation) {
            displayArticle(index);
            eventInformation.preventDefault();
        });
    });
</pre>


    <p>Koodimme näyttää nyt kokonaisuudessaan seuraavalta:</p>

<pre class="sh_javascript_dom">
$(document).ready(function(){

    // sattumalta saa parametrina indeksin
    $("header nav a").each(function(index) {
        $(this).attr("id", index);
        $(this).click(function(eventInformation) {
            displayArticle(index);
            eventInformation.preventDefault();
        });
    });
});

function displayArticle(index) {
    $("article").addClass("hidden");
    $("article:eq(" + index + ")").removeClass("hidden");
}
</pre>

    <p>HTML-dokumentista on myös poistettu <code>body</code>-elementin <code>onload</code>-attribuutti.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;Kindler&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body&gt;

        &lt;!-- sama sisältö kuin aiemminkin --&gt;

    &lt;script type="text/javascript" src="javascripts/jquery-1.8.2.min.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodit.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

<div class="tehtavat">
  <h3>JQueryMOOC</h3>

  <p>Muokkaa tehtäväpohjan mukana tulevaa tehtävistä W1E08 ja W2E02 tuttua MOOC-sivua siten, että elementtien näyttäminen ja piilottaminen toteutetaan JQueryn tarjoamien apuvälineiden avulla.</p>

  <p>Poista lopulta myös turhaksi tullut myös turha body-elementin onload-attribuutti.</p>

  <p>Kun olet vaihtanut toteutuksen JQueryksi, ja toteutuksen toiminnallisuus on ennallaan, palauta tehtävä TMC:lle.</p>
</div>


    <h4>Kyselyt palvelimelle</h4>

    <p>JQuery tarjoaa myös tuen kyselyjen tekemiseen erilliselle palvelinkomponentille.</p>

    <p><strong>JSONP</strong></p>

    <p>JSONP-kyselyt, eli kyselyt, joissa vastauksena tulee selaimessa evaluoitavaa JavaScript-koodia hoituvat kätevästi JQueryn <code><a href="http://api.jquery.com/jQuery.getJSON/" target="_blank">$.getJSON</a></code>-funktiolla. Alla olevassa esimerkissä haemme Twitterin JSONP-apista rageresearch-tunnuksen lähettämiä viestejä. JQuery määrittelee callback-funktion itse, ja asettaa sen osoitteeseen jätettävän kysymysmerkin kohdalle.</p>

    <p>Kyselyn palauttama data ohjataan <code>$.getJSON</code>-funktion toisena parametrina määriteltävään funktioon. Alla olevassa esimerkissä kutsumme vain <code>alert</code>-komentoa.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.twitter.com/1/statuses/user_timeline/rageresearch.json?count=4&callback=?",
    function(data) {
        alert(data);
    }
);
</pre>

    <p>Ylläoleva esimerkki palauttaa listan olioita. Käytetään JQueryn <code>each</code>-komentoa listassa olevien elementtien iterointiin. Komennolle <code>each</code> voi antaa parametrina iteroitavan listan, sekä funktion, jota kutsutaan jokaisella listassa olevalla oliolla.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.twitter.com/1/statuses/user_timeline/rageresearch.json?count=4&callback=?",
    function(data) {
        $.each(data, function(i, item) {
            alert(i + ": " + item);
        });
    }
);
</pre>

    <p>Nyt ylläoleva komento tulostaa oliot yksitellen. Oletetaan, että käytössämme on elementti, jonka tunnus on "viestit". JQuery tarjoaa myös mahdollisuuden nopeaan tekstielementtien luontiin komennolla <code>$("&lt;p/&gt")</code>. Elementteihin voi asettaa tekstin <code>text</code>-komennolla, ja elementin voi lisätä tietyllä tunnuksella määriteltyyn elementtiin komennolla <code>appendTo("#<em>tunnus</em>")</code>.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://api.twitter.com/1/statuses/user_timeline/rageresearch.json?count=4&callback=?",
    function(data) {
        $.each(data, function(i, item) {
            $("&lt;p/&gt;").text(item.text).appendTo("#viestit");
        });
    }
);
</pre>

    <p><strong>XMLHttpRequest</strong></p>

    <p>Jos tiedämme, että palvelu palauttaa JSON-dataa, voimme käyttää yllä käsiteltyä lähestymistapaa. Esimerkiksi viestien noutaminen Chat-chat -tehtävän viestipalvelimelta onnistuu seuraavalla komennolla. Tässä tapauksessa lisäämme jokaiseen viestiin liittyvän <code>message</code>-attribuutin "viestit" -tunnuksella määriteltyyn elementtiin.</p>

<pre class="sh_javascript_dom">
$.getJSON("http://bad.herokuapp.com/app/messages", function(data) {
    $.each(data, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#viestit");
    });
});
</pre>

    <p>Yllä oleva komento on lyhenne alla määritellystä komennosta.</p>

<pre class="sh_javascript_dom">
$.ajax({
    url: "http://bad.herokuapp.com/app/messages",
    dataType: 'json',
    success: parseMessages
});

function parseMessages(messages) {
    $.each(messages, function(i, item) {
        $("&lt;p/&gt;").text(item.message).appendTo("#viestit");
    });
}
</pre>

    <p>Komennolle <code><a href="http://api.jquery.com/jQuery.ajax/" target="_blank">$.ajax</a></code> voi lisätä myös dataa, mitä lähetetään palvelimelle. Esimerkiksi seuraavalla komennolla lähetetään osoitteeseen <code>http://bad.herokuapp.com/app/in</code> olio, jonka sisällä on attribuutit <code>name</code> ja <code>details</code>. Lähetettävän datan tyyppi asetetaan attribuutilla <code>contentType</code>, alla ilmoitamme että data on json-muotoista, ja että se käyttää utf-8 -merkistöä. </p>

<pre class="sh_javascript_dom">
var dataToSend = JSON.stringify({
        name: "bob",
        details: "i'm ted"
    });

$.ajax({
    url: "http://bad.herokuapp.com/app/in",
    dataType: 'json',
    contentType:'application/json; charset=utf-8',
    type: 'post',
    data: dataToSend
});
</pre>


    <p>Pyynnössä voi myös sekä lähettää, että vastaanottaa dataa. Attribuutin <code>success</code> asettaminen ylläolevaan pyyntöön aiheuttaa success-attribuutin arvona olevan funktion kutsun kun pyyntö on onnistunut.</p>

<div class="tehtavat">
  <h3>JQuerySpoilaajanBackend</h3>

  <p>Toteuta Spoilaajan Backend-tehtävä tässä JQueryn avulla. Jos hyödynsit aiemmin synkronisia kutsuja, kannattaa hyödyntää niitä myös tässä. Vinkki: <code>$.ajax</code>-komennolle asettaa attribuutin <code>async: false</code>, jolloin tulee myös määritellä <code>success</code>-attribuutille funktio, jota kutsutaan kun data on noudettu.</p>

</div>


    <h3>Näkymätemplatet ja Mustache.js</h3>

    <p>Selainohjelmistojen rakennetta suunniteltaessa yksi huolenaihe on sivun eri näkymien järkevä hallinta. Aiemmin näkemässämme esimerkissä sivun osia piilotetaan ja näytetään dynaamisesti. Toinen pulma liittyy HTML-koodin generointiin datan pohjalta: generointi on auttamatta työlästä.</p>

    <p>Näkymätemplatet ovat HTML-koodipätkiä, jotka sisältävät halutun HTML-rakenteen sekä paikat datalle. Eräs projekti näkymätemplatejen generointiin on <p><a href="https://github.com/janl/mustache.js" target="_blank">Mustache.js</a>, joka on <a href="http://mustache.github.com/" target="_blank">mustache</a>-projektin osa.</p>

    <p>Käytännössä näkymätemplatejen käyttö toimii siten, että HTML-dokumenttiin piilotetaan osa, joka sisältää kaikki HTML-templatet. Kun käyttäjä esimerkiksi klikkaa linkkiä, renderöidään näkyvälle alueelle templaten ja datan pohjalta uusi sisältö. Tutkitaan alla olevaa esimerkkiä, jossa on erillinen osio tunnuksella "view", ja toinen piilotettu osio, joka sisältää templatet.</p>

<pre class="sh_html">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="utf-8" &gt;&lt;/meta&gt;
        &lt;title&gt;&lt;/title&gt;
        &lt;link rel="stylesheet" href="style.css" type="text/css" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
    &lt;section id="view"&gt;
    &lt;/section&gt;

    &lt;div class="hidden"&gt;
        &lt;div id="template"&gt;
            &lt;article&gt;
                &lt;h2&gt;{{nimi}} {{ika}}&lt;/h2&gt;
                &lt;/article&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;!-- lähdekooditiedostojen lataus, käytössä vain mustache.js --&gt;
    &lt;script type="text/javascript" src="javascripts/jquery-1.8.2.min.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="javascripts/mustache.js"&gt;&lt;/script&gt;
        &lt;script type="text/javascript" src="javascripts/koodi.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

    <p>Tyylitiedosto <code>style.css</code> sisältää vain yhden määrittelyn.</p>

<pre class="sh_css">
.hidden {
    display: none;
}
</pre>

    <p>Lähdekooditiedosto <code>koodi.js</code> sisältää seuraavanlaisen lähdekoodin.</p>

<pre class="sh_javascript_dom">
$(document).ready(function() {
    var data = {
        nimi: "Bob",
        ika: function() {
            return 14+7;
        }
    };

    var html = Mustache.render($("#template").html(), data);
    $("#view").html(html);
});
</pre>

    <p>Tutkitaan koodia hieman tarkemmin. Komennolla <code>$(document).ready(function() { ... });</code> määritellään toiminnallisuus, joka suoritetaan kun sivu on latautunut. Toiminnallisuus sisältää olion luomisen. Luomme olion, jolla on attribuutit nimi (arvo "Bob"), ja ika (arvo funktion palauttama arvo).</p>

    <p>Tämän jälkeen oleva koodi ei olekaan vielä tuttua. JQuery tarjoaa pääsyn elementin html-koodiin komennolla <code><a href="http://api.jquery.com/html/" target="_blank">html</a></code>, eli komento <code>$("#template").html()</code> palauttaa tunnuksella "template" merkityn elementin sisältämän HTML-koodin. Tämä koodi annetaan Mustachen <code>render</code>-komennolle yhdessä data-olion kanssa. Mustachen <code>render</code>-komento asettaa olion data sisällön HTML-koodissa merkityille paikoille, ja palauttaa uuden merkkijonon. Merkkijono sisältää HTML-koodin, jossa merkityt kohdat sisältävät nyt datasta saadut arvot.</p>

      <p>Lopuksi html-koodi asetetaan tunnuksella "view" määritellyn elementin sisään.</p>

      <h4>Listojen läpikäynti</h4>

      <p>Listojen läpikäynti onnistuu {{#<em>muuttuja</em>}}-operaattorilla, joka aloittaa läpikäynnin. Läpikäynnin lopetus tapahtuu {{/<em>muuttuja</em>}}-operaattorilla. Esimerkiksi alla on määritelty <code>messages</code>-attribuutissa olevien olioiden läpikäynti siten, että jokaiselta oliolta kutsutaan attribuuttia <code>nickname</code> ja <code>message</code>.</p>

<pre class="sh_html">
    &lt;div class="hidden"&gt;
        &lt;div id="template"&gt;
                &lt;article&gt;
                    {{#messages}}
                        &lt;p&gt;&lt;strong&gt;{{nickname}}:&lt;/strong&gt; {{message}}&lt;/p&gt;
                    {{/messages}}
               &lt;/article&gt;
            &lt;/div&gt;
        &lt;/div&gt;
</pre>

    <p>Voimme kytkeä ylläolevan templaten helposti Chat-chat -tehtävän viestit hakevaan palveluun.</p>

<pre class="sh_javascript_dom">
function parseMessages(messages) {
    var data = {
        messages: messages
    };

    var html = Mustache.render($("#template").html(), data);
    $("#view").html(html);
}

$(document).ready(function() {
    $.ajax({
        url: "http://bad.herokuapp.com/app/messages",
        dataType: 'json',
        success: parseMessages
    });
});
</pre>

    <p>Ehkäpä tärkein muistettava ylläolevassa esimerkissä on se, että data tulee antaa Mustachelle olion sisällä. Jos render-komentoa kutsutaan suoraan messages-oliolla, joka sisältää listan chat-viestejä, ei Mustache tiedä miten toimia.</p>

<div class="tehtavat">
  <h3>Movember (2p)</h3>

  <p>Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että näkymä generoidaan tarvittaessa HTML-templateista. Tiedostossa <code>code.js</code> olevaan muuttujaan <code>data</code> on asetettu valmiiksi HTML-dokumentissa tällä hetkellä olevat sisällöt. Tehtävänäsi on muokata tiedostoa <code>index.html</code> siten, että se sisältää template-elementin, jonka pohjalta sivun näkymiä (perusmooc, materiaali, ...) voidaan luoda. </p>

  <p>Muokkaa myös tiedostoa <code>code.js</code> siten, että kukin näkymä generoidaan aina linkkiä klikattaessa. Generoitu näkymä tulee asettaa osaksi näkymäaluetta, jonka joudut myös luomaan. Kannattaa hyödyntää aiemmin tekemääsi JQueryMOOC-pohjaa.</p>

  <p>Lykkyä tykö!</p>
</div>


<div class="extra">
  <p><strong>Templatet piiloon script-elementin sisään!</strong></p>

  <p>Piilotimme templatet aiemmin <code>div</code>-elementin sisään siten, että <code>div</code>-elementille oli asetettu tyyli, joka piilottaa sen sisällön. Tyypillisempi lähestymistapa templatejen piilottamiseen liittyy selainten käyttäytymisen <code>script</code>-elementin kanssa hyödyntämiseen. Jos selain ei tunne <code>script</code>-elementille annettavaa tyyppiä, ei se myöskään yritä tulkata elementin sisältöä. Templaten voi asettaa myös <code>script</code>-elementin sisälle seuraavasti:</p>

<pre class="sh_html">
    &lt;script id="template" type="text/html"&gt;
        &lt;article&gt;
            {{#messages}}
                &lt;p&gt;&lt;strong&gt;{{nickname}}:&lt;/strong&gt; {{message}}&lt;/p&gt;
            {{/messages}}
       &lt;/article&gt;
    &lt;/script&gt;
</pre>

  <p>Tämä mahdollistaa myös paremman kuvaelementtien sisällyttämisen templateihin. Kun selain ei yritä tulkita templatea, se ei myöskään yritä hakea templatessa mahdollisesti olevaa kuvaviitettä.</p>
</div>


    <h4>Case: Henkilötiedot</h4>

    <p>Rakennetaan sovellus, jossa käyttäjä voi etsiä henkilöitä ja katsoa yksittäisen henkilön tietoja. Henkilöiden etsiminen tapahtuu kirjoittamalla tekstikenttään osa henkilön nimestä, tai henkilön nimi kokonaan. Henkilön nimeä kirjoitettaessa sovellus ehdottaa vaihtoehtoja. Kun oikea vaihtoehto löydetään, käyttäjä voi klikata nimeä ja katsoa henkilöön liittyviä tietoja.</p>

    <p>Käytössämme on seuraavanlainen datajoukko.</p>

<pre class="sh_javascript_dom">
var data = [{ "id": 1, "name": "homer", "age": 44 },
  { "id": 2, "name": "bart", "age": 12 },
  { "id": 3, "name": "maggie", "age": 4 },
  { "id": 4, "name": "lisa", "age": 10 },
  { "id": 5, "name": "marge", "age": 43 },
  { "id": 6, "name": "abraham", "age": 85 },
  { "id": 7, "name": "mona", "age": 81 },
  { "id": 8, "name": "amber", "age": 51 }]
</pre>

    <p><strong>Henkilöiden listaaminen</strong></p>

    <p>Jotta henkilöä voi etsiä, tulee sovelluksessa olla tekstikenttä nimen täyttämiseen, sekä alue henkilöiden näyttämiseen. Luodaan sovellukselle elementit etsimiseen ja tulosten listaamiseen.</p>

<pre class="sh_html">
  &lt;section&gt;
    &lt;input type="text" id="searchbox"/&gt;
  &lt;/section&gt;

  &lt;section id="resultview"&gt;&lt;/section&gt;
</pre>

    <p>Tunnuksella <code>searchbox</code> merkittyä elementtiä käytetään tekstin syöttämiseen, ja tunnuksella <code>resultview</code> merkittyä elementtiä tulosten näyttämiseen. Luodaan aivan ensin toiminnallisuus datajoukon näyttämiseen osana tuloslistaa. Käytetään tähän templatea.</p>

<pre class="sh_html">
  &lt;script id="searchresulttemplate" type="text/html"&gt;
    {{#list}}
    &lt;p&gt;{{name}}&lt;/p&gt;
    {{/list}}
  &lt;/script&gt;
</pre>

    <p>Yllä oleva template käy listan nimeltä <code>list</code> läpi siten, että se tulostaa jokaisen listalla olevan elementin attribuutin <code>name</code> <code>p</code>-elementin sisään. Käytännössä sille tulee siis antaa olio, jolla on attribuutti <code>list</code>, jotta se voi tulostaa alkiot.</p>

<pre class="sh_javascript_dom">
var data = [{ "id": 1, "name": "homer", "age": 44 },
  { "id": 2, "name": "bart", "age": 12 },
  { "id": 3, "name": "maggie", "age": 4 },
  { "id": 4, "name": "lisa", "age": 10 },
  { "id": 5, "name": "marge", "age": 43 },
  { "id": 6, "name": "abraham", "age": 85 },
  { "id": 7, "name": "mona", "age": 81 },
  { "id": 8, "name": "amber", "age": 51 }]

// huom! attribuutti list sisältää datan
var dataForTemplate = {
  list: data
}
</pre>

    <p>Luodaan toiminnallisuus, jonka avulla lista näytetään kun käyttäjä on kirjoittanut jotain tekstialueeseen. Käytetään tähän <code>keyup</code>-komentoa.</p>

<pre class="sh_javascript_dom">
$(document).ready(function() {
    $("#searchbox").keyup(function() {
      showdata();
    });
});
</pre>

    <p>Funktio <code>showdata</code> näyttää datan sivulla. Luodaan aivan ensiksi funktio, joka näyttää aina koko datan. Jotta datan renderöinti onnistuu aiemmin määrittelemämme templaten avulla, tulee data asettaa erillisen olion attribuutin list arvoksi.</p>

<pre class="sh_javascript_dom">
function showdata() {
  var dataForTemplate = {
    list: data
  }

  // renderöidään tulokset mustachen avulla
  var html = Mustache.render($("#searchresulttemplate").html(), dataForTemplate);
  // näytetään tulokset
  $("#resultview").html(html);
}
</pre>

    <p>Nyt sivumme näyttää tulokset.</p>

    <p><strong>Henkilöiden filtteröinti</strong></p>

    <p>Toteutetaan seuraavaksi henkilöiden filtteröinti. Filtteröinnin toteutus onnistuu helpohkosti käyttämällä edellä olevaa lähestymistapaa, ja muokkaamalla muuttujaa <code>dataForTemplate</code> JQueryn valmiin <code><a href="http://api.jquery.com/jQuery.grep/" target="_blank">grep</a></code>-komennon avulla. Komennolle grep annetaan parametrina funktio, joka saa grep-komennolta sille parametrina annetusta listasta aina yksittäisen alkion ja sen indeksin. Funktion tulee palauttaa arvo true tai false riippuen siitä halutaanko alkio säilyttää. Alla olevassa esimerkissä tarkistetaan onko parametrina saadun alkion attribuutti nimi "Mikke".</p>

<pre class="sh_javascript_dom">
data = $.grep(data, function(element, index) {
  return element.name === "Mikke";
});
</pre>

    <p>Omassa toteutuksessamme haluamme etsiä henkilöä, jonka nimessä on <code>searchbox</code>-elementissä oleva arvo. Koska käsittelemämme lista on muuttujan <code>dataForTemplate</code> attribuutti, annetaan grep-komennolla parametrina kyseinen attribuutti.</p>

<pre class="sh_javascript_dom">
function showdata() {
  var dataForTemplate = {
    list: data
  }

  // filtteröinti
  var mustContain = $("#searchbox").val();
  dataForTemplate.list = $.grep(dataForTemplate.list, function(person, index) {
    return person.name.indexOf(mustContain) != -1;
  });

  // renderöidään tulokset mustachen avulla
  var html = Mustache.render($("#searchresulttemplate").html(), dataForTemplate);
  // näytetään tulokset
  $("#resultview").html(html);
}
</pre>

<div class="extra">
  <p><strong>Cannot call method 'search' of undefined</strong></p>

  <p>Jos Mustache näyttää virheen "Uncaught TypeError: Cannot call method 'search' of undefined", tarkista aivan ensin että olet asettanut templatejen tunnukset oikein. Virhe "TypeError: this.tail.search is not a function" viittaa taas usein käytettävän templaten sisällön ja datan sisällön epäjohdonmukaisuuteen -- tarkista tässä myös että annat <em>oikeasti</em> html:ää Mustachelle..</p>

  <p>&nbsp;</p>
</div>
</section>
<section class="week">
  <header>
    <a name="viikko4"></a>
    <h1 data-week-id="4">Viikko 4</h1>
  </header>

  <h2>Sovelluksen rakenteen hallinta: AngularJS</h2>
  <p>Olemme tähän mennessä onnistuneesti pystyneet esittämään sovelluksemme dataa käyttöliittymässä ja jopa välittämään käyttöliittymästä tehtyjä muutoksia sovelluslogiikkaan. Mustache tekee datan esittämisestä näkymässä melko helppoa, mutta kuten olet ehkä huomannut, datan muokkaaminen näkymän kautta ei ole aivan niin helppoa. Ongelmat ilmenevät etenkin sovelluksen kasvaessa, jolloin sen rakenteesta tulee aina vain sekavampi. Rakennetta selkeyttää huomattavasti käyttöliittymän erottaminen sovelluksen datasta, johon jo mainittu MVC-arkkitehtuuri pyrkiikin. Selkeän MVC-arkkitehtuurin aikaansaaminen on kuitenkin yllättävän vaikeaa, jos työkalut eivät ole oikeat.</p>
  <p>
    Apuun tulee suuren suosion saavuttanut <a href="https://angularjs.org/" target="_blank">AngularJS</a> MVW-sovelluskehys. Edellisessä lauseessa ei ole kirjoitusvirhettä, Angularia ei voi rajata pelkäksi MVC-sovelluskehykseksi (vaikkakin niin usein tehdään), vaan tarkempi termi onkin "Model View Whatever". Se siis esittää mallia näkymässä ja välittää näkymässä tehtyjä muutoksia takaisin malliin. Mitä mallin ja näkymän rajapinnassa tapahtuu, on ohjelmoijan itsensä päätettävissä.
  </p>
  <p>
    Mikä Angularissa on hienoa, on se, että se tekee luonteeltaan staattisesta HTML:stä dynaamista, jolloin malli on sekä helppo esittää näkymässä, että helppo muokata näkymän kautta. Otetaan pieni esimerkki, joka havainnollistaa, kuinka paljon voimme saada aikaan kirjoittamatta riviäkään JavaScriptiä:
  </p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div ng-app&gt;
      &lt;h1&gt;Hello {{name}}!&lt;/h1&gt;
      &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Huomaat ensimmäiseksi, että Angularissa ja Mustachessa on sama syntaksi muuttujan upottamiseksi näkymään, eli <code>{{muuttuja}}</code>. Esimerkissä olemme upottaneet näkymäämme muuttujan <code>name</code>. Muuttuja ei ole vielä määritelty, joten näkymässä on pelkästään otsikko "Hello !". Otsikon alapuolella on tekstikenttä, jolle on määritelty attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngModel" target="_blank">ng-model</a></code>, jonka arvo on <code>name</code>. Tämä tarkoittaa sitä, että olemme sitoneet tekstikentän arvon muuttujaan <code>name</code>. Siis, jos muutamme tekstikentän arvoa, myös otsikon sisältö muuttuu. Tulemme myös myöhemmin huomaamaan, että jos muutamme muuttujan <code>name</code> arvoa sovelluslogiikassa, muuttuu myös tekstikentän arvo. Tämän yksinkertaiselta kuulostavan toiminnon toteuttaminen käyttämällä jQuerya ja Mustachea olisi helposti vienyt näin monta riviä koodia:
</p>
<pre class="sh_javascript_dom">
var name = "";

function renderHeading(){
  var html = Mustache.render('Hello {{name}}!', { name: name });
  $('h1').html(html);
}

$(document).ready(function(){
  renderHeading();

  $('input[type="text"]').on('keyup', function(){
    name = $(this).val();
    renderHeading();
  });
});
</pre>
<p>
  Kokeile Angularilla toteutetua esimerkkiä vielä itse:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10885/embedded/result,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h3>Kontrollerit</h3>
<p>
  Kuten on jo mainittu, kontrolleri on MVC-arkkitehtuurissa mallin ja näkymän yhdistävä tekijä. Se siis välittää esitettävän datan mallilta näkymälle ja muokkaa mallia näkymän pyynnöstä. Katsotaan, miten voimme liittää edelliseen esimerkkiimme kontrollerin käyttämällä Angularia:
</p>
<pre class="sh_javascript_dom">
function HelloController($scope){
  $scope.name = 'Kalle';
}
</pre>
<p>
  Se on siinä! Määrittelemme siis vain funktion nimeltä <code>HelloController</code>, jolla on yksi parametri. Parametrina saadun muuttujan <code>$scope</code> ("scope", suomeksi "näkyvyysalue") avulla toteuttamamme kontrolleri keskustelee näkymän kanssa. Se on objekti, johon voimme liittää kenttiä, joita voimme näyttää ja muokata näkymässä. Näkymään voi välittää sen kautta oikeastaan mitä vain, merkkijonoja, kokonaislukuja, objekteja tai jopa funktioita. Tässä esimerkissä välitämme näkymäämme vain muuttujan name, joka onnistuu lisäämälle <code>$scope</code>-objektiin kentän <code>name</code>.
</p>
<p>
  Jotta näkymä tietäisi, minkä kontrollerin kanssa se on vuorovaikutuksessa, täytyy näkymään määrittää kontrollerin näkyvyysalue lisäämällä johonkin HTML-tagiin attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngController" target="_blank">ng-controller</a>="HelloController"</code> ja se elementti lapsineen muodostaa kontrollerin näkyvyysalueen. Liitetään toteuttamamme <code>HelloController</code> näkymäämme:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app&gt;
    &lt;div ng-controller="HelloController"&gt;
      &lt;h1&gt;Hello {{name}}!&lt;/h1&gt;
      &lt;input type=&quot;text&quot; ng-model=&quot;name&quot;&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Nyt kontrollerimme näkyvyysalue on <code>div</code>-elementti, ja kaikki sen lapset. Näkymän otsikon sisältö ei ole enää pelkästään "Hello!", vaan muuttujalla <code>name</code> on asetettu kontrollerissa alkuarvo, "Kalle". Otsikon sisältö on siis "Hello Kalle!" ja lisäksi tekstikentän, jonka arvo on sidottu muuttujaan <code>name</code>, sisältö on "Kalle". On myös tärkeää lisätä <code><a href="https://docs.angularjs.org/api/ng/directive/ngApp" target="_blank">ng-app</a></code>-attribuutti johonkin DOM-elementtiin, joka sisältää kaikki elementit, jotka ovat kytköksissä Angulariin. Lisäsin sen tässä esimerkissä <code>body</code>-tagiin, mutta olisin voinyt lisätä sen yhtä hyvin <code>html</code>-tagiin.
</p>
<div class="tehtavat">
  <h3>My name is Bond, James Bond</h3>
  Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että näkymän otsikon sisältö määräytyy "etunimi" ja "sukunimi" tekstikenttien perusteella. Jos siis "etunimi"-kentän arvo on "Kalle" ja "sukunimi"-kentän arvo on "Ilves", on otsikon sisältö "My names is Ilves, Kalle Ilves". Otsikon alkuarvon tulee olla "My name is Bond, James Bond". Joudut tekemään muutoksia näkymän lisäksi <code>BondController</code>-kontrolleriin, joka sijaitsee tiedostossa <code>app/app.js</code>. 
</div>
<h3>Näkymät</h3>
<p>
  Angularissa jo pelkästään mallin esittäminen näkymässä on huomattavasti monipuolisempaa, kuin esimerkiksi Mustachen kanssa. Havainnollistetaan sitä tämän esimerkkikontrollerin avulla:
</p>
<pre class="sh_javascript_dom">
function ExampleController($scope){
  $scope.person = {
    name: 'Kalle',
    age: 22,
    happy: true,
    friends: ['Henri', 'Arto', 'Elina', 'Jorma']
  };
}
</pre>
<p>
  Määritin siis <code>ExampleController</code>-funktiossa <code>person</code>-objektin, jonka haluan välittää näkymälle.
</p>
<h4>Muuttujien upottaminen</h4>
<p>
  Toteutetaan seuraavaksi näkymä, joka esittää <code>person</code>-objektin kentät. Aloitetaan <code>name</code>- ja <code>age</code>-kenttien esittämisellä:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app&gt;
    &lt;div ng-controller="ExampleController"&gt;
      &lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymässä ei tapahtu mitään kovin kummallista, siihen upotetaan arvot <code>person.age</code> ja <code>person.name</code> syntaksilla <code>{{muuttujan}}</code>, joka on jo ennestään tuttu Mustachen kanssa. Näkymään ilmestyy siis otsikko, jonka sisältö on "Kalle, 22 vuotta vanha".
</p>
<h4>Ehtolauseet ja DOM-elementtien muokkaus ehtojen perusteella</h4>
<p>
  Lisätään seuraavaksi näkymään tieto henkilön mielentilasta:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy">:(&lt;/span&gt;
&lt;/p&gt;
</pre>
<p>
  Lisäämällä <code><a href="https://docs.angularjs.org/api/ng/directive/ngIf" target="_blank">ng-if</a></code>-attribuutin elementtiin, pystymme määrittämään ehdon sen esittämiselle. Ehto määräytyy <code>ng-if</code>-attribuutin arvon perusteella, jonka tulee olla jokin totuusarvo. Koska kontrollerissa on määritelty <code>person.happy = true</code>, toteutuu attribuutissa määritelty ehto, joten <code>span</code>-elementti sisältöineen on näkymässä.
</p>
<p>
  On lisäksi monia muita tapoja manipuloida DOM-elementtejä ehtojen perusteella. Voimme esimerkiksi lisätä <code>span</code>-elementtiin luokan <code>green</code>, jos ehto <code>person.happy</code> toteutuu. Vastaavasti, jos se ei toteudu, voimme lisätä siihen luokan <code>red</code>:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy" ng-class="{ 'green': person.happy }">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy" ng-class="{ 'red': person.happy }">:(&lt;/span&gt;
&lt;/p&gt;
</pre>
<p>
  <code><a href="https://docs.angularjs.org/api/ng/directive/ngClass" target="_blank">ng-class</a></code>-attribuutin sisältö on JSON-muodossa oleva merkkijono, jonka kenttinä on lisättävä luokka ja arvona ehto, joka kyseisen luokan lisäämiseen kuuluu. Samalla tavalla toimii mm. <code>ng-attr</code>, joka lisää DOM-elementtiin tietyn attribuutin, jos annettu ehto toteutuu.
</p>
<h4>Listojen läpikäynti</h4>
<p>Lopuksi täytyy vielä esittää lista henkilön ystävistä. Kuten Mustachessa, myös Angularissa on oma toistorakenteensa:
</p>
<pre class="sh_html">
&lt;h1&gt;{{person.name}}, {{person.age}} vuotta vanha&lt;/h1&gt;
&lt;p&gt;
  Fiilis on
  &lt;span ng-if="person.happy">:)&lt;/span&gt;
  &lt;span ng-if="!person.happy">:(&lt;/span&gt;
&lt;/p&gt;
&lt;ul ng-repeat="friend in person.friends"&gt;
  &lt;li&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Toisto siis onnistuu lisäämällä attribuutti <code><a href="https://docs.angularjs.org/api/ng/directive/ngRepeat" target="_blank">ng-repeat</a></code> elementtiin, jonka sisältöä halutaan toistaa. Attribuutin arvo on muotoa <code>iteroitavaAlkio in lista</code>. Toistojen määrää voi rajoittaa lisäämällä <code>ng-repeat</code>-attribuuttiin <code><a href="https://docs.angularjs.org/api/ng/filter/limitTo" target="_blank">limitTo</a></code> filtteri seuraavasti:
</p>
<pre class="sh_html">
&lt;ul ng-repeat="friend in person.friends | limitTo: 5"&gt;
  &lt;li&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Yllä olevassa esimerkissä tulostetaan vain viisi ensimmäistä kaveria, koska limitTo filtterille on annettu parametriksi kokonaisluku 5, joka kertoo rajan toistettaville alkioille. Toinen hyödillinen filtteri on <code><a href="https://docs.angularjs.org/api/ng/filter/orderBy" target="_blank">orderBy</a></code>, joka toistaa taulukon alkiot tietyssä järjestyksessä, esimerkiksi nimen perusteella: 
</p>
<pre class="sh_html">
&lt;ul ng-repeat="friend in person.friends | orderBy"&gt;
  &lt;li&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Koska taulukko sisältää merkkijonoja, ei <code>orderBy</code>-filtterille tarvitse antaa parametreja. Jos <code>friend</code>-muuttuja olisi ollut objekti, jolla on kenttä <code>name</code> olisi filtterin pitänyt olla <code>orderBy: friend.name</code>.
</p>
<p>
  Tustustutaan vielä lopuksi filtteriin <code><a href="https://docs.angularjs.org/api/ng/filter/filter" target="_blank">filter</a></code>, joka toistaa vain alkiot, jotka toteuttavat annetun ehdon, esimerkiksi sisältävät kirjaimen "a":
</p>
<pre class="sh_html">
&lt;ul ng-repeat="friend in person.friends | filter: 'a'"&gt;
  &lt;li&gt;{{friend}}&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  <code>filter</code>-filtterin parametri olisi yhtä hyvin voinut olla esimerkiksi muuttuja tai funktio.
</p>
<div class="tehtavat">
  <h3>Nättiä dataa</h3>
  Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että se listaa (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngRepeat" target="_blank">ng-repeat</a></code>) <code>index.html</code>-näkymässä <code>MovieController</code>-kontrollerissa (löytyy tiedostosta <code>app/app.js</code>) määritellyn taulukon <code>movies</code> elokuvat siten, että lista näyttää kutakuinkin tältä:
  <div>
    <p>
      <h3 class="ignore">
        <a href="http://www.imdb.com/title/tt0120737">The Lord of the Rings: The Fellowship of the Ring</a> (2001)
      </h3>
      <p>
        A meek hobbit of the Shire and eight companions set out on a journey to Mount Doom to destroy the One Ring and the dark lord Sauron.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Peter Jackson
      </p>
      <h4 class="ignore">Oscar awards (4)</h4>
      <p>
        <ul>
          <li>Best Cinematography</li>
          <li>Best Makeup</li>
          <li>Best Music, Original Score</li>
          <li>Best Effects, Visual Effects</li>
        </ul>
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Elijah Wood (Frodo)</li>
        <li>Sean Astin (Sam)</li>
        <li>Billy Boyd (Pippin)</li>
        <li>Dominic Monaghan (Merry)</li>
        <li>Viggo Mortensen (Aragorn)</li>
        <li>Orlando Bloom (Legolas)</li>
      </ul>
    </p>
    <p>
      <h3 class="ignore">
        <a href="http://www.imdb.com/title/tt0097523">Honey, I Shrunk the Kids</a> (1989)
      </h3>
      <p>
        The scientist father of a teenage girl and boy accidentally shrinks his and two other neighborhood teens to the size of insects. Now the teens must fight diminutive dangers as the father searches for them.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Joe Johnston
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Rick Moranis (Wayne Szalinski)</li>
        <li>Marcia Strassman (Diane Szalinski)</li>
        <li>Kristine Sutherland (Mae Thompson)</li>
      </ul>
    </p>
    <p>
      <h3 class="ignore"><a href="http://www.imdb.com/title/tt0096283">My Neighbor Totoro</a> (1988)</h3>
      <p>
        When two girls move to the country to be near their ailing mother, they have adventures with the wonderous forest spirits who live nearby.
      </p>
      <h4 class="ignore">Director</h4>
      <p>
        Hayao Miyazaki
      </p>
      <h4 class="ignore">Roles</h4>
      <ul>
        <li>Toshiyuki Amagasa (Kanta)</li>
        <li>Brianne Brozey (Michiko)</li>
        <li>Cheryl Chase (Mei)</li>
        <li>Dakota Fanning (Satsuki)</li>
      </ul>
    </p>
  </div>
  <p>
    Elokuvan otsikko sisältää sen nimen ja julkaisuvuoden. Elokuvan nimen tulee olla linkki sen sivulle <a href="http://www.imdb.com" target="_blank">IMDb</a>:ssä (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngHref" target="_blank">ng-href</a></code>). Oscar-palkinnot tulee näyttää vain, jos elokuvalla niitä on (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngIf" target="_blank">ng-if</a></code>). "Oscar awards" otsikon vieressä suluissa on Oscar-palkintojen lukumäärä. Elokuvan näyttelijät tulee listata (vinkki: </code>ng-repeat</code>) niin, että näyttelijän nimi on ensin ja sen jälkeen suluissa näyttelijän roolinimi elokuvassa. Järjestä elokuvien lista julkaisuvuoden perusteella (vinkki: <code><a href="https://docs.angularjs.org/api/ng/filter/orderBy" target="_blank">orderBy</a></code>), niin että uusin elokuva on listan kärjessä.
  </p>
  <ul> 
</div>
<h3>Mallin muokkaaminen näkymässä</h3>
<p>
  Pelkkä mallin esittäminen näkymässä ei riitä, jos sitä ei pysty myös muokkaamaan. Angularissa mallin pystyy helposti sitomaan lomakkeen elementteihin, kuten tekstikenttiin, radio-painikkeisiin ja checkboxeihin. Palataan takaisin <code>ExampleController</code>-kontrollerin pariin, jossa välitimme näkymään objektin <code>person</code>. Katsotaan, miten voimme muokata <code>person</code>-objektia näkymästämme käsin. Aloitetaan <code>name</code>-kentän muokkaamisella, jota haluan pystyä muokkaamaan tekstikentän avulla:
</p>
<pre class="sh_html">
&lt;label&gt;Nimi&lt;/label&gt;
&lt;input type="text" ng-model="person.name"&gt;
</pre>
<p>
  Riittää siis vain määrittää tekstikentän <code>ng-model</code> attribuuttiin muuttuja, jonka arvo halutaan sitoa sen arvoon. Nyt kun tekstikentän arvo muuttuu, muuttuu myös <code>person</code>-objektin <code>name</code> kentän arvo. 
</p>
<p>
  Totuusarvoa on kätevä muuttaa näkymissä sitomalla sen arvo checkboxin arvoon. Voimme siis helposti muuttaa <code>person</code>-objektin <code>happy</code>-kentän arvoa seuraavasti:
</p>
<pre class="sh_html">
&lt;label&gt;Iloinen?&lt;/label&gt;
&lt;input type="checkbox" ng-model="person.happy"&gt;
</pre>
<p>
  Angularissa pystyt sitomaan muuttujan arvon lähes jokaiseen eri lomakkeen elementtiin lisäämällä sille <code>ng-model</code>-attribuutin, jonka arvona on sidotun muuttujan nimi.
</p>
<p>
  <code>ng-model</code>-attribuutissa määritellyissä muuttujissa on käytössä nk. "two way data binding", jolloin mallin muuttaminen kontrollerissa aiheuttaa näkymän päivityksen ja samoin mallin muuttaminen näkymässä aiheuttaa siihen muutoksen kontrollerissa.  
</p>
<div class="tehtavat">
  <h3>Elokuvafiltteri</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että <code>index.html</code>-näkymässä muodostettua elokuvien listaa pystyy filtteröimään nimen, julkaisuvuoden ja ohjaajan perusteella käyttämällä näkymässä olevia kenttiä. Jos siis käyttäjä syöttää esimerkiksi "nimi"-kenttään arvon "The Lord" ja "ohjaaja"-kenttään arvon "Peter", tulee näkymässä listata vain elokuvat, joiden nimestä löytyy sana "The Lord" ja ohjaajan nimestä löytyy sana "Peter". <a href="https://docs.angularjs.org/api/ng/filter/filter" target="_blank">Filtteröintiin</a> tutustumisesta on tehtävässä paljon apua. Taulukko <code>movies</code> löytyy kontrollerista <code>MovieController</code> (joka löytyy tiedostosta <code>app/app.js</code>). Älä tee muutoksia <code>movies</code>-taulukkoon, mutta muuten voit tehdä kontrolleriin haluamiasi muutoksia.
  </p>
</div>
<h4>Lomakkeiden validointi</h4>
<p>
  Katsotaan seuraavaksi hieman, kuina pystymme validoimaan käyttäjän syötteitä Angularin avulla. Otetaan esimerkiksi tämä lomake, joka sisältää kentät henkilötiedoille:
</p>
<pre class="sh_html">
&lt;form name="infoForm"&gt;
  &lt;p&gt;
    &lt;label&gt;Etunimi&lt;/label&gt;
    &lt;input name="firstName" type="text" ng-model="firstName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Sukunimi&lt;/label&gt;
    &lt;input name="lastName" type="text" ng-model="lastName"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Puhelinnumero&lt;/label&gt;
    &lt;input name="phoneNumber" type="text" ng-model="phoneNumber"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;label&gt;Sähköpostiosoite&lt;/label&gt;
    &lt;input name="emailAddress" type="text" ng-model="emailAddress"&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;input type="submit" value="Lähetä"&gt;
  &lt;/p&gt;
&lt;/form&gt;
</pre>
<p>
  Haluasin, että yllä oleva lomake validoitaisiin seuraavasti:
  <ul>
    <li>Etunimi, eikä sukunimi saa olla tyhjä ja molempien pituuden tulee olla vähintään kaksi merkkiä</li>
    <li>Puhelinnumeron pitää koostua numeroista ja olla vähintään yhdeksän merkkiä pitkä</li>
    <li>Sähköpostiosoitteen pitää olla muotoa jotain@jotain.jotain</li>
  </ul>
</p>
<p>
  Huh, kuulostaa aikamoiselta urakalta! Onneksi se ei Angularin kanssa ole. Aloitetaan etunimen ja sukunimen validoinnista. Jos kentät eivät ole valideja, lisätään niiden alapuolelle virheilmoitukset:
</p>
<pre class="sh_html">
&lt;p&gt;
  &lt;label&gt;Etunimi&lt;/label&gt;
  &lt;input name="firstName" type="text" ng-model="firstName" required ng-minlength="2"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Sukunimi&lt;/label&gt;
  &lt;input name="lastName" type="text" ng-model="lastName" required ng-minlength="2"&gt;
&lt;/p&gt;
</pre>
<p>
  Kenttien validointi tapahtuu lisäämälle niihin validointiin liittyviä attribuutteja. Molempiin tekstikenttiin on lisätty attribuutti <code>required</code>, joka kertoo, että kentässä tulee olla sisältöä. Lisäksi molemmissa on attribuutti <code>ng-minlength</code>, jonka arvo on <code>2</code>. Se kertoo, että kentän pituuden tulee olla vähintään kaksi merkkiä.
</p>
<p>
  Puhelinnumeron ja sähköpostiosoitteen kentät ovat hieman hankalampia, niissä pitää käyttää säännöllistälauseketta. Ei hätää, voimme määrittää niille attribuutin <code>ng-pattern</code>, jonka arvoksi määritämme haluamamme säännöllisenlausekkeen:
</p>
<pre class="sh_html">
&lt;p&gt;
  &lt;label&gt;Etunimi&lt;/label&gt;
  &lt;input name="firstName" type="text" ng-model="firstName" ng-pattern="/^[0-9]{9,}$/"&gt;
&lt;/p&gt;
&lt;p&gt;
  &lt;label&gt;Sukunimi&lt;/label&gt;
  &lt;input name="lastName" type="text" ng-model="lastName" ng-pattern="/^.+@.+\..+$/"&gt;
&lt;/p&gt;
</pre>
<p>
  Nyt puhelinnumerossa täytyy olla vähintään yhdeksän numeroa ja sähköpostiosoite on muotoa jotain@jotain.jotain. Huomaa, että säännöllinen lauseke, tulee sijoittaa merkkien <code>/^</code> ja <code>$/</code> väliin.
</p>
<p>
  Seuraavaksi käyttäjälle pitäisi näyttää virheilmoitukset, jos hän on täyttänyt lomakkeet väärin. Lisätään jokaisen kentän alle virheilmoitus, jos se ei ole validi:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;form name="infoForm"&gt;
    &lt;p&gt;
      &lt;label&gt;Etunimi&lt;/label&gt;
      &lt;input name="firstName" type="text" ng-model="firstName" required ng-minlength="2"&gt;
      &lt;div ng-show="infoForm.firstName.$invalid && infoForm.firstName.$dirty"&gt;
        Etunimi ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Sukunimi&lt;/label&gt;
      &lt;input name="lastName" type="text" ng-model="lastName" required ng-minlength="2"&gt;
      &lt;div ng-show="infoForm.lastName.$invalid && infoForm.lastName.$dirty"&gt;
        Sukunimi ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Puhelinnumero&lt;/label&gt;
      &lt;input name="phoneNumber" type="text" ng-model="phoneNumber" required ng-pattern="/^[0-9]{9,}$/"&gt;
      &lt;div ng-show="infoForm.phoneNumber.$invalid && infoForm.phoneNumber.$dirty"&gt;
        Puhelinnumero ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;label&gt;Sähköpostiosoite&lt;/label&gt;
      &lt;input name="emailAddress" type="text" ng-model="emailAddress" required ng-pattern="/^.+@.+\..+$/"&gt;
      &lt;div ng-show="infoForm.emailAddress.$invalid && infoForm.emailAddress.$dirty"&gt;
        Sähköpostiosoite ei ole validi!
      &lt;/div&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;input type="submit" value="Lähetä" ng-disabled="infoForm.$invalid"&gt;
    &lt;/p&gt;
  &lt;/form&gt;
&lt;/div&gt;
</pre>
<p>
  Jokaiseen kenttään on lisätty virheilmoitus, joka näytetään, jos kenttä ei ole validi ja sitä on muokattu. Kentän oikeellisuuden pystyy tarkastamaan arvosta lomakkeenName.kentanName.$invalid, jossa <code>lomakkeenName</code> on <code>form</code>-elementin <code>name</code>-attribuutin arvo, jonka sisällä kenttä sijaitsee ja <code>kentanName</code> kyseisen kentän <code>name</code>-attribuutin arvo. Esimerkiksi <code>infoForm.firstName.$invalid</code> on <code>false</code>, jos etunimen kenttä on validi ja <code>true</code>, jos se ei ole validi. Voimme tarkistaa onko koko lomake validi arvosta <code>lomakkeenName.$invalid</code>. Lisäksi voimme tarkistaa onko kenttä validi yksittäinen validaattorin perusteella, esimerkiksi <code>required</code>-validaattorin perusteella, syntaksilla <code>lomakkeenName.kentanName.$error.required</code> (<code>true</code>, jos kenttä ei ole validi <code>require</code>-validaattorin perusteella). Esimerkissä otin "Lähetä"-painikkeen pois käytöstä, jos lomake ei ole validi. Arvo <code>lomakkeenName.kentanName.$dirty</code> taas kertoo, onko kentän arvoa muutettu. Se on lisätty ehtoon, koska emme halua näyttää virheilmoituksia ennen kuin käyttäjä on ehtinyt syöttää mitään kenttään.
</p>
<p>
  Lisää lomakkeista ja niiden validoinnista voit lukea <a href="https://docs.angularjs.org/guide/forms" target="_blank">täältä</a>.
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10936/embedded/result,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>Validi sen olla pitää!</h3>
  <p>Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että siinä oleva lomake validoidaan. Lomake on validi, jos seuraavat ehdot ovat voimassa:
  <ul>
    <li>
      Käyttäjätunnus on vähintään kolme merkkiä pitkä.
    </li>
    <li>
      Käyttäjän salasanan pituus on vähintään kahdeksan merkkiä ja sisältää vähintään yhden numero ja ison kirjaimen.
    </li>
    <li>
      Käyttäjän antama salasana ja sen vahvistus vastaavat toisiaan. Käytetään tähän Angulariin toteutettua direktiiviä, jonka käyttöön löydät ohjeet <a href="https://github.com/TheSharpieOne/angular-input-match#usage" target="_blank">täältä</a>. Asennus on jo tehty, tutustu vain lyhyesti käyttöohjeisiin.
    </li>
    <li>
      Sekä etu-, että sukunimi on pituudeltaan vähintään kaksi merkkiä ja koostuvat pelkistä kirjaimista.
    </li>
    <li>Henkilötunnus on <a href="http://fi.wikipedia.org/wiki/Henkil%C3%B6tunnus#Tunnuksen_muoto" target="_blank">täällä</a> määriteltyä mutoa.</li>
    <li>
      Käyttäjä on hyväksynyt käyttöehdot (checkboxi on valittu).
    </li>
  </ul>
</p>
  Poista lomakkeen lähetyspainike käytöstä, kunnes lomake on validi (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngDisabled" target="_blank">ng-disabled</a></code>). Näytä lisäksi kenttiin kohdistuvat virheilmoitukset, jos niille on tarvetta, kunhan käyttäjä on ehtinyt syöttää kenttään arvon. Yksittäisen validaattorin virheitä ei tarvitse, näyttää, riittää ilmoittaa, jos kenttä ei ole validi jonkin validaattorin perusteella. Muista sitoa jokainen kenttä jonkin muuttujan arvoon <code>ng-model</code>-attribuutin avulla, muuten validointi ei toimi.
</p>
</div>
<h3>Tapahtumat</h3>
</p>
  Puhutaan seuraavaksi hieman siitä, kuinka voimme sitoa tapahtumia näkymäämme. Puhuimme jo siitä, että näkymään voi välittää <code>$scope</code>-parametrin kautta myös funktioita. Kuulostaa siltä, että voisimme siis kutsua kontrollerissa määriteltyä funktiota näkymästä käsin.
</p>
<p>
  Olemme tottuneet jQueryssa siihen, että tapahtumat sidotaan johonkin valitsimeen, esimerkiksi id:llä <code>nappula</code> varustettuun painikkeeseen sidottaisiin <code>click</code>, eli hiirenpainallus elementin päällä seuraavasti:
</p> 
<pre class="sh_javascript_dom">
$('#nappula').on('click', function(){
  alert('Painoit nappulaa!');
});
</pre>
<p>
  Tapahtumat sidotaan siis jQueryssa käyttöliittymälogiikan puolella. Tässä tavassa ei periaatteessa ole mitään vikaa, mutta kun tapahtumien määrä kasvaa, täyttyy käyttöliittymälogiikka oudoista valitsimista ja kukaan ei enää muista, mihin näkymän elementtiin kukin valitsin liittyi.
</p>
<p>
  Angular lähestyy tapahtumien sitomista elementteihin toisesta näkökulmasta sitomalla tapahtumat näkymässä suoraan DOM-elementtiin valitsimen sijaan. Tapa muistuttaa hieman kurssin alkupuolella esitettyä tapaa sitoa tapahtumia DOM-elementteihin. Äskeinen jQuery esimerkki voidaan toteuttaa Angularilla seuraavasti: 
</p>
<pre class="sh_html">
&lt;div ng-controller="NotificationController"&gt;
  &lt;button ng-click="notify('Painoit nappulaa!')" id="nappula"&gt;Paina nappulaa!&lt;/button&gt;
&lt;/div&gt;
</pre>
<p>
  Sidoimme siis <code>button</code>-elementtiin <code>click</code>-tapahtuman asettamalla sille <code>ng-click</code>-attribuutin, jonka arvona on funktionkutsu. Eri tapahtumia on lukuisia ja yleensä ne muistuttavat nimissään jQueryn tapahtumia, esimerkiksi <code>ng-mousemove</code>, <code>ng-keyup</code> ja <code>ng-focus</code>.
  Nyt koodin ulkopuolinen katselijakin näkee helposti, mitä tapahtumia mihinkin DOM-elementtiin on sidottu ilman, että hänen täytyy tulkita valitsimia. Yllä oleva koodi ei tosin itsessään tee vielä mitään, koska funktiota <code>notify</code> ei ole määritelty. Toteutetaan siis kontrolleri, josta kyseinen funktio löytyy: 
</p>
<pre class="sh_javascript_dom">
function NotificationController($scope){
  $scope.notify = function(notification){
    alert(notification);
  }
}
</pre>
<p>
  Kuten jo puhuimme, näkymään voi välittää myös funktion, jonka nyt teimme lisäämällä <code>$scope</code>-objektiin kentän <code>notify</code>, jonka arvona on funktio.
</p>
<p>
  Palataan hetkeksi <code>ExampleController</code>-funktion pariin, jonka kanssa töyskentelimme vähän aikaa sitten. Toteutetaan siihen toiminto, jonka avulla henkilön ystäviä voi lisätä ja poistaa:
</p>
<pre class="sh_javascript_dom">
function ExampleController($scope){
  $scope.person = {
    name: 'Kalle',
    age: 22,
    happy: true,
    friends: ['Henri', 'Arto', 'Elina', 'Jorma']
  };

  $scope.addFriend = function(){
    $scope.person.friends.push($scope.newFriend);
  }

  $scope.removeFriend = function(index){
    $scope.person.friends.splice(index, 1);
  }
}
</pre>
<p>
  Ennen kuin etenemme pidemmälle, katsotaan, mitä muutoksia teimme. Lisäsimme siis funktiot <code>addFriend</code> ja <code>removeFriend</code> parametrin <code>$scope</code> kentiksi, jolloin ne ovat käytettävissä näkymässä. Funktio <code>addFriend</code> lisää ystävät sisältävään taulukkoon uuden ystävän. Emme ole vielä määritelleet muuttujaa <code>newFriend</code>, mutta tulemme tekemään sen pian näkymässämme. Toteutimme myös funktion <code>removeFriend</code>, joka poistaa ystävän taulukon tietystä indeksistä käyttäen <code>splice</code>-funktiota, joka poistaa taulukosta tietyn määrän alkioita alkaen tietystä indeksistä (järjestys on <code>splice(indeksi, lukumäärä)</code>).
</p>
<p>
  Nyt kaikki kontrollerissa tehdyt muutokset on käyty läpi, joten siirrytäänpä näkymän pariin. Aloitetaan lisäystoiminnosta. Tarvitsemme tekstikentän, johon käyttäjä voi lisätä uuden ystävän nimen ja painikkeen, jota painamalla ystävä lisätään:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;div ng-controller="ExampleController"&gt;
    &lt;input type="text" ng-model="newFriend"&gt;
    &lt;button ng-click="addFriend()"&gt;Lisää ystävä&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Sidoimme muuttujan <code>newFriend</code> arvon tekstikenttään, jolloin sen arvo välittyy muuttujaamme. Lisäksi sidoimme painikkeeseen hiirenpainallustapahtuman, jonka seurauksena kutsutaan funktiota <code>addFriend</code>.
</p>
<p>
  Seuraavaksi haluamme toteuttaa toiminnon ystävän poistamiselle. Olemme jo toteuttaneet näkymään ystävien listaamisen, lisätään vain jokaisen ystävän kohdalle painike sen poistamiseksi:
</p>
<pre class="sh_html">
&lt;div ng-app&gt;
  &lt;div ng-controller="ExampleController"&gt;
    &lt;ul ng-repeat="friend in person.friends"&gt;
      &lt;li&gt;{{friend}} &lt;button ng-click="removeFriend($index)"&gt;Poista&lt;/button&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;input type="text" ng-model="newFriend"&gt;
    &lt;button ng-click="addFriend()"&gt;Lisää ystävä&lt;/button&gt;
  &lt;/div&gt;
&lt;/div&gt;
</pre>
<p>
  Toteutimme <code>removeFriend</code>-funktion niin, että se poistaa ystävän taulukon tietystä indeksistä. Se tehtiin siksi, että <code>ng-repeat</code>-toistorakenteessa iteroitavan alkion indeksi on helppo saada muuttujasta <code>$index</code>. Funktion olisi voinut myös toteuttaa niin, että se poistaa ystävän tietyllä nimellä käyttäen jQueryn <code>$.grep</code>-funktiota siten, että se valitsee vain ystävät, joilla ei ole parametrina annettua nimeä. Tällöin taulukossa ei tosin olisi voinut olla saman nimisiä ystäviä.
</p>
<p>
  Tämä pieni sovellus alkaa olla paketissa, katsotaan vielä, mitä olemme saaneet aikaan:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/10905/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>Laskin</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että käyttäjä voi laskea kerto-, plus-, erotus- ja jakolaskuja syöttämällä haluamansa luvut kahteen kenttään ja painamalla jotain neljästä painikkeesta, jolloin valittu laskuoperaatio suoritetaan luvuille ja tulos näytetään käyttäjälle kenttien yläpuolella. Jos käyttäjä yrittää jakaa lukua nollalla, ota jakolaskupainike pois käytöstä (vinkki: <code>ng-disabled</code>). Toteuta laskin tekemällä tarvittavat muutokset <code>CalculatorController</code>-kontrolleriin (löytyy tiedostosta <code>app/app.js</code>) ja <code>index.html</code>-näkymään.
  </p>
</div>
<h4>Mallin tarkkailu</h4>
<p>
  Tulee usein tilanne, jossa haluamme tarkkailla muutosta mallissa. Esimerkiksi, jos henkilön nimeä muuttaa, hänen ystävän poistetaan, koska henkilö ei ole enää sama kuin ennen, joten hänellä ei ole myöskään samoja ystäviä.
</p>
<p>
  Toteutetaan kuitenkin hieman yksinkertaisempi esimerkki, jossa käyttäjä syöttää nimensä tekstikenttään ja jos sen arvo on "James Bond", näytetään alert-ikkuna "I've been expecting you, mr. Bond". Aloitetaan luomalla luomalla näkymä, joka sisältyy <code>BondController</code>-kontrollerin näkyvyysalueeseen:
</p>
<pre class="sh_html">
&lt;div ng-controller="BondController"&gt;
  &lt;h1&gt;My name is {{name}}&lt;/h1&gt;
  &lt;input type="text" ng-model="name"&gt;
&lt;/div&gt;
</pre>
<p>
  Se on siinä! Sidoimme vain <code>name</code>-muuttujan arvon tekstikentän arvoon ja lisäsimme otsikon, joka esittää <code>name</code>-muuttujan arvon. Seuraavaksi toteutetaan funktio <code>BondController</code>, jossa itse magia tapahtuu:
</p>
<pre class="sh_javascript_dom">
function BondController($scope){
  $scope.name = "Kalle";

  $scope.$watch('name', function(newValue, oldValue){
    if(newValue == 'James Bond'){
      alert('I\'ve been expecting you, mr. Bond');
    }
  });
}
</pre>
<p>
  Lisäämme objektiin <code>$scope</code> tarkkailijan, joka tarkkailee <code><a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch" target="_blank">$watch</a></code>-funktion ensimmäisenä saatua parametria. Parametri annetaan merkkijonona, joka vastaa tarkkailtavan muuttujan nimeä. Kun muuttujan arvo vaihtuu, kutsutaan toisena parametrina annettua anonyymiä-funktiota, joka saa parametreikseen muuttujan uuden ja vanhan arvon. Funktion sisällä voimme tarkkailla muuttujan uutta arvoa ja tehdä jotain sen perusteella. Tarkkailtavan muuttujan ei tarvitse olla merkkijono, se voi olla myös mm. objekti tai taulukko. Kannattaa kuitenkin olla tarkkana, sillä Angular ei välttämättä ole kanssasi samaa mieltä siitä, onko muuttujan arvo muuttunut. Angular tarkastaa oletusarvoisesti, onko muuttujan viite muuttunut, jolloin objektien kanssa tulee ongelmia. Ongelma ratkeaa lisäämällä <code>$watch</code>-funktioon kolmas parametri, jonka arvo on <code>true</code>. Tällöin Angular vertaa muuttujan sisältöä viitteen sijaan. 
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="https://jsfiddle.net/HB7LU/10890/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h3>Riippuvuuksien injektointi</h3>
<p>
  Riippuvuuksien injektointi (<a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a>) on suosittu suunnittelumalli sovelluskehityksessä, johon myös Angular hyvin vahvasti nojautuu. Dependency Injection suunnittelumallin suosio perustuu siihen, että se vähentää sovelluksen sisäisiä riippuvuuksia (tekee "<a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsible Principle</a>"-periaatteen noudattamisesta helpompaa) ja tekee koodista uudelleenkäytettävämpää sekä helpommin testattavaa. 
</p>
<p>
  Katsotaan, miten riippuvuuksien injektointi on toteutettu Angularissa. Tähän mennessä olemme määritelleet kontrollerimme tähän tapaan:
</p>
<pre class="sh_javascript_dom">
function MyController($scope){
  $scope.message = 'Hello World!';
}
</pre>
<p>
  Tavassa ei periaatteessa ole mitään vikaa, mutta tulevaisuudessamme haluamme käyttää muita komponentteja kontrollereissamme, jolloin meidän täytyy injektoida ne kontrolleriimme. Jotta riippuvuuksien injektointi olisi helpompaa, määrittelemme kontrollerimme tulevaisuudessa seuraavanlaisesti:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', []);

App.controller('MyController', function($scope){
  $scope.message = 'Hello World!';
});
</pre>
<p>
  Toteutimme siis moduulin nimeltä <code>MyApp</code> ja sille kontrollerin <code>MyController</code>, johon injektoin muuttujan <code>$scope</code>. Huomaa, että tyhjä taulukko <code>angular.module</code>-kutsun toisena parametrina tarkoittaa sitä, etten injektoi moduuliini toisia moduuleja. Tulemme kuitenkin tekemään niin tulevaisuudessa. Moduuli on Angularissa pelkästään laatikko, joka sisältää sovelluksemme konponentit, kuten kontrollerit. Se on siis tapa organisoida sovelluksen eri osia. Moduulin käyttö lähtee liikkeelle näkymästä, jossa se otetaan käyttöön lisäämällä se <code>ng-app</code>-attribuutin arvoksi:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Ei siis sen kummempaa. Tehdään hommasta hieman jännittävämpää ja injektoidaan <code>MyController</code>-kontrolleriin <code>$scope</code>-muuttujan lisäksi funktio <code>$interval</code>, joka kutsuu parametrina saatua funktiota tietyn aikajakson välein:
</p>
<pre class="sh_javascript_dom">
App.controller('MyController', function($scope, $interval){
  $scope.message = 60;

  $interval(function(){
    $scope.message--;
  }, 1000);
});
</pre>
<p>
  Käytän injektoitua <code>$interval</code>-funktiota vähentääkseni muuttujan <code>message</code> arvoa joka sekuntti (sekuntti on 1000 millisekunttia).
</p>
<div class="tehtavat">
  <h3>Pikakirjoitus</h3>
  <p>
    Muokkaa tehtäväpohjassa olevaa dokumenttia siten, että käyttäjä voi testata pikakirjoitustaitojaan. Pikakirjoituspelin tulee toimia niin, että käyttäjä näkee sivulla pitkän "Lorem ipsum dolor sit amet..."-tekstin, jonka sisältö löytyy muuttujasta <code>text</code>. Kun käyttäjä painaa "Aloita!"-painiketta, hänen täytyy alkaa kirjoittamaan näkeemäänsä tekstiä tekstikenttään niin nopeasti kuin mahdollista. Käyttäjällä on aikaa kirjoittaa tekstiä 15 sekunttia. Varmista, ettei käyttäjä tee kirjoitusvirhettä niin, ettet hyväksy tekstikenttään virheellisiä merkkejä. Samaan aikaan, kun käyttäjä kirjoittaa, sivulla näkyvän laskurin arvo vähenee joka sekuntti. Kun laskurin arvo on 0, tulee käyttäjälle ilmoittaa alert-ikkunan kautta, kuinka monta merkkiä hän onnistui kirjoittamaan. Pelin uudelleen aloittamiseksi riittää, että käyttäjä päivittää sivun, mutta voit halutessasi alustaa pelin uudelleen, kun laskurin arvo on 0.
  </p>
  <p>
    Toteuta pikakirjoituspeli käyttämällä <code>$watch</code>-funktiota tarkkailemaan esimerkiksi <code>timeLeft</code> (kuinka paljon laskurissa on aikaa) ja <code>userText</code> nimisten muuttujien (käyttäjän kirjoittama teksti) arvoja. Kun <code>timeLeft</code> muuttujan arvo on 0, ilmoita käyttäjälle, kuinka monta merkkiä hän onnistui kirjoittamaan oikein (esim. "Onnistuit kirjoittamaan 30 merkkiä!"). Tarkkaile <code>userText</code>-muuttuja kirjoitusvirheiden varalta esimerkiksi seuraavasti: 
<pre class="sh_javascript_dom">
var lastChar = newVal.charAt(newVal.length - 1);

if(lastChar != $scope.text.charAt(newVal.length - 1)){
  $scope.userText = $scope.userText.slice(0,-1);
}
</pre>
  </p>
  <p>
    Pelin aloittaa "Aloita!"-painikkeen klikkaaminen. Aloita siis laskurin vähentäminen siitä hetkestä käyttämällä <code><a href="https://docs.angularjs.org/api/ng/service/$interval" target="_blank">$interval</a></code>-funktiota. <code>TypeController</code>-kontrollerin pohja löytyy tiedostosta <code>app/app.js</code> ja näkymä tiedostosta <code>index.html</code>.
  </p>
  <h3>TodoApp (3p)</h3>
  Seuraavaksi pääset toteuttamaan hieman suurempaa sovellusta, muistilistaa. Muistilistan avulla käyttäjä voi lisätä itselleen tehtäviä, jotka hän itse priorisoi. Lisätyn tehtävän voi merkata tehdyiksi, poistaa ja sen prioriteettia voi muuttaa. Tehtävät tulee järjestää muistilistaan niiden prioriteetin mukaan. Lopullinen muistilista muistuttaa tätä (pelkkä käyttöliittymä, toiminallisuus puuttuu):
  <p>
  <style>
    #todo-container{
      border: 1px solid rgb(220,220,220);
      font: 13px arial;
    }
    #add-todo-container{
      padding: 10px;
    }
    #add-todo-container input[type="text"]{
      padding: 10px;
      width: 400px;
      border: 1px solid rgb(220,220,220);
    }
    #mark-todos-done{
      background-color: #00C000 !important;
      border: 1px solid #00C000 !important;
    }
    #remove-todos{
      background-color: #C63717 !important;
      border: 1px solid #C63717 !important;
    }
    #todo-footer{
      border-top: 1px solid rgb(220,220,220);
      padding: 10px;
    }
    #add-todo-container button{
      padding: 10px 14px;
      border: 1px solid black;
      background-color: black;
      color: white;
    }
    .todo{
      border-top: 1px solid rgb(220,220,220); 
      padding: 10px; 
      overflow: hidden;
    }
    .todo .todo-priority{
      padding: 10px 10px;
      display: inline-block;
      width: 40px;
      text-align: center;
      border: 1px solid white;
    }
    .todo .todo-priority:hover, .todo-priority:focus{
      border: 1px solid rgb(220,220,220);
    }
    .todo .todo-done{
      text-decoration: line-through;
    }
    .todo .remove-todo{
      background-color: #C63717;
      border: 1px solid #C63717;
      color: white;
      padding: 10px 14px;
      float: right;
    }
  </style>
      <h1 class="ignore">Muistilista</h1>
      <div id="todo-container">
        <div id="add-todo-container">
          <input type="text" placeholder="Uusi tehtävä">
          <button>Lisää tehtävä</button>
          <button id="mark-todos-done">Merkkaa kaikki tehdyiksi</button>
          <button id="remove-todos">Poista kaikki</button>
        </div>

        <div class="todo">
          <input type="text" value="1" class="todo-priority">
          <label>
            <input type="checkbox" checked> <span class="todo-done">Kirjoita Angular-materiaalia</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div class="todo">
          <input type="text" value="2" class="todo-priority">
          <label>
            <input type="checkbox"> <span>Ruoki koira</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div class="todo">
          <input type="text" value="3" class="todo-priority">
          <label>
            <input type="checkbox"> <span>Käy kaupassa</span>
          </label>
          <button class="remove-todo">Poista</button>
        </div>

        <div id="todo-footer">
          1 tehtävä tehty, 2 tehtävää jäljellä
        </div>
      </div>
  </p>
  <p>
    Toteuta valmiiseen käyttöliittymään seuraavat toiminnot:
    <ul>
      <li>Käyttäjä voi lisätä tehtävän listaan "Uusi tehtävä"-tekstikentän nimen perusteella. Älä anna käyttäjän lisätä tehtävää tyhjällä nimellä.</li>
      <li>Käyttäjä voi merkata merkata tehtävän tehdyksi klikkaamalla checkboxia. Tehdyn tehtävän nimi vedetään yli (voit lisätä tehtävän nimeen tällöin luokan <code>todo-done</code> (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngClass" target="_blank">ng-class</a></code>).</li>
      <li>
        Käyttäjä voi merkata kaikki tehtävät tehdyksi klikkaamalla "Merkkaa kaikki tehdyiksi"-painiketta.
      </li>
      <li>
        Käyttäjä voi poistaa tehtävän listasta painamalla oikeasta laidasta "Poista"-painiketta.
      </li>
      <li>
        Käyttäjä voi poistaa kaikki tehtävät klikkaamalla "Poista kaikki"-painiketta. Varmista painikkeen klikkaamisen jälkeen, että käyttäjä haluaa varmasti poistaa kaikki tehtävät (vinkki: <code><a href="http://www.w3schools.com/jsref/met_win_confirm.asp" target="_blank">confirm</a></code>). 
      </li>
      <li>
        Tehtävään liittyy prioriteetti. Jokaiselle tehtävälle lisätään sen lisäämisen yhteydessä prioriteetti <code>1</code>. Sitä pienempi prioriteetti on, sitä tärkeämpi tehtävä on. Käyttäjä voi muokata tehtävän prioriteettia vaihtamalla sen vieressä olevan tekstikentän arvoa. Järjestä tehtävät prioriteetin mukaan niin, että tärkeimmät tehtävät ovat listan yläpäässä (vinkki: liitä prioriteetin sisältävään tekstikenttään <code><a href="https://docs.angularjs.org/api/ng/directive/ngBlur" target="_blank">ng-blur</a></code>-kuuntelija ja järjestä tehtävien taulukko prioriteetin mukaan, kun kenttä menettää fokuksen käyttämällä <code><a href="http://www.w3schools.com/jsref/jsref_sort.asp" target="_blank">sort</a></code>-funktiota).
      </li>
      <li>
        Käyttäjä voi nähdä muistilistan alalaidasta, kuinka monta tehtävää hän on tehnyt ja kuinka monta on vielä tekemättä. Käytä selkeää suomen kieltä, jolloin "1 tehtävä tehty" on oikein ja "1 tehtävää tehty" on väärin (vinkki: <code><a href="https://docs.angularjs.org/api/ng/directive/ngPluralize" target="_blank">ng-pluralize</a></code>). Voit toteuttaa toiminnon käyttämällä <code><a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch" target="_blank">$watch</a></code>-funktiota niin, että seuraat tehtävät sisältävää taulukkoa ja päivittää esimerkiksi muuttujien <code>todosDone</code> ja <code>todosRemaining</code> arvot aina, kun taulukossa tapahtuu muutoksia. <strong>Muista lisätä <code>$watch</code>-funktiokutsun viimeiseksi parametriksi <code>true</code>, niin Angular tarkastaa onko taulukossa tapahtunut muutoksia sen sisällön, eikä pelkän viitteen perusteella</strong>. 
      </li>
    </ul>
    <p>
      <code>TodoController</code>-kontrollerin valmis pohja löytyy tiedostosta <code>app/controllers/todo_controller.js</code> ja näkymä tiedostosta <code>index.html</code>.
    </p>
  </p>
</div>
<h3>Direktiivit</h3>
<p>
  Jos olemme tarkkoja, emme ole puhuneet asioista täysin niiden oikeilla nimillä. Olemme puhuneet mm. <code>ng-repeat</code>, <code>ng-if</code> ja <code>ng-controller</code> yhteydessä pelkistä attribuuteista, joita annetaan DOM-elementeille. Toisaalta ne ovat sitä, mutta Angularin yhteydessä niillä on toinen nimi, <a href="https://docs.angularjs.org/guide/directive" target="_blank">direktiivi</a> (directive). Direktiivit ovat yksinkertaisesti tunnuksia (yleensä juuri attribuutteja) DOM-elementeissä, jotka kertovat Angularin HTML-kääntäjälle, että niihin pitää liittää erityisiä ominaisuuksia tai muuttaa elementtiä ja sen lapsielementtejä esimerkiksi lisäämällä niiden sisään toisia DOM-elementtejä tai muokkaamalla olemassaolevien elementtien esitystä.
</p>
<p>
  Sovellusta toteuttaessa tulee usein vastaan tilanne, jossa valmista direktiiviä ei löydy, jolloin se pitää joko toteuttaa itse, tai etsiä muualta. Angulariin on toteuttu lukuisia ulkopuolisia direktiivejä, mutta toteutetaan harjoituksen vuoski yksi itse. Oman direktiivin luonti tapahtuu seuraavasti: 
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', []);

App.directive('counter', function(){
  // ...
});
</pre>
<p>
  Huomaat, että direktiivin luonti muistuttaa erehdyttävästi kontrollerin luontia. Kutsumme vain moduulillemme <code>directive</code>-funktiota ja annamme ensimmäiseksi parametriksi direktiivin nimen ja toiseksi anonyymin funktion. Tässä esimerkissä loin direktiivin <counde>counter</code>, jonka voin liittää DOM-elementtiin seuraavasti:
</p>
<pre class="sh_html">
&lt;button counter&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  <code>counter</code>-direktiivi on nyt liitetty <code>button</code>-elementtiin, se ei tosin vielä tee mitään. Muista nimeämisessä että, jos direktiivisi nimi on esimerkiksi <code>MinunOmaDirektiivini</code>, voi sen lisätä DOM-elementtiin attribuutilla <code>minun-oma-direktiivini</code> (CamelCase-tyyli muuttuu viivoilla erotetuiksi sanoiksi). Laitetaan seuraavaksi direktiivimme esittämään käyttäjälle alert-ikkuna, kun siihen liittyvää elementtiä klikataan:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    link: function(scope, elem, attrs){
      $(elem).on('click', function(){
        alert('Klikkasit!');
      });
    }
  }
});
</pre>
<p>
  Direktiivin ominaisuudet liitetään objektiin, jonka toisena parametrina annettu anonyymifunktio palauttaa. Voimme liittää palautettuun objektiin kentän <code>link</code>, joka sisältää funktion, joka ottaa parametreikseen näkyvyysalueen, jossa direktiivi sijaitsee (<code>scope</code>), elementin, johon direktiivi on liitetty (<code>elem</code>) ja attribuutit, mikä kyseiseen elementtiin liittyy (<code>attrs</code>). Funktion avulla voimme manipuloida DOM-elementtiä, johon direktiivimme on liitetty, kuten liittää siihen tapahtumankuuntelijan. Voimme lisäksi funktiossa päästä käsiksi koko kontrollerin näkyvyysalueeseen, jonka sisällä direktiivimme sijaitsee <code>scope</code>-parametrin avulla. Nyt kun käyttäjä klikkaa "Kasvata"-painiketta, johon <code>counter</code>-direktiivi on liitetty, ilmestyy alert-ikkuna "Klikkasit!". 
</p>
<p>
  <code>link</code>-kentässä määritellyn funktion ensimmäisen parametrin, <code>scope</code> avulla pääsemme käsiksi koko direktiivin näkyvyysalueeseen, joka on koko direktiivin ulkoinen näkyvyysalue. Usein haluamme kuitenkin määrittää direktiivillemme nk. eristetyn näkyvyysalueen, jonka avulla voimme kuvata direktiivin ulkoisen näkyvyysalueen sen sisäiseksi näkyvyysalueeksi. Se on kätevää, koska silloin direktiivinen toteutuksen ei tarvitse riippua siitä, minkä kontrollerin sisällä se on käytössä. Eristetyn näkyvyysaluuen toteuttaminen onnistuu määrittelemällä palautettavaan objektiin kenttä <code>scope</code>, johon määrittelemme direktiivin näkyvyysalueen. Käytännössä voimme esimerkiksi käyttää <code>ng-model</code>-direktiivissä määriteltyä muuttujaa direktiivissämme seuraavasti:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel'
    },
    link: function(scope, elem, attrs){
      $(elem).on('click', function(){
        alert(scope.number);
      });
    }
  }
});
</pre>
<p>
  Lisäsimme siis palautettavaan objektiin <code>scope</code> kentän, jossa määritimme, että lisäämme direktiivimme näkyvyysalueseen muuttujan <code>number</code>, jonka arvo vastaa <code>ng-model</code>-direktiivissä määriteltyä arvoa. Merkkijonossa <code>=ngModel</code>, <code>=</code>-merkki tarkoittaa, että sidomme ulkoisen näkyvyysalueen muuttujan direktiivimme näkyvyysalueeseen ja <code>ngModel</code> viittaa vain direktiiviin <code>ng-model</code> (huomaathan, että attribuutti on muotoa <code>attribuutin-nimi</code>, mutta siihen viitataan nimellä <code>attribuutinNimi</code>).  Muokkasimme myös <code>link</code>-kentessä määriteltyä funktiota niin, että alert-ikkunaan ilmestyy näkyvyysalueeseen lisätyn <code>number</code>-muuttujan arvo. Muokataan vielä näkymää niin, että <code>button</code>-elementtiin lisätään <code>ng-model</code>-direktiivi, jonka arvo on muuttuja <code>value</code>:
</p>
<pre class="sh_html">
Laskurin arvo on: {{value}}
&lt;button counter ng-model="value"&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  Koska muuttujan <code>value</code> arvoa ei ole vielä asetettua, "Kasvata"-painikkeen klikkaamisesta ilmestyvän alert-ikkunan sisältö on "undefined". Muokataan direktiiviämme vielä niin, että painikkeen klikkaaminen kasvattaa <code>ng-model</code>-direktiivissä määriteltyä arvoa:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel'
    },
    link: function(scope, elem, attrs){
      if(typeof scope.number == 'undefined'){
        scope.number = 0; 
      }

      $(elem).on('click', function(){
        scope.$apply(function(){
          scope.number++;
        });
      });
    }
  }
});
</pre>
<p>
  Ratkaisimme alustamattoman <code>ng-model</code>-direktiivissä annetun muuttujan ongelman, asettamalla siinä tilanteessa <code>number</code>-muuttujan arvon nollaksi. Lisäsimme myös klikkauksen tapahtumankuuntelijaan <code>number</code>-arvon kasvatuksen. Huomaa, jotta arvon muokkaaminen välittyisi direktiivin ulkopuolelle, täytyy kutsua funktiota <code>$apply</code>, jolloin kerromme Angularille, että olemme tehneet muutoksia malliin ja ne muutokset pitäisi välittää näkymään. Yleensä <code>$apply</code>-funktiota ei tarvitse erikseen kutsua, koska Angular hoitaa sen puolestasi. Olemme tapahtumankuuntelijassa kuitenkin Angularin kontekstin ulkopuolella, joten meidän täytyy kutsua <code>$apply</code>-funktiota itse, jotta saamme välitettyä mallissa tehdyt muutokset näkymään. 
</p>
<p>
  Lisätään vielä direktiiviimme yksi toiminto, jonka avulla sen käyttäjä kertoo, kuinka paljon hän haluaa muuttaa <code>ng-model</code>-direktiivissä määriteltyä arvoa. Sen voisi määritellä elementissä näin:
</p>
<pre class="sh_html">
Laskurin arvo on: {{value}}
&lt;button counter ng-model="value" amount="-2"&gt;Kasvata&lt;/button&gt;
</pre>
<p>
  Määritimme siis elementtiin <code>amount</code>-attribuutin, joka kertoo, että haluamme vähentää <code>value</code>-muuttujan arvoa kahdella jokaisen klikkauksen jälkeen. Joudumme vielä määrittämään <code>amount</code>-attribuutin direktiivimme eristettyyn näkyvyysalueeseen:
</p>
<pre class="sh_javascript_dom">
App.directive('counter', function(){
  return {
    scope: {
      number: '=ngModel',
      amount: '=amount'
    },
    link: function(scope, elem, attrs){
      if(typeof scope.number == 'undefined'){
        scope.number = 0; 
      }

      $(elem).on('click', function(){
        scope.$apply(function(){
          scope.number+=parseInt(scope.amount);
        });
      });
    }
  }
});
</pre>
<p>
  Liitimme <code>amount</code>-muuttujan eristettyyn näkyvyysalueeseemme. Muutimme myös <code>link</code>-kentässä määriteltyä funktiota niin, että se kasvattaa (tai vähentää) <code>number</code>-muuttujan arvoa <code>amount</code>-muuttujan arvon verran jokaisen klikkauksen jälkeen. Muuttujan <code>amount</code> arvoksi olisi voinut asettaa näkymässä myös muuttujan. Se johtuu siitä, että lisäsimme sen direktiivimme näkyvyysalueeseen <code>=</code>-operaattorilla. Toinen mahdollinen operaattori olisi ollut <code>@</code>, mutta silloin näkymän <code>amount</code>-attribuutissa määriteltyä arvoa olisi käsitelty puhtaana arvona, ei muuttujana. Lopputulos on testattavissa <a href="http://plnkr.co/edit/CtAROoWeBUWMNWRnistW?p=preview" target="_blank">Plunkerissa</a>.
</p>
<p>
  Tämä osio oli vasta pintaraapaisu direktiivien käyttöön. Lisää niistä voi lukea <a href="https://docs.angularjs.org/guide/directive" target="_blank">Angularin Developer Guidesta</a>.
</p>
<div class="tehtavat">
  <h3>Slider-direktiivi</h3>
  <p>
    Tehtävänäsi on toteuttaa jQueryn <a href="http://jqueryui.com/slider/" target="_blank">slider</a>-widgetti <code>slider</code>-nimisenä direktiivinä. Tarkoitus on, että kun käyttäjä muuttaa sliderin arvoa, myös siihen <code>ng-model</code>-direktiivin avulla sidotun muuttujan arvo muuttuu. Sliderin alkuarvon tulee olla sama, kuin siihen sidotun muuttujan arvo. Voit olettaa etta <code>ng-model</code>-direktiivissä sidottu muuttuja on kokonaisluku. Sliderin <a href="http://jqueryui.com/slider/#steps" target="_blank">stepin</a> (kuinka paljon sliderin arvo muuttuu liikutuksesta) voit päätää itse. Näkymässä esimerkiksi <code>div</code>-elementtiin sidottu <code>slider</code>-direktiivi näyttäisi tältä:  
  </p>
<pre class="sh_html">
&lt;div slider ng-model="number"&gt;&lt;/div&gt;
</pre>
<p>
  Tehtäväpohjasta löytyy valmis pohja direktiiville tiedostosta <code>app/directives/slider.js</code>. Kun näkymässä <code>index.html</code>-upotetun <code>number</code>-muuttujan arvo muuttuu sliderin liikuttamisen perusteella ja sliderin alkuperäinen sijainti vastaa muuttujan alkuarvoa (joka on <code>10</code>), tehtävä on valmis.
</p>
</div>
</section>
<section class="week">
  <header>
    <a name="viikko5"></a>
    <h1 data-week-id="5">Viikko 5</h1>
  </header>
  <h2>Jatketaan keskustelua palvelimen kanssa: Firebase</h2>
    <p>
      Viime viikolla kehitimme upean muistilistasovelluksen (tehtävä TodoApp), johon pystyi lisäämään muistettavia asioita ja merkkaamaan niitä tehdyiksi. Tylsä puoli sovelluksessa oli se, ettei se tallettanut lisäämiämme muistutuksia mihinkään. Korjaamme sen puolen sovelluksestamme tällä viikolla ottamalla käyttöön <a href="https://www.firebase.com/">Firebasen</a>, jonka avulla voimme tallettaa ja muuttaa dataa reaaliajassa. Kuulostaa siistiltä!  
    </p>
    <p>
      Aoita rekisteröitymällä Firebaseen <a href="https://www.firebase.com/signup/">täältä</a>. Kun olet rekisteröitynyt sinut ohjataan käyttäjäsi dashboardille, jossa ensimmäinen sovelluksesi on jo alustettu puolestasi nimellä "My first app". Olemme siis jo periaatteessa valmiita, katsotaan seuraavaksi hieman, miten saamme kytkettyä Firebasen Angular-sovellukseemme. 
    </p>
    <h3>Firebase ja Angular</h3>
    <p>
      Firebasella on oma moduuli (jonka nimi on yllätys ja yllätys <code>firebase</code>), joka tarjoaa työkalut datamme muokkaamiseen ja hakemiseen. <code>firebase</code>-moduuli on sisällä jokaisessa tehtäväpohjassa, joten riittää vain, että injektoit sen omaan <code>MyApp</code>-moduuliisi seuraavasti:
    </p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', ['firebase']);
</pre>
<p>
  Kun <code>firebase</code> moduuli on injektoitu omaan moduuliimme, pääsemme käyttämään sen tarjoamia palveluita. Seuraavaksi meidän täytyy toteuttaa omalle kontrollerillemme palvelu, joka hoitaa Firebasen kanssa keskustelmisen.
</p>
<h3>Palvelut (services)</h3>
<p>
  Palvelut ovat Angularissa kontrollereihin ja toisiin palveluihin injektoitavia komponentteja, jotka, kuten jo nimestä voi päätellä, tarjoavat sen käyttäjälle jonkin palvelun. Palvelu voi olla esimerkiksi API tiedon hakuun palvelimelta tai joukko funktioita, jotka tekevät eri joukko-operaatioita:  
</p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', []);

MyApp.service('Set', function(){
  return {
    intoSet: function(arr){
      var set = [];

      arr.forEach(function(item){
        if(set.indexOf(item) < 0){
          set.push(item);
        } 
      });

      return set;
    },

    union: function(arrA, arrB){
      var setA = this.intoSet(arrA);
      var setB = this.intoSet(arrB);

      setB.forEach(function(item){
        if(setA.indexOf(item) < 0){
          setA.push(item);
        } 
      });

      return setA;
    },

    intersection: function(arrA, arrB){
      var setA = this.intoSet(arrA);
      var setB = this.intoSet(arrB);

      var intersected = [];

      setA.forEach(function(item){
        if(setB.indexOf(item) >= 0){
          intersected.push(item);
        } 
      });

      return intersected;
    }
  }
});
</pre>
<p>
  Palvelun saa liitettyä moduulin täysin samaan tapaan kuin kontrollerinkin, kutsumme vain moduulillemme <code>controller</code>-funktion sijasta funktiota <code>service</code>. Funktio ottaa parametrikseen palvelun nimen merkkijonona ja funktion, joka palauttaa objektina palvelun tarjoamat funktiot. Huomaat varmasti, että palvelun rakenne muistuttaa hyvin paljon <a href="http://en.wikipedia.org/wiki/Module_pattern" target="_blank">Module pattern</a>-suunnittelumallia. Palveluiden luominen onkin hyvä tapa jakaa ohjelmaa pieniin ja helposti hallittaviin komponentteihin. Otetaan toteuttamme palvelu käyttöön kontrollerissa:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, Set) {    
    $scope.union = function(){
       var arrA = $scope.arrA.split(',');
       var arrB = $scope.arrB.split(',');
       
       $scope.result = Set.union(arrA, arrB).toString();
    }
    
    $scope.intersection = function(){
       var arrA = $scope.arrA.split(',');
       var arrB = $scope.arrB.split(',');
       
       $scope.result = Set.intersection(arrA, arrB).toString();
    }
});
</pre>
<p>
  Voimme käyttää siis toteuttamaamme palvelua injektoimalla sen kontrolleriimme lisäämällä sille parametrin <code>Set</code>. Palvelun tarjoamat funktiot ovat sen jälkeen käytettävissä kontrollerissa. Tässä vielä lopullinen versio:
  <iframe width="100%" height="300" src="http://jsfiddle.net/HB7LU/11001/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe> 
</p>
<h4>Firebase-palvelu</h4>
<p>
  Voisimme periaatteessa upottaa kaiken Firebasen käyttöön liittyvän logiikan suoraan kontrolleriimme, mutta siitä tulisi erittäin sekavaa. Tehdään sen sijaan moduuliimme palvelu (service), joka hoitaa Firebasen kanssa keskustelemisen kontrollerimme puolesta, niin kontrolleristamme tulee selkeämpi ja se noudattaa paremmin jo mainittua "Single Responsibility"-periaatetta. Liitetään moduuliimme aluksi <code>FirebaseService</code>-niminen palvelu:
</p>
<pre class="sh_javascript_dom">
var MyApp = angular.module('MyApp', ['firebase']);

MyApp.service('FirebaseService', function($firebase){
  // ...  
});
</pre>
<p>
  Injektoin siis ensin <code>firebase</code>-moduulin omaan moduuliini ja sen jälkeen sen tarjoaman <code>$firebase</code>-palvelun omaan <code>FirebaseService</code>-palveluuni. 
</p>
<img src="img/firebase_content.png" style="float: right; width: 300px; margin-left: 15px;">
<p>
  Ennen kuin etenemme pidemmälle, lisätään sovellukseemme hieman dataa Firebasen kautta. Siirry ensin käyttäjäsi dashboardille ja klikkaa "My first app" alapuolelta painiketta "Manage app". Sivulle aukee sovelluksesi datasisältö, joka on tällä hetkellä tyhjä. Lisätään sovellukseen dataa, viemällä hiiri sovelluksemme datan osoitteen päälle (se on hassu nimi, kuten scorching-torch-2360), jolloin sen viereen ilmestyy vihreä "+"-painike, paina sitä. Kun olet painanut "+"-painiketta ilmestyy datan osoitteen alapuolelle tekstikentät <code>name</code> ja <code>value</code>. Kirjoita <code>name</code>-kenttään "message" ja <code>value</code>-kenttään "Hello World!" ja paina kenttien vierestä vihreää "+"-painiketta. Sovelluksessamme on nyt dataa, joka on objekti <code>{ message: 'Hello World!' }</code>, jonka rakenteen määrittelimme <code>name</code>- ja <code>value</code>-kenttien kautta. Katsotaan seuraavaksi, miten voimme hakea tämän datan sovelluksestamme käsin.
</p>
<h4>Datan haku Firebasesta</h4>
<p>
  Olen jo saanut valmiiksi <code>FirebaseService</code>-palveluni rungon. Lisään siihen seuraavaksi funktion, joka hakee datani Firebasesta:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE');
  var sync = $firebase(firebaseRef);
  var data = sync.$asObject(); 
  
  this.fetchData = function(){
    return data;
  }
});
</pre>

<img src="img/firebase_data_url.png" style="float: left; width: 300px; margin-right: 15px;">
<p>
  Käydään läpi, mitä <code>FirebaseService</code>-palvelussa oikein tapahtuu. Talletan aluksi <code>firebaseRef</code>-muuttujaan <code>Firebase</code>-olion, joka ottaa parametrikseen sovelluksemme datasäilön sijainnin (joudut vaihtamaan kohtaan <code>OMA_FIREBASE</code> oman datasi sijainnin, joka löytyy dashboardiltasi kuvan osoittamasta paikasta). Sen jälkeen lisään palveluuni funktion <code>fetchData</code> kontrollerin käyttöä varten. Funktiossa talletan referenssin dataani kutsumalla injektoimaani <code>$firebase</code>-funktiota omalla <code>Firebase</code>-oliollani. Sen jälkeen voin hakea sovellukseni datan kutsumalla referenssille funktiota <code>$asObject()</code>. Otetaan seuraavaksi palvelu käyttöön kontrollerissa:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  var data = FirebaseService.fetchData();
  $scope.message = data.message;
});
</pre>
<p>
  Riittää siis vain injektoida toteutettu <code>FirebaseService</code>-palvelu kontrolleriin ja olemme valmiita käyttämään sitä. Voimme näyttää Firebasesta hakemamme datan, joka oli objekti <code>{ message: 'Hello World!' }</code> näkymässämme, aivan kuten muutkin muuttujat:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;h1&gt;{{message}}&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymään ilmestyy otsikko "Hello World!", joten datan hakeminen Firebasesta on onnistunut.
</p>
<div class="tehtavat">
  <h3>Hello Firebase!</h3>
  <p>
    <a href="https://www.firebase.com/signup/" target="_blank">Rekisteröidy</a> Firebaseen ja lisää sinne dataa, jonka sisältö on <code>{ message: 'Hello World!' }</code> (<code>message</code>-kenttä, jonka arvo on "Hello World"). Muista, että voit lisätä sovellukseesi dataa suoraan Firebasesta siirtymällä dashboardilta sovelluksesi hallintaan klikkaamalla "Manage App".  
  </p>
  <p>
    Muokkaa tehtäväpohjaa siten, että <code>app/services/firebase_service.js</code>-tiedostossa sijaitseva <code>FirebaseService</code>-palvelu hakee lisäämäsi datan Firebasesta (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebase-asobject" target="_blank">$asObject</a></code>). Muokkaa sen jälkeen <code>app/controllers/hello_controller.js</code>-tiedossa sijaitsevaa <code>HelloController</code>-kontrolleria niin, että se käyttää <code>FirebaseService</code>-palvelua hakemaan Firebasesta viestin "Hello World!" ja esittää sen näkymässä esimerkiksi muuttujan <code>message</code> arvona. Muista injektoida <code>FirebaseService</code> kontrolleriin, muuten sen käyttäminen ei onnistu!
  </p>
</div>
<h4>Datan lisääminen Firebaseen</h4>
<p>
  Olemme onnistuneet hakemaan dataa Firebasesta, joten seuraava looginen askel on katsoa, miten voimme lisätä sinne dataa. Paltaan takaisin <code>FirebaseService</code>-palvelumme pariin ja lisätään siihen funktio <code>addMessage</code>, joka lisää parametrina saadun objektin Firebaseen:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }
});
</pre>
<p>
  Tämä eroaa melko datan lisäämisestä, joten on hyvä käydä läpi, mitä oikein tapahtuu. Aluksi alustin uuden <code>Firebase</code>-olion melkein samaan tapaan kuin datan hakemisen kanssa, pientä yksityiskohtaa lukuunottamatta. Huomasit ehkä, että lisäsin Firebase-polkuni perään <code>/messages</code>. Tein sen siitä syystä, että haluan hakea ja tehdä muutoksia vain resurssiin <code>messages</code>. Sen jälkeen kutsun <code>$firebase</code>-funktiota alustamallani <code>Firebase</code> oliolla aivan, kuten datan lisäämisen kanssa. Seuraavaksi en kuitenkaan kutsu referenssille funktiota <code>$asObject</code>, vaan <code>$asArray</code>, koska haluan käsitellä dataani taulukkona objektin sijaan. Se on melko loogista, koska haluan hakea ja muokata joukkoa viestejä.
</p>
<p>
  Alustus on tehty, pureudutaan seuraavaksi funktioon <code>addMessage</code>. Sen toteutus on erittäin yksinkertainen, kutsun vain <code>messages</code>-resurssilleni funktiota <code>$add</code>, joka lisää parametrina saadun objektin taulukkoon muiden viestien sekaan. Ei siis sen kummempaa. Käytetään toteuttamaamme palvelua vielä kontrollerissamme: 
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.newText = '';
  
  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }
});
</pre>
<p>
  Nyt voimme sitoa näkymässä tekstikentän arvon muuttujaan <code>newText</code> ja sitoa painikkeen painalluksen funktion <code>addMessage</code>-kutsuun:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;textarea ng-model="newMessage"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Pystyn nyt lisäämään dataa Firebaseen, mutta en pääse tarkkailemaan sitä muualta, kuin Firebase käyttäjäni dashboardilta. Lisätään siis vielä <code>FirebaseService</code>-palveluun funktio <code>getMessages</code>, joka hakee kaikki viestit <code>messages</code>-resurssista, jotta voimme näyttää ne näkymässä:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }
});
</pre>
<p>
  Todella helppoa! Palautan siis vain <code>getMessages</code>-funktiossa <code>messages</code>-taulukon, joka sisältää kaikki sovellukseni viestit. Muokataan vielä hieman kontrolleriamme:
</p>

<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';
  
  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }
});
</pre>
<p>
  Huomaa, ettei <code>addMessage</code>-funktiossa uutta viestiä tarvitse lisätä erikseen <code>messages</code>-taulukkoon, sillä Firebase synkronoi taulukon sisällön lisäämisen yhteydessä puolestasi. Kätevää! Listataan <code>messages</code>-taulukon alkiot vielä näkymässä:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul ng-repeat="message in messages"&gt;
        &lt;li&gt;{{messages.text}}&lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Se on siinä! Olemme toteuttaneet pienen chatin, seuraavaksi saat hieman parannella sitä.
</p>
<div class="tehtavat">
  <h3>Chat (2p)</h3>
  <p>
    Parannellaan hieman yllä olevaa esimerkkiä lisäämällä chattiin käyttäjät (vinkki: pidä käyttäjät ja viestit erillisinä resursseina Firebasessa). Kun käyttäjä avaa sovelluksen, pyydä häntä valitsemaan itselleen käyttäjätunnus. Jos käyttäjätunnus löytyy ennestään, älä lisää sitä uudestaan Firebaseen (vinkki: hae kaikki käyttäjät Firebasesta ja katso, löytyykö sieltä käyttäjän antamaa käyttäjätunnusta), muuten lisää uusi käyttäjä (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-addnewdata" target="_blank">$add</a></code>). Kun käyttäjätunnus on valittu (vinkki: piilota chatti-näkymä kunnes käyttäjätunnuksella on arvo, esimerkiksi <code>ng-if</code>-direktiivin avulla), näytä näkymässä chatin viestit ja sen vieressä chatin käyttäjät. Kun käyttäjä lisää viestin chattiin, näytä viestin vieressä hänen käyttäjänimensä ja sen alapuolella, milloin viesti on lisätty (vinkki: <code><a href="http://www.w3schools.com/jsref/jsref_obj_date.asp" target="_blank">Date</a></code>). Lisää siis Firebaseen talletettavaan viestiin esimerkiksi kenttä <code>username</code> (käyttäjätunnukselle) ja <code>added</code> (viestin lisäämisen ajalle). Älä anna käyttäjän lisätä chattiin tyhjää viestiä.
  </p>
  <p>
    Tehtäväpohjasta löytyy <code>ChatController</code>-kontrollerin pohja tiedostosta <code>app/controllers/chat_controller.js</code> ja Firebasen kanssa keskustelevan <code>FirebaseService</code>-palvelun pohja tiedostosta <code>app/services/firebase_service.js</code>. Näkymä löytyy tutusta <code>index.html</code>-tiedostosta.
  </p>
</div>
<h4>Olemassaolevan datan muokkaaminen ja poistaminen Firebasessa</h4>
<p>
  Katsotaan vielä pari höydyllistä Firebasen toimintoa ennen kuin siirrymme muiden aiheiden pariin. Tarkastellaan ensin, miten voimme muokata olemassaolevaa dataa. Käytetään esimerkkinä edellisessä osiossa toteuttamaamme pientä chatti-sovellusta. Lisätään <code>FirebaseService</code>-palveluun funktio <code>editMessage</code>, joka tallettaa parametreina saatuun viestiin tehdyt muutokset:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }

  this.editMessage = function(message){
    messages.$save(message);
  }
});
</pre>
<p>
  Funktiossa <code>editMessage</code> kutsumme <code>messages</code>-resurssille funktiota <code>$save</code>, joka päivittää parametrina saadun alkion Firebasessa. Tehdään seuraavaksi kontrolleriin saman niminen funktio, joka käyttää toteuttamaamme funktiota:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';
  $scope.editText = ''
  
  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }

  $scope.showEditForm = function(message){
    $scope.editText = message.text;
    message.editing = true;
  }

  $scope.editMessage = function(message){
    if($scope.editText != ''){
      delete message.editing

      message.text = $scope.editText;
      FirebaseService.editMessage(message);
      
      $scope.editText = '';
    }
  }
});
</pre>
<p>
  Lisäsin <code>editMessage</code>-funktion lisäksi funktion, jonka avulla näytän viestin muokkauslomakkeen. Funktio <code>showEditForm</code> näyttää parametrina saadun viestin muokkauslomakkeen asettamalla sen <code>editing</code>-kentän arvoksi <code>true</code>. Kun muokkaan viestiä <code>editMessage</code>-funktiossa, poistan siitä kentän <code>editing</code> ennen kuin muokkaan sitä, jotta sitä ei talletettaisi Firabaseen. Katsotaan vielä, miten näitä funktioita käytetään näkymässä: 
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul ng-repeat="message in messages"&gt;
        &lt;li&gt;
          {{messages.text}}

          &lt;button ng-click="showEditForm(message)" ng-hide="message.editing"&gt;Muokkaa&lt;button&gt; 

          &lt;p ng-show="message.editing"&gt;
            &lt;textarea ng-model="editText"&gt;&lt;/textarea&gt;
            &lt;button ng-click="editMessage(message)"&gt;Lisää viesti&lt;/button&gt;
          &lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Lisäsin jokaisin viestin alle sen muokkauslomakkeen, joka näytetään vain, jos sen <code>editing</code>-kentän arvo on <code>true</code>. Muokkauslomakkeen avaaminen onnistuu klikkaamalla "Muokkaa"-painiketta, jonka klikkaaminen kutsuu <code>showEditForm</code>-funktiota. Muokkauslomakkeesta "Lähetä"-painikkeen painallus taas kutsuu <code>editMessage</code>-funktiota, joka muokkaa viestin sisältöä painikkeen yllä olevan tekstikentän perusteella, joka on sidottu muuttujan <code>editText</code> arvoon.
</p>
<p>
  Kun olemme päässeet vauhtiin, toteutetaan vielä viestin poistotoiminto. Palataan takaisin <code>FirebaseService</code>-palvelun pariin ja lisätään sinne funktio <code>removeMessage</code>, joka poistaa parametrina annetun pelin Firebasesta:
</p>
<pre class="sh_javascript_dom">
MyApp.service('FirebaseService', function($firebase){
  var firebaseRef = new Firebase('OMA_FIREBASE/messages');
  var sync = $firebase(firebaseRef);
  var messages = sync.$asArray();

  this.addMessage = function(message){
    messages.$add(message);
  }

  this.getMessages = function(){
    return messages;
  }

  this.editMessage = function(message){
    messages.$save(message);
  }

  this.removeMessage = function(message){
    messages.$remove(message);
  }
});
</pre>
<p>
  Saatoit jo melkein arvata, miten <code>removeMessage</code>-funktio toteutetaan. Kuten ennenkin, selviämme yhdellä rivillä koodi, tällä kertaa kutsumme <code>messages</code>-resurssille funktiota <code>$remove</code>, joka poistaa parametrina annetun alkion Firebasesta. Toteutetaan vielä kontrolleriin <code>removeMessage</code>-metodi:
</p>
<pre class="sh_javascript_dom">
MyApp.controller('MyController', function($scope, FirebaseService){
  $scope.messages = FirebaseService.getMessages();
  $scope.newText = '';
  $scope.editText = ''
  
  $scope.addMessage = function(){
    if($scope.newText != ''){
      FirebaseService.addMessage({
        text: $scope.newText
      });

      $scope.newText = '';
    }
  }

  $scope.showEditForm = function(message){
    $scope.editText = message.text;
    message.editing = true;
  }

  $scope.editMessage = function(message){
    if($scope.editText != ''){
      delete message.editing

      message.text = $scope.editText;
      FirebaseService.editMessage(message);
      
      $scope.editText = '';
    }
  }

  $scope.removeMessage = function(message){
    FirebaseService.removeMessage(message);
  }
});
</pre>
<p>
  Kontrollerissa ei tapahtu mitään kovin kummallista, <code>removeMessage</code>-funktiossa kutsutaan vain <code>FirebaseService</code>-palvelun tarjoamaa <code>removeMessage</code>-funktiota. Lisätään vielä näkymään panike, jonka painallus kutsuu toteuttamaamme funktiota:
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;div ng-controller="MyController"&gt;
      &lt;ul ng-repeat="message in messages"&gt;
        &lt;li&gt;
          {{message.text}}

          &lt;button ng-click="removeMessage(message)"&gt;Poista&lt;button&gt; 
          &lt;button ng-click="showEditForm(message)" ng-hide="message.editing"&gt;Muokkaa&lt;button&gt; 

          &lt;p ng-show="message.editing"&gt;
            &lt;textarea ng-model="editText"&gt;&lt;/textarea&gt;
            &lt;button ng-click="editMessage(message)"&gt;Lisää viesti&lt;/button&gt;
          &lt;/p&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;textarea ng-model="newText"&gt;&lt;/textarea&gt;
      &lt;button ng-click="addMessage()"&gt;Lisää viesti&lt;/button&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Näkymässä "Poista"-painikkeen painallus kutsuu funktiota <code>removeMessage</code>. Huomaa, ettei poistamisen yhteydessä tarvitse poistaa alkiota erikseen <code>messages</code>-taulukossa, koska Firebase synkronoi taulukon sisällön automaattisesti.
</p>
<div class="tehtavat">
  <h3>TodoApp ja Firebase (3p)</h3>
  <p>
    Toteutimme viime viikolla muistilistan, jonka mallivastaus löytyy tehtäväpohjasta. Voit halutessasi korvata mallivastauksen omalla toteutuksellasi. Toteuta sovellukseen palvelu, joka keskustelee Firebasen kanssa niin, että muistilistan tehtäviä pystyy lisäämään (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-addnewdata" target="_blank">$add</a></code>), merkkaamaan tehdyiksi (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-saverecordorindex" target="_blank">$save</a></code>) ja poistamaan (vinkki: <code><a href="https://www.firebase.com/docs/web/libraries/angular/api.html#angularfire-firebasearray-removerecordorindex" target="_blank">$remove</a></code>) Firebasesta. Kaikki viime viikolla toteutetut toiminnot tulee siis nyt toteuttaa käyttämällä Firebasea. Valmiissa tehtäväpohjassa Firebasen kanssa keskustelevan <code>FirebaseService</code>-palvelun pohja löytyy tiedostosta <code>app/directives/firebase_service.js</code>, kontrolleri <code>TodoController</code> tiedostosta <code>app/controllers/todo_controller.js</code> ja näkymä tiedostosta <code>index.html</code>. Tee siis tarvittavat muutokset palveluun, kontrolleriin ja näkymään.
  </p>
</div>
    <h2>Testaaminen</h2>
  <p>
    Yksi Angularin käytön hyvä puoli on se, että se on helposti testattava, kunhan käytettävät työkalut on oikeat. Ensimmäiseksi tarvitaan työkalu, joka käytännössä ajaa testit. Tähän tehtävään käytetään usein Angularin kanssa <a href="http://karma-runner.github.io/0.12/index.html" target="_blank">Karmaa</a>. Se on komentorivi työkalu, jonka avulla voimme muodostaa tilapäisen web-palvelimen, joka lataa sovelluksesi lähdekoodit ja ajaa testisi ja kertoo, mitkä niistä läpäistiin ja mitkä ei. Karman lisäksi tarvitsemme testaamista varten kehitetyn sovelluskehyksen, jota käyttäen voimme toteuttaa sovelluksellemme testit. Sitä varten on kehitetty <a href="http://jasmine.github.io/1.3/introduction.html" target="_blank">Jasmine</a>, joka on "<a href="http://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank">Behavior-driven</a>"-sovelluskehitykseen (BDD) toteutettu sovelluskehys JavaScript-koodin testaamiseen.
  </p>
<h3>Testaaminen Jasminella</h3>
<p>
  Jasminella toteutettu testi alkaa <code>describe</code>-funktion kutsulla, joka ottaa ensimmäiseksi parametrikseen merkkijonon, joka on testijoukon nimi, tai otsikko ja toiseksi parametrikseen anonyymin funktion, jonka sisältää itse testit:
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  // ...
});
</pre>
<p>
  Eli määrittelemme testijoukon nimeltä "An example" kutsumalla <code>describe</code>-funktiota. Itse testit sijoitetaan toisena parametrina annetun anonyymin funktion sisään. Jokainen testi on yksi <code>it</code>-funktion kutsu, jonka ensimmäinen parametri on <code>describe</code>-funktiossa määritellyn testijoukon yhden testattavan toiminnon nimi ja toinen parametri on anonyymifunktio, joka sisältää itse testin.
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  it('should work when trying to match true with true', function(){
    var isTrue = true;
    expect(isTrue).toBe(true)
  })
});
</pre>
<p>
  Testin sisällä määritämme, että haluamme tarkkailla <code>isTrue</code>-muuttujan arvoa kutsumalla <code>expect</code>-funktiota se parametrinaan. Sen jälkeen ketjutamme sen perään funktiokutsun, jonka avulla kohdistamme <code>isTrue</code>-muuttujan arvoon jonkin oletuksen. Tässä esimerkissä oletimme sen arvon olevan <code>true</code> kutsumalla <code>toBe</code>-funktiota. Koodi on niin selkeää, että sen voi oikeastaan lukea ääneen - "expect isTrue to be true", eli "oletetaan, että isTrue on true". Muuttujaan liittyviä oletuksia on lukuisia, tässä tärkeimpiä:
</p>
<pre class="sh_javascript_dom">
describe('An example', function(){
  it('should work when trying to match true with true', function(){
    var isTrue = true;
    expect(isTrue).toBe(true)
  });

  it('should work with negation', function(){
    var isFalse = false;
    // negaatiota, not, voi käyttää kaikkien oletuksien kanssa
    expect(isFalse).not.toBe(true);
  });

  it('should work when checking object equality', function(){
    var foo = {
      a: 12,
      b: 34
    };

    var bar = {
      a: 12,
      b: 34
    };

    // foo- ja bar-objektit ovat samat, jos niissä on samat kentät, joiden arvot ovat samat
    expect(foo).toEqual(bar);
  });

  it('should work when checking variable existence', function(){
    var foo = 'bar';
    // oletetaan, että muuttuja foo on määritelty
    expect(foo).toBeDefined();
  });

  it('should work when checking if item is in array', function(){
    var names = ['Elina', 'Kalle', 'Arto', 'Jorma', 'Matti']
    // oletetaan, että taulukossa names on alkio "Elina"
    expect(names).toContain('Elina');
  });

  it('should work when checking if the value is less or greater than another', function(){
    var age = 21;
    // oletetaan, että age on suurempi kuin 18
    expect(age).toBeGreaterThan(18);
    // oletetaan, että age on pienempi kuin 50
    expect(age).toBeLessThan(50);
  });
});
</pre>
<p>
  Tässä vain pieni osa mahdollisia oletuksia muuttujan arvolle. Kuten huomaat, oletuksien nimeäminen on niin selkeää, että tiedät heti, mitä muuttujalta oletetaan. Voit lukea lisää Jasminen oletuksista sen <a href="http://jasmine.github.io/2.0/introduction.html#section-Expectations" target="_blank">dokumentaatiosta</a>. Katsotan seuraavaksi, miten pystymme testaaman Angular-sovellustamme Jasminella.
</p>
<h3>Angular sovelluksen testaaminen</h3>
<p>
  Testataan seuraavaksi yksinkertaista ystävälista sovellusta, jonka kautta käyttäjä voi lisätä ystäviä ystävälistalleen ja poistaa niitä. Sovelluksen toteutus on seuraava:
</p>
<pre class="sh_javascript_dom">
var FriendApp = angular.module('FriendApp', []);

FriendApp.controller('FriendListController', function($scope){
  $scope.friends = [];

  $scope.addFriend = function(){
    if($scope.newFriend != ''){
      $scope.friends.push($scope.newFriend);
      $scope.newFriend = '';
    }
  }

  $scope.removeFriend = function(index){
    if($scope.friends.length >= index){
      $scope.friends.splice(index, 1);
    }
  }
});
</pre>
<p>
  Haluamme testata <code>FriendListController</code>-kontrollerissa viittä eri asiaa:
  <ul>
    <li>Ystävälista on aluksi tyhjä.</li>
    <li>Ystävälistaan pystyy lisäämään ystävän kutsumalla <code>addFriend</code>-funktiota.</li>
    <li>Jos lisättän ystävän nimi on tyhjä, häntä ei lisätä ystävälistaan.</li>
    <li>Ystävän pystyy poistamaan ystävälistalta kutsumalla <code>removeFriend</code>-funktiota.</li>
    <li>Ystävää ei poisteta, jos häntä yritetään poistaa <code>friends</code>-taulukon ulkopuolelta.</li>
  </ul>
</p>
<p>
  Aloitetaan testaaminen kutsumalla Jasminen <code>describe</code>-funktiota:
</p>
<pre class="sh_javascript_dom">
describe('FriendListController', function(){
  var controller, scope;

  beforeEach(function(){
    module('FriendApp');

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('FriendListController', {
        $scope: scope
      });
    });
  });

});
</pre>
<p>
  Jotta voimme testata kontrolleriamme, meidän täytyy ensin alustaa se ennen jokaista testiä, eli <code>it</code>-funktion kutsua. Kätevimmin se tapahtuu kutsumalla <code>beforeEach</code>-funktiota, jonka parametrina saatua funktiota kutsutaan jokaisen <code>it</code>-funktiokutsun alussa. Alustuksessa määrittelemme aluksi, mikä moduuli on testattavana kutsumalla <code>module</code>-funktiota, meidän tapauksessamme se on <code>FriendApp</code>. Seuraavaksi injektoimme testeihimme <code>FriendListController</code>-kontrollerimme ja injektoimme sen <code>$scope</code>-parametrin arvoksi globaalin <code>scope</code>-parametrin arvomme. Nyt pääsemme käsiksi kontrollerin näkyvyysalueeseen testeissämme <code>scope</code>-muuttujan kautta:
</p>
<pre class="sh_javascript_dom">
describe('FriendListController', function(){
  var controller, scope;

  beforeEach(function(){
    module('FriendApp');

    inject(function($controller, $rootScope) {
      scope = $rootScope.$new();
      controller = $controller('FriendListController', {
        $scope: scope
      });
    });
  });

  it('should be initialized with an empty friend list', function(){
    expect(scope.friends.length).toBe(0);
  });

  it('should be able to add a friend', function(){
    expect(scope.friends.length).toBe(0);
    scope.newFriend = 'Arto';
    scope.addFriend();
    expect(scope.friends.length).toBe(1);
  });

  it('should not be able to add a friend with an empty name', function(){
    expect(scope.friends.length).toBe(0);
    scope.newFriend = '';
    scope.addFriend();
    expect(scope.friends.length).toBe(0);
  });

  it('should be able to remove a friend', function(){
    scope.friends = ['Arto', 'Matti', 'Elina', 'Kalle'];
    expect(scope.friends.length).toBe(4);
    scope.removeFriend(0);
    expect(scope.friends.length).toBe(3);
    expect(scope.friends).not.toContain('Arto');
  });

  it('should not be able to remove a friend outside the array boundaries', function(){
    scope.friends = ['Kalle', 'Elina'];
    expect(scope.friends.length).toBe(2);
    scope.removeFriend(6);
    expect(scope.friends.length).toBe(2);
  });
});
</pre>
<p>
  <code>FriendListController</code>-kontrollerille on nyt kirjoitettu viisi eri testiä, joista jokainen on oma <code>it</code>-funktion kutsunsa. Testeissä ei tapahdu mitään kovin erikoista, kutsumme <code>scope</code>-muuttujan kautta kontrollerissamme määriteltyjä <code>addFriend</code>- ja <code>removeFriend</code>-funktiota ja varmistamme, etteivät ne tee mitään kummallista <code>friends</code>-taulukolle.
</p>
<h3>Testien suorittaminen</h3>
<p>
  Tarvitset tässä vaiheessa NetBeansin versiota 8.0.1, tai uudempaa. Uusimman version voit asentaa <a href="https://netbeans.org/downloads/" target="_blank">täältä</a>. Testien ajamiseen tarvitsemme jo mainitun Karman, joka taas tarvitsee toimiakseen <a href="http://nodejs.org/" target="_blank">Node.js</a>:ssän. Lisäksi tarvitsemme <a href="http://git-scm.com/" target="_blank">Git</a>:iä riippuvuuksien hallintaan. Alla on asennusohjeet eri alustoille. Huomaa, että kaksi ensimmäistä ohjetta olettaa, että sinulla on koneellasi pääkäyttäjän oikeudet. Kolmas ohje on laitoksen koneelle, jossa sinulla ei ole pääkäyttäjän oikeuksia.
</p>
<h4>Node.js ja Git Windowsille (pääkäyttäjän oikeuksilla)</h4>
<p>
  Käy hakemassa <a href="http://nodejs.org/" target="_blank">Node.js</a>-asennuspaketti sen kotisivuilta painamalla "Install"-painiketta. Kun asennuspaketti on ladattu, käynnistä se. Kun asennus on valmis avaa Noden komentorivi työkalu siirtymällä "Start", hakemalla ohjelmaa "Node.js command promt" ja käynnistämällä sen. Jos ohjelma löytyy, Node.js on asennettu onnistuneesti.
</p>
<p>
  Jos koneeltasi puuttuu Git, asenna se seuraavaksi <a href="http://git-scm.com/" target="_blank">täältä</a> painamalla "Download"-painiketta. Kun pääset asennusikkunaan, voit käyttää oletusasetuksia, mutta valitse "Run Git from the Windows Command Promt"-asetus, kun se tulee valittavaksi</strong>. Kun asennus on valmis, avaa "Node.js command promt", kuten edellisessä kohdassa ja suorita siinä komento <code>git --version</code>. Terminaaliin pitäisi ilmestyä versionumero, kuten <code>git version 1.8.5.2</code>.
</p>
<h4>Node.js ja Git OS X:lle ja Linuxille (pääkäyttäjän oikeuksilla)</h4>
<p>
  Käy hakemassa <a href="http://nodejs.org/" target="_blank">Node.js</a>-asennuspaketti sen kotisivuilta painamalla "Install"-painiketta. Kun asennuspaketti on ladattu, käynnistä se. Kun asennus on valmis, avaa terminaali ja suorita siinä komento <code>node --version</code>, jonka jälkeen terminaaliin pitäisi ilmestyä jokin versionumero, kuten <code>v0.10.29</code>. Jos versionumero ilmestyy terminaaliin, Node.js on asennettu onnistuneesti.
</p>
<p>
  Jos koneeltasi puuttuu Git, asenna se seuraavaksi <a href="http://git-scm.com/" target="_blank">täältä</a> painamalla "Download"-painiketta. Kun asennus on valmis siirry terminaaliin ja suorita siinä komento <code>git --version</code>. Terminaaliin pitäisi ilmestyä versionumero, kuten <code>git version 1.8.5.2</code>.
</p>
<h4>Node.js laitoksen koneille</h4>
<p>
  Laitoksen koneilla Git:in pitäisi olla valmiina asennettuna, mutta Noden asennuksen kanssa ongelma on se, ettei sinulla ole pääkäyttäjän oikeuksia, joka tekee asioista hieman vaikeampaa. Noden asennus onnistuu kuitenkin suorittamalla terminaalissa seuraavan komennon:
</p>
<pre class="sh_javascript_dom">
curl http://web-selainohjelmointi.github.io/node-install.sh | bash
</pre>
<p>
  Komennon suorittaminen kestää jonkin aikaan. Kun se on valmis suorita terminaalissa komento <code>node --version</code>, jonka jälkeen terminaaliin pitäisi ilmestyä jokin versionumero, kuten <code>v0.10.29</code>. Tämä tarkoittaa sitä, että Node on asennettu. <strong>Laitoksen koneilla Node.js komentojen ajaminen NetBeansin kautta ei kuitenkaan onnistu, mutta samat komennot voit ajaa terminaalissa NetBeans-projektien jureessa</strong>.
</p>
<h4>Testien ajaminen NetBeansissa</h4>
<p>
  Kun Node ja Git on asennettua, olemma valmiita siirtymään NetBeansiin pariin. Käynnistä NetBeans ja avaa siinä tämän viikon tehtävä <code>TodoAppTestaaminen</code>. Jos NetBeans oli jo käynnissä, käynnistä se uudelleen, niin asennukset ovat varmasti tulleet voimaan. Kuten huomaat, projektin nimi on punainen, joten jotain on vialla. Ongelma ratkeaa painamalla hiiren oikeaa painiketta projektin päällä ja valitsemalla "Npm install". Klikkaaminen asentaa Karman ja muut tarvittavat riippuvuudet. Kun riippuvuudet on asennettu, klikkaa taas hiiren oikeaa painiketta projektisi nimen päällä ja valitse "Properties". Valitse avautuvasta ikkunasta oikealla sijaitsevasta valikosta "JavaScript Testing" ja valitse "Testing Provider"-valikosta "Karma". Alle ilmestyy tekstikentät "Karma" ja "Configuration", klikkaa molempien oikealta puolelta "Search"-painikkeita, niin tarvittavat tiedostot löytyvät automaattisesti. Voit nyt ajaa testit klikkaamalla hiiren oikeaa painiketta projektisi nimen päällä ja valitsemalla "Test". Testit eivät vielä mene läpi, joudutkin seuraavassa tehtävässä korjaamaan ne.
</p>
<h4>Testien ajaminen terminaalissa</h4>
<p>
  Laitoksen koneilla Node.js-komentoja ei pysty ajamaan NetBeansin kautta, mutta pystyt ajamaan ne terminaalissa. Siirry terminaalissa <code>TodoAppTestaaminen</code>-projektin juureen. Saat selville, missä projektikansio sijaitsee klikkaamalla NetBeansissa projektin nimen päällä hiiren oikeaa painiketta ja valitsemalla "Properties". Kopio avautuneesta ikkunasta "Project Folder"-kentän sisältö ja siirry siihen terminaalissa seuraavasti: 
</p>
<pre class="sh_javascript_dom">
cd PROJEKTIN_KANSION_POLKU
</pre>
<p>
  Korvaa vain kohtaan <code>PROJEKTIN_KANSION_POLKU</code> kopioimasi projektikansion sijainti. Kun olet siirtynyt projektikansioon, suorita siinä komento <code>npm install</code>, se asentaa tarvitsemasi riippuvuudet. Kun riippuvuudet on asennettu, voit ajaa testit projektikansion juuressa komennolla <code>./node_modules/karma/bin/karma start</code>.
</p>
<h4>karma.conf.js</h4>
<p>
  <code>karma.conf.js</code> on tiedosto, joka kertoo Karmalle mm. mitkä tiedostot ladataan selaimeen, kun testit ajetaan. Testeihin pitää ladata koko sovelluksen koodi, kaikki sen käyttämät kirjastot ja itse testit. Tiedoston sisältö voi olla esimerkiksi seuraava:
</p>
<pre class="sh_javascript_dom">
module.exports = function(config) {
  config.set({

    // annetaan tiedostojen aloituspolku (jos tyhjä, niin se on karma.conf.js tiedoston polku)
    basePath: '',


    // käytettävät sovelluskehykset
    frameworks: ['jasmine'],

    // tiedostot, jotka ladataan selaimeen, kun testit ajetaan
    files: [
        'bower_components/angular.min.js',
        'js/app.js',
        'js/controllers/*.js'
    ],


    // web-palvelimen portti, jossa testit ajetaan
    port: 9876,


    colors: true,

    config.LOG_INFO || config.LOG_DEBUG
    logLevel: config.LOG_INFO,


    // jos "true", niin Karma ajaa testit aina kun jokin "files"-kentässä määritelty tiedosto tallennetaan
    autoWatch: true,


    // testien ajamiseen käytettävä selain
    browsers: ['Chrome'],

    singleRun: false
  });
};
</pre>
<p>
  Yleensä <code>karma.conf.js</code>-tiedosto löytyy tehtäväpohjasta valmiina, mutta tulevaisuudessa tulee tehtäviä, jossa sinun täytyy määritellä se itse. Silloinkin yleensä <code>karma.conf.js</code>-tiedoston runko on valmiina, jolloin riittää vain määritellä <code>files</code>-kenttään testien ajamisen yhteydessä selaimeen ladattavat tiedostot.
</p>
<div class="tehtavat">
  <h3>Muistilistan testaaminen</h3>
  <p>
    Tehtäväpohjasta löytyy viime viikolla toteutetun muistilistasovelluksen mallivastaus, joka ei vielä käyttänyt Firebasea. Voit halutessasi korvata mallivastauksen omalla toteutuksellasi. Muistilistan testaamista veaten on toteutettu runko tiedostossa <code>app/test/todo_controller_test.js</code>, mutta testit eivät vielä meni läpi. Sinun tehtäväsi on testata testeissä muistilistan eri toimintoja ja saada testit menemään läpi. Testattavat toiminnot kuvataan kunkin testin kohdalla, <code>it</code>-funktion kutsussa, toteuta siis kuvausta vastaava testi. Jos käytät tehtäväpohjan toteutusta, aloita tutustumalla <code>TodoController</code>-kontrolleriin tiedostossa <code>app/controllers/todo_controller.js</code>. <strong>Huom! Jos lisäät tehtäväpohjaan tiedostoja tai muokkaat niiden nimiä, muista päivättää <code>karma.conf.js</code>-tiedosto, jotta lisäämäsi/muokkaamasi tiedostot ladataan selaimeen testien ajamisen yhteydessä.</strong> 
  </p>
</div>

<h2>Reititys Angularissa</h2>
<p>
  Isompi sovellus on usein jaettu useaan eri näkymään, jotka löytyvät eri poluista, kuten <code>/elokuvat</code>, <code>/elokuvat/1</code> ja <code>elokuvat/uusi</code>. Perinteisesti sovelluksen polut määritetään palvelinpuolen sovelluksessa, mutta kasva trendi on toteuttaa ainakin osa sovelluksen reitityksestä selainpuolella, jolloin sovelluksessa uuteen polkuun siirtyminen ei rasita niin paljon palvelinta. Näitä sovelluksia kutsutaan nimellä "<a href="http://en.wikipedia.org/wiki/Single-page_application">Single-page application</a>".
</p>
<h3>Single-page sovellukset</h3>
<p>
  Single-page sovelluksesissa reitityksen pääpaino on siirtynyt palvelinpuolelta selainpuolella. Mutta miksi, mitä etuja siitä on? Suurin etu on siinä, että kun käyttäjä siirtyy sovelluksessa toiseen polkuun, palvelimelta haetaan vain uuden näkymän esittämiseen vaadittava sisältö, kuten HTML-sivu tai JSON-dataa sen sijaan, että kaikki sivulla esiintyvät resurssit kuten tyyli- ja skripti-tiedostot sekä kuvat haettaisiin uudelleen. Suorituskyky etu on siis melko huomattava, jolloin näkymien välillä siirtyminen on nopeampaa. Selainpuolen reititys ei ole kuitenkaan kaikki maailman ongelmat ratkaiseva tekiä, siinä on huonojakin puolia. Selainpuolen reitit eivät välttämättä toimi kaikilla alustoilla (etenkin mobiililaitteilla) ja usein sivulla on vain yksi sisääntuloväylä, jonka kautta kaikki reitit käsitellään. 
</p>
<h3>Reittien määrittäminen Angularissa</h3>
<p>
  Angularissa reititykseen käytetään <code>ngRoute</code>-moduulia. Kuten moduulit yleensä, ennen kuin sitä pääsee käyttämään, se täytyy injektoida omaan moduuliisi:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);
</pre>
<p>
  Se on siinä! Injektoin <code>ngRoute</code>-moduulin muiden moduulien tapaan lisäämällä sen nimen moduulin alustamiskutsun toisena parametrina olevaan taulukkoon. Itse reititys tapahtuu konfiguroimalla <code>ngRoute</code>-moduulin komponenttia <code>$routeProvider</code>. Se onnistuu seuraavasti:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);

App.config(function($routeProvider){
  $routeProvider
    .when('/', {
      controller: 'HomeController',
      templateUrl: 'templates/home.html'
    })
    .when('/hello', {
      controller: 'HelloController',
      templateUrl: 'templates/hello.html'
    })
    .otherwise({
      redirectTo: '/'
    });
});
</pre>
<p>
  Lisäämme konfiguraatiossa <code>$routeProvider</code>-komponentin kautta sovellukseemme kaksi reittiä <code>/</code> ja <code>/hello</code> kutsumalla sen funktiota <code>when</code>. Kuten huomaat, funktiokutsuja voi ketjuttaa. Funktio <code>when</code> ottaa parametrikseen polun merkkijonona ja objektin, joka kertoo, mitä tulee tapahtua, kun käyttäjä siirtyy sovelluksessa ensimmäisenä parametrina annettuun polkuun. Objekti sisältää kentän <code>controller</code>, joka kertoo, mikä kontrolleri otetaan reitissä käyttöön ja kentän <code>templateUrl</code>, joka kertoo, mitä näkymätiedostoa käytetään. Ketjun viimeisessä funktiokutsussa kutsutaan funktiota <code>otherwise</code>, joka kertoo, mitä tehdään, jos käyttäjä siirtyy polkuun, jota ei ole määritelty <code>when</code>-funktioiden kutsuissa. Funktio <code>otherwise</code> ottaa parametrikseen objektin, jossa yleensä määritetään kenttä <code>redirectTo</code>, joka kertoo, mihin polkuun käyttäjä ohjataan, jos hän yrittää mennä polkuun, jota ei ole määritelty.
</p>
<p>
  Kontrollerin määrittäminen ei ole pakollista, jos haluat esittää polussa käyttäjälle pelkästään staattisen näkymän. <code>templaUrl</code>-kentän sijaan voi määrittää kentän <code>template</code>, jonka arvo on tiedoston sijaan merkkijono, joka sisältää näkymän sisällön HTML-elementteineen. <code>template</code>-kentän määrittäminen <code>templateUrl</code>-kentän sijaan periaatteessa parantaa hieman sovelluksen suorituskykyä, koska näkymätiedostoa ei tarvitse hakea palvelimelta, mutta isojen näkymien esittäminen merkkijonona on todella sekavaa.
</p>
  Liitetään moduulimme kontrollerit <code>HomeController</code> ja <code>HelloController</code>, joihin reiteissä viittaamme:
</p>
<pre class="sh_javascript_dom">
App.controller('HomeController', function($scope){
  $scope.message = 'Olet etusivulla!';
});

App.controller('HelloController', function($scope){
  $scope.message = 'Olet hello sivulla! Hello World!';
});
</pre>
<p>
  Tarvitsemme vielä reiteissä viitatut näkymätiedostot <code>home.html</code> ja <code>hello.html</code>. Tarvitsemme kuitenkin sitä ennen pohjatiedoston, johon näkymät upotetaan, joka on yleensä nimeltään <code>index.html</code>: 
</p>
<pre class="sh_html">
&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body ng-app="MyApp"&gt;
    &lt;a href="#"&gt;Etusivu&lt;a&gt; | &lt;a href="#/hello"&gt;Hello&lt;a&gt;
    &lt;h1&gt;Kallen Single-page sovellus&lt;/h1&gt;
    &lt;div ng-view&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</pre>
<p>
  Pohjatiedostossa määrittelemme moduulimme <code>ng-app</code>-attribuutissa. Lisäksi pohjatiedostossa määritellään, mihin reiteissä määritellyt näkymätiedostot upotetaan. Se tapahtuu lisäämällä <code>ng-view</code>-attribuutti DOM-elementille, jonka sisään näkymätiedostojen sisältö halutaan lisätä. 
</p>
<p>
  Jos olit tarkkana, huomasit myös, että lisäsin pohjatiedostoon pienen navigaation, joka hyvä lisätä juuri pohjatiedostoon, koska navigaatio esiintyy joka sivulla. Navigaation linkit eroavat kuitenkin <code>href</code>-attribuutin arvon osalta hieman. On tärkeää, että linkin kohde on muotoa <code>#/hello</code>, eikä <code>/hello</code>. Ero on siinä, että <code>#</code>-alkuiset kohteet ovat nk. sivun sisäisiä linkkejä, eli niihin siirtyminen ei aiheuta pyyntöä palvelimelle, vaan kohteen käsittely jää selainpuolen sovelluksen tulkittavaksi. Tämä mahdollistaa selainpuolella tapahtuvan reitityksen. 
</p>
<p>
  Nyt, jos käyttä klikkaa linkkiä "Hello", selaimen osoiteriivin ilmestyy sivuston url:in jatkeeksi <code>/#hello</code>, eikä käyttäjä poistu sivulta, vaan selainpuolen sovellus (meidän Angular-sovelluksemme) päättää, mitä tehdään. Olemme määrittäneet <code>$routeProvider</code>-komponentissa, että polussa <code>/hello</code> otetaan käyttöön kontrolleri <code>HelloController</code> ja näytetään näkymä <code>hello.html</code>. Näkymän <code>hello.html</code> sisältö voisi olla vaikka seuraava:
</p>
<pre class="sh_html">
&lt;h2&gt;Hello sivu&lt;/h2&gt;
{{message}}
</pre>
<p>
  Huomaa, ettei näkymätiedostossa tarvitse määrittää <code>html</code>- ja <code>body</code>-tageja, koska tiedoston sisältö upotetaan pohjatiedoston <code>div</code>-elementin sisään, jolla on <code><a href="https://docs.angularjs.org/api/ngRoute/directive/ngView" target="_blank">ng-view</a></code>-attribuutti. 
</p>
<p>
  Tässä vielä tähän astinen toteutuksemme (huomaa, etten voi jsFiddlessä määrittää näkymätiedoston polkua, joten joudun laittamaan näkymän sisällön suoraan reitin määritykseen):
  <iframe width="100%" height="300" src="http://jsfiddle.net/Mh2UH/15/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<div class="tehtavat">
  <h3>PerusMOOC reiteillä</h3>
  <p>
    Tehtäväpohjan mukana tulee viikolla 1 toteutetun PerusMOOC-tehtävän runko ja sivupohjat sivuille "PerusMOOC", "Materiaali" ja "Oma etenemiseni". Muokkaa tehtäväpohjaa niin, että etusivun sisältönä (polussa <code>#/</code>) näytetään "PerusMOOC"-sivupohja, polussa <code>#/materiaali</code> "Materiaali"-sivupohja ja polussa <code>#/oma-etenemiseni</code> "Oma etenemiseni"-sivupohja. Muista injektoida <code>ngroute</code>-moduuli omaan moduulisi, jotta pääset määrittämään sovelluksesi reitit konfiguroimalla <code>$routeProvider</code>-komponenttia. Tee <code>$routeProvider</code>-komponenttiin liittyvät konfiguraatiot tiedostossa <code>app/app.js</code>, jossa itse moduuli sijaitsee. Tarvittavat kontrollerit voit luoda <code>app/controllers</code> kansioon. <strong>Muista linkittää luomasi <code>js</code>-tiedostot <code>index.html</code>-näkymässä <code>script</code>-tagien avulla!</strong>. Näkymätiedostot <code>etusivu.html</code>, <code>materiaali.html</code> ja <code>etenemiseni.html</code> löytyvät kansiosta <code>app/views</code>. 
  </p>
</div>
<h4>Polkujen parametrit</h4>
<p>
  Sovelluksen polun kautta halutaan usein välittää tietoa. Jos meillä on esimerkiksi sovellus, joka esittää käyttäjän profiilisivun, haluamme, että profiilisivulle pääse esimerkiksi polun <code>#/kayttaja/KAYTTAJANIMI</code>-kautta, jossa <code>KAYTTAJANIMI</code> on käyttäjän nimi. Kun käyttäjä tällöin siirtyy sovelluksessa esimerkiksi polkuun <code>#/kayttaja/kalle</code>, voimme hakea tietokannasta (esim. Firebasesta) käyttäjän "kalle" tiedot ja esittää ne profiilisivulla.
</p>
<p>
  Angularissa voimme helposti upottaa polkuihin nk. polkuparametreja, joiden sisältö vaihtelee käyttäjän antaman polun perusteella. Katsotaan, miten voisimme upottaa käyttäjän nimen polkuun <code>#/kayttaja/KAYTTAJANIMI</code>:
</p>
<pre class="sh_javascript_dom">
var App = angular.module('MyApp', ['ngRoute']);

App.config(function($routeProvider){
  $routeProvider
    .when('/kayttaja/:username', {
      controller: 'UserController',
      templateUrl: 'templates/profile.html'
    });
});
</pre>
<p>
  Määrittelemme sovelluksemme reitit tavalliseen tapaan konfiguroimalla <code>ngRoute</code>-moduulin <code>$routeProvider</code>-komponenttia. Tällä kertaa funktiossa <code>when</code> määritelty polku näyttää tosin hieman erinlaiselta, sillä siihen on upotettu parametri <code>username</code>. Parametrin upotus polkuun tapahtuu yksinkertaisesti syntaksilla <code>:parametrinNimi</code>, eli <code>:</code> ja nimi parametrille, jonka kautta voimme hakea sen arvon. Nyt polussa <code>#/kayttaja/arto</code> parametrin <code>username</code> arvo on "arto". Katsotaan, miten voimme käyttää polkumme <code>username</code> parametria määrittelemällä kontrolleri <code>UserController</code>:
</p>
<pre class="sh_javascript_dom">
App.controller('UserController', function($scope, $routeParams){
  var users = {
    'arto': {
      name: 'Arto',
      friends: ['Kalle', 'Matti']
    },
    'kalle': {
      name: 'Kalle',
      friends: ['Elina', 'Arto', 'Matti']
    },
    'elina': {
      name: 'Elina',
      friends: ['Kalle']
    },
    'matti': {
      name: 'Matti',
      friends: ['Arto', 'Kalle']
    }
  }

  if(users[$routeParams.username.toLowerCase()]){
    $scope.user = users[$routeParams.username.toLowerCase()];
  }else{
    $scope.user = null;
  }
});
</pre>
<p>
  Huomasit varmaan, että kontrolleriin on injektoitu <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>-muuttuja. Se on objekti, joka sisältää kenttinä kaikki nykyiseen polkuun liittyvät parametrit. <code>username</code>-parametrin arvo on siis <code>$routeParams.username</code>. Voimme käyttää polkuparametrin arvoa, esimerkiksiä määrittämään, minkä käyttäjän profiili esitetään näkymässä, kuten yllä on tehty. Toteutaan vielä näkymä <code>profile.html</code>, jotta saamme homman pakettiin:
</p>
<pre class="sh_html">
&lt;h2&gt;Käyttäjän {{user.name}} profiili&lt;/h2&gt;
Kaverit:
&lt;ul ng-repeat="friend in user.friends"&gt;
  &lt;li&gt;&lt;a ng-href="#/kayttaja/{{friend}}"&gt;{{friend}}&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</pre>
<p>
  Huomaa, että linkeissä kannattaa käyttää <code><a href="https://docs.angularjs.org/api/ng/directive/ngHref" target="_blank">ng-href</a></code>-attribuuttia perinteisen <code>href</code>-attribuutin sijaan, muuten voi käydä niin, että linkin <code>href</code>-attribuutti asetetaan ennen kuin muuttujat ovat latautuneet. Tällöin esimerkiksi linkin polku voisi olla <code>#/kayttaja/{{friend}}</code> polun <code>#/kayttaja/elina</code> sijaan.
</p>
<p>
  Tässä vielä lopputulos:
  <iframe width="100%" height="300" src="http://jsfiddle.net/Mh2UH/18/embedded/result,js,html" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
</p>
<h4>Polkujen käsittely kontrollereissa</h4>
<p>
  Sovelluksen polkuja pystyy käsittelemään monin tavoin kontrollereissa. Tärkein palvelu polkujen käsittelyyn on <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelu. Yksi sen tärkeimmistä toiminnoista on käyttäjän ohjaaminen toiseen polkuun käyttäen <code>path</code>-funktiota:
</p>
<pre class="sh_javascript_dom">
App.controller('UserController', function($scope, $routeParams, $location){
  var users = {
    'arto': {
      name: 'Arto',
      friends: ['Kalle', 'Matti']
    },
    'kalle': {
      name: 'Kalle',
      friends: ['Elina', 'Arto', 'Matti']
    },
    'elina': {
      name: 'Elina',
      friends: ['Kalle']
    },
    'matti': {
      name: 'Matti',
      friends: ['Arto', 'Kalle']
    }
  }

  if(users[$routeParams.username.toLowerCase()]){
    $scope.user = users[$routeParams.username.toLowerCase()];
  }else{
    $location.path('/kayttajat/kalle');
  }
});
</pre>
<p>
  Lisäsin siis kontrollerin <code>if</code>-ehdon <code>else</code>-haaraan ohjauksen polkuun <code>#/kayttaja/kalle</code> (huomaa, ettei polun eteen tarvitse laittaa <code>#</code>-merkkiä!). Nyt jos käyttäjää ei löydy, ohjataan käyttäjä polkuun <code>#/kayttaja/kalle</code>, eli käyttäjän "Kalle" profiilisivulle. Tapa muistuttavaa hyvin paljon palvelinohjelmissa tehtävää uudelleenohjausta. <code>$location</code>-palvelua käytetään myös hyvin paljon selaimen osoitepalkin sisällön tarkkailuun. Esimerkiksi, jos haluamme koko tähän hetkisen url:in (esim. http://cs.helsinki.fi/courses), voimme kutsua <code>absUrl</code>-funktiota ja jos haluamme vain pyynnön osan (esim. /courses), voimme kutsua <code>url</code>-funktiota.
</p>
<div class="tehtavat">
  <h3>Kuin kissat ja koirat</h3>
  <p>
    Tehtäväpohjassa on määritelty palvelut <code>Cat</code> (tiedostossa <code>app/services/cat.js</code>) ja <code>Dog</code> (tiedostossa <code>app/services/dog.js</code>), jotka molemmat tarjoavat funktion <code>all</code>, joka paluttaa taulukon kissoja, tai koiria, riippuen kumman palvelun funktiota kutsutaan. Toteuta kontrollerit <code>ListController</code> (pohja tiedostossa <code>app/controllers/list_controller.js</code>), joka listaa etusivulla (polussa #/) kaikki kissat sekä koirat ja <code>CatController</code> (pohja tiedostossa <code>app/controllers/cat_controller.js</code>), joka näyttää polussa <code>#/kissat/ROTU</code> polkuparametrin <code>ROTU</code>-arvonana (vinkki: <code><a href="https://docs.angularjs.org/api/ngRoute/service/$routeParams" target="_blank">$routeParams</a></code>) annetun kissarodun tiedot seuraavasti:
  </p>
  <h1 class="ignore">Eksoottinen lyhytkarva</h1>
  <p>
    Eksoottisen lyhytkarvan turkki on tiheä ja samettisen pehmeä, luonne koiramaisen seurallinen. Rakenne on roteva ja litteänaamainen kuten persialaisella. Rotumääritelmä on turkin pituutta lukuun ottamatta yhtenevä persialaisen rotumääritelmän kanssa.
  </p>
  <p>
    Sivun otsikko on siis kissarodun nimi ja sen alla on sen kuvaus. Toteuta myös kontrolleri <code>DogController</code> (pohja tiedostossa <code>app/controllers/dog_controller.js</code>), joka näyttää polussa <code>#/koirat/ROTU</code> polkuparametrin <code>ROTU</code>-arvonana annetun koirarodun tiedot samaan tapaan kuin kissojen kanssa. <code>$routeProvider</code>-komponenttiin liittyvät konfiguraatiot kannattaa tehdä tiedostossa <code>app/app.js</code> ja näkymätiedostot voi sijoittaa vaikkapa kansioon <code>app/views</code>. 
  </p>
  <p>
    Jos käyttäjä yrittää mennä kissa- tai koirarodun sivulle, jota ei löydy, ohjaa hänet takaisin etusivulle käyttäen <code><a href="https://docs.angularjs.org/api/ng/service/$location" target="_blank">$location</a></code>-palvelua.
  </p>
  <p>
    Kun tehtävä on tehty, voit vaikappa katsoa upen koko perheen elokuvan <a href="http://www.imdb.com/title/tt0239395/" target="_blank">Kuin kissat ja koirat</a>.
  </p>
</div>
<h2>Kehitystyökalut</h2>
<p>
  JavaScriptiin on toteutettu parin viime vuoden aikana tolkuttoman monta eri kehitystyökaluja ja trendit niiden käytön kanssa vaihtelevat melkein kuukausittain. Käymme seuraavaksi läpi vain pari tärkeintä työkalua, jotka ovat luultavasti joidenkin hipsterien mielestä jo todella vanhanaikaisia.
</p>
<h3>Järkevää riippuvuuksien hallintaa: Bower</h3>
<p>
  JavaScript sovellukset ja kirjastot ovat nykyään yhä enemmän riippuvaisia toisista kirjastoista, jotka ovat edelleen riippuvaisia toisista kirjastoista. Riippuvuuksien hallinta oli ennen hankalaa, sillä kirjastojen dokumentaatiossa piti erikseen mainita, mitä riippuvuuksia niissä on ja ohjelmoijan piti itse etsiä riippuvuuksien lähdekoodi ja linkittää ne sovellukseen. Nykyään riippuvuuksien hallinta on onneksi todella helppoa, kiitos <a href="http://bower.io/" target="_blank">Bowerin</a>.
</p>
<p>
  Bower etsii ja asentaa tarvitsemasi kirjastot puolestasi. Lisäksi se pitää kirjaa sovelluksesi riippuvuuksista <code>bower.json</code>-tiedostossa, jotta muut voivat tarvittaessa asentaa sovelluksesi käyttämät riippuvuudet, kun he haluavat käyttää sovellustasi. Aloitetaan hieman tarkempi tutustuminen siihen ja katsotaan, miten voimme käyttää sitä NetBeansissa. Bower vaatii toimiakseen <a href="http://git-scm.com/" target="_blank">Gitin</a> ja <a href="http://nodejs.org/" target="_blank">Noden</a>. Jos asensit molemmat viime viikolla testaamisen yhteydessä, olet jo valmis. Jos ne on vielä asentamatta lue asentamisohjeet kohdasta Testien suorittaminen.
</p>

<h4>Kirjastojen asentaminen</h4>
<p>
  Avataan edellisen tehtävän <code>KuinKissatJaKoirat</code>-projekti NetBeansissa ja katsotaan, mitä riippuvuuksia sillä on avaamalla <code>bower.json</code>-tiedosto kansiosta <code>Important Files</code>. Sen sisältö on seuraava:
</p>
<pre class="sh_javascript_dom">
{
  "name": "weso",
  "version": "0.0.0",
  "authors": [],
  "license": "MIT",
  "dependencies": {
    "angular": "~1.3.13",
    "angular-route": "~1.3.13"
  }
}
</pre>
<p>
  Tiedostoston alku koostuu sovelluksemme perustiedoista, kuten sen nimestä, versiosta ja lisenssistä. Sen jälkeen kerrotaan, mitä riippuvuuksia sovelluksessamme on, ne ovat <code>angular</code> ja reititykseen käyttämämme <code>angular-route</code>. Numerosarja riippuvuuden nimerän jälkeen on sen versionumero. Asennetaan seuraavaksi pari riippuvuutta, vaikkapa jQuery ja Mustache. Jokaisella kirjastolla on Bowerin rekistereissä oma nimensä, mutta en ole aivan varma, millä nimellä jQuery ja Mustache löytyvät. Voin tarkastaa asian helposti <a href="http://bower.io/search/" target="_blank">täältä</a>. Ilmeisesti jQuery löytyy nimellä <code>jquery</code> ja Mustache nimellä <code>mustache</code> (yllätys, yllätys!). Määritellään <code>bower.json</code>-tiedostoon kenttä <code>dependencies</code> ja määritellään siihen, että haluamme asentaa sovellukseemme viimeisimmät versiot <code>jquery</code>- ja <code>mustache</code>-kirjastoista: 
</p>
<pre class="sh_javascript_dom">
{
  "name": "weso",
  "version": "0.0.0",
  "authors": [],
  "license": "MIT"
  "dependencies": {
    "angular": "~1.3.13",
    "angular-route": "~1.3.13"
    "jquery": "latest",
    "mustache": "latest"
  }
}
</pre>
<p>
  Lisäämällä <code>dependencies</code>-kentän sisältävään objektiin kentät <code>jquery</code> ja <code>mutache</code>, joiden arvo on "latest", saamme asennettua niiden viimeisimmät versiot Bowerin rekistereistä. Riippuvuuksien määrittely on nyt valmis, seuraava vaihe on niiden asentaminen. Se on NetBeansissa helppoa, painetaan vain projektimme nimen päällä hiiren oikeaa painiketta ja valitaan "Npm install", joka asentaa Bowerin ja sen jälkeen valitsemalla "Bower install", joka asentaa asettamamme riippuvuudet <code>jquery</code> ja <code>mustache</code>. Jos käytät laitoksen konetta, suorita terminaalissa NetBeans-projektin juuressa ensin komento <code>npm install</code> ja sen jälkeen komento <code>./node_modules/bower/bin/bower install</code>. Kommennon suorittamisen jälkeen <code>bower_components</code>-kansioon ilmestyy kansiot <code>mustache</code> ja <code>jquery</code>, joista löytyy tarvitsemamme riippuvuudet, joita voimme nyt käyttää sovelluksessamme.
</p>
<h3>Väsymätön työnsankari: Grunt</h3>
<p>
  Ohjelmoijalla on sovellusta kehittäessä usein monta pientä tehävää, jotka pitää toistaa tiuhaan tahtiin. Tehtävät voivat olla joko, skripti- tai tyylitiedostojen yhdistämistä ja pakkaamista, testien automaattista suorittamista, tai lähdekoodin auttomaattista siirtämistä versionhallinta. Kaikki näistä tehtävistä ovat melko työläitä, etenkin kun ne pitää suorittaa manuaalisesti tiuhaan tahtiin. Ratkaisu ongelmaan on JavaScriptin ikioma tehtäviensuorittaja, <a href="http://gruntjs.com/" target="_blank">Grunt</a>, joka suorittaa määrittämiäsi tehtäviä puolestasi aina, kun haluat.
</p>
<h4>Töihin siitä, Grunt!</h4>
<p>
  Grunttiin on toteutettu monta <a href="http://gruntjs.com/plugins" target="_blank">pluginia</a>, joiden avulla sille voi määritellä eri tehtäviä eli "taskeja". Taskien määrittely tapahtuu projektin juuressa sijaitsevassa <code>Gruntfile.js</code>-tiedostossa, jossa pluginit ladataan ja niiden tarjoamat taskit konfiguroidaan tarpeidesi mukaisiksi. Tässä esimerkki <code>Gruntfile.js</code>-tiedostosta, jossa käytetään <a href="https://www.npmjs.com/package/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>-pluginia minimoimaan kasa JavaScript-tiedostoja yhdeksi kompaktiksi tiedostoksi, josta ne kaikki löytyvät pakatusssa muodossa:
</p>
<pre class="sh_javascript_dom">
module.exports = function(grunt) {

  // Konfiguroidaan taskit
  grunt.initConfig({
    // uglify-plugini
    uglify: {
      build: {
        src: ['app/app.js', 'app/services/*.js', 'app/controllers/*.js'],
        dest: 'app/app.min.js'
      }
    }
  });

  // Ladataan plugini "grunt-contrib-uglify", joka tarjoaa taskin "uglify"
  grunt.loadNpmTasks('grunt-contrib-uglify');

  // Asetetaan suoritettava oletustaski, joka on tässä tapauksessa "uglify"
  grunt.registerTask('default', ['uglify']);
};
</pre>
<p>
  Annamme <code>initConfig</code>-funktiolla parametriksi objektin, jossa määrittelemme taskiemme konfiguraatiot. <code>grunt-contrib-uglify</code>-plugin tarjoaa taskin <code>uglify</code>, jonka avulla pystymme minimoimaan JavaScript-tiedostoja. Se on kätevää, koska sivunlataus nopetuu huomattavasti, jos <code>script</code>-tageja on sivulla monen sijaan yksi. <code>uglify</code>-taskin konfiguroinnissa kerromme, että haluamme minimoida tiedoston <code>app/app.js</code> ja kaikki <code>js</code>-tiedostot kansioista <code>app/services</code> ja <code>app/controllers</code> tiedostoon <code>app/app.min.js</code>. Konfiguroinnin jälkeen lataamma pluginit käyttöömme ja asetamme gruntin oletus taskit. Tässä tapauksessa, kun Grunt aloittaa työn projektimme parissa komennolla <code>grunt</code>, suoritetaan vain taski <code>uglify</code>.
</p>
<p>
  Voimme suorittaa samaan aikaan monta taskia. Otetaan vielä käyttöön <a href="https://www.npmjs.com/package/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>-plugini, joka tarjoaa taskin <code>jshint</code>, joka validoi JavaScript-koodia ja ilmoittaa meille löytämänsä syntaksivirheet:
</p>
<pre class="sh_javascript_dom">
module.exports = function(grunt) {

  // Konfiguroidaan taskit
  grunt.initConfig({
    // uglify-plugini
    uglify: {
      build: {
        src: ['app/app.js', 'app/services/*.js', 'app/controllers/*.js'],
        dest: 'app/app.min.js'
      }
    }
    jshint: {
      src: ['app/**/**.js']
    }
  });

  // Ladataan plugini "grunt-contrib-uglify", joka tarjoaa taskin "uglify"
  grunt.loadNpmTasks('grunt-contrib-uglify');
  grunt.loadNpmTasks('grunt-contrib-jshint');

  // Asetetaan suoritettavat oletustaskit, jotka ovat "jshint" ja "uglify"
  grunt.registerTask('default', ['jshint', 'uglify']);

  // Asetetaan "hint"-ryhmässä suoritettavat taski
  grunt.registerTask('hint', ['jshint']);
};
</pre>
<p>
  Otimme siis käyttöömme taskin <code>jshint</code>, joka etsii syntaksivirheitä kaikista <code>app</code>-kansion alakansioista sijaitsevista <code>js</code>-tiedostoista. Määritimme myös, että <code>jshint</code>-taski suoritetaan oletustaskina ja lisäksi, että sen voi suorittaa ilman erikseen komennolla <code>grunt hint</code>.
</p>
<p>
  Seuraavassa tehtävässä pääset käyttämään Grunttia. Jos et asentanut testaamisen yhteydessä Node.js:ssää ja Git:iä, tee se nyt. Ohjeet löytyvät osiosta Testien suorittaminen. Kun asennus on tehty, avaa NetBeans ja siinä tämän viikon tehtävistä tehtävä <code>GruntToihin</code>. Klikkaa projektin nimen päällä hiiren oikeaa painiketta ja valitse "Npm install", se asentaa tarvitsemasi riippuvuudet, mukaan lukien Gruntin. Sen jälkeen paina taas projektisi nimen päällä hiiren oikeaa painiketta ja valitse "Properties" ja siirry avautuvasta ikkunasta "Grunt"-kategoriaan. Voit valita, milloin Gruntin taskit suoritetaan valitsemalla jonkun kolmesta vaihtoehdosta ja syöttämällä sen viereiseen tekstikenttään, minkä ryhmän taskit suoritetaan (esimerkiksi "default"). Jos käytät laitoksen konetta, voit suorittaa Gruntin taskit terminaalissa NetBeansin-projektin juuressa suorittamalla ensin komennon <code>npm install</code> ja sen jälkeen komennon <code>node -e "require('grunt').cli();"</code>.
</p>
<div class="tehtavat">
<h3>Laitetaan Grunt töihin</h3>
<p>
  Arto on toteuttanut eeppisen kokeisen sovelluksen, mutta hänellä on sen kanssa pari pientä ongelmaa. Ensinäkin, Matti valitti, että Arton sovellus lataa palvelimelta aivan turhan monta <code>js</code>-tiedostoa ja antoikin vinkiksi, että Gruntilla JavaScript tiedostot voi yhdistää yhdeksi kompaktiksi <code>js</code>-tiedostoksi käyttäen <a href="https://www.npmjs.com/package/grunt-contrib-uglify" target="_blank">grunt-contrib-uglify</a>-pluginia. Sama ongelmalla Artolla on <code>css</code>-tiedostojen kanssa. Siihen soveltuu Matin mukaan <a href="https://www.npmjs.com/package/grunt-contrib-cssmin" target="_blank">grunt-contrib-cssmin</a>-plugini. Lisäksi Artolla on koodissaan syntaksivirhe, jota hän ei millään löydä. Hän tietää, että sen löytämiseen voi käyttää <a href="https://www.npmjs.com/package/grunt-contrib-jshint" target="_blank">grunt-contrib-jshint</a>, mutta hän tarvitsee apua sen konfigurointiin. Voitko auttaa artoa?
</p>
<p>
  Tehtäväpohjan mukana <code>Important Files</code>-kansiosta löytyy pohja <code>Gruntfile.js</code>-tiedostolle, johon sinun täytyy tehdä tarvittavat muutokset. Aloita suorittamalla komento <code>npm install</code> joko NetBeansissa tai terminaalissa projektisi juuressa, joka asentaa Gruntin. Kun Grunt on asennettu, siirry klikkaa projektisi nimen päällä hiiren oikeaa painiketta ja valitse "Properties". Siirry avautuvasta ikkunasta vasemmalta kohtaan "Grunt" ja valitse checkboxi "Build Project" ja kirjoita sen vieressä olevaan tekstikenttään "default" (ilman lainausmerkkejä). Nyt Grunt ajaa projektin buildaamisen yhteydessä kaikki taskit ryhmässä <code>default</code>, jotka määritellään <code>Gruntfile.js</code>-tiedostossa. Laitoksen koneella voit ajaa Gruntin suorittamalla terminaalissa NetBeans-projektisi juuressa komennon <code>node -e "require('grunt').cli();"</code>. Toteuta <code>Gruntfile.js</code>-tiedosto, niin, että Grunt suorittaa taskit <code>uglify</code>, <code>cssmin</code> ja <code>jshint</code> seuraavasti:
  <ul>
    <li>
      <code>jshint</code>-taski etsii syntaksivirheitä kaikista <code>app/controllers</code> kansiosta sijaitsevista <code>js</code>-tiedostoista. Löydä siis Arton tekemät syntaksivirheet ja korjaa se niin, että <code>jshint</code> on tyytyväinen.
    </li>
    <li>
      <code>uglify</code>-taski yhdistää tiedoston <code>app/app.js</code> sekä kaikki <code>js</code>-tiedostot kansioista <code>app/controllers</code>, <code>app/services</code> ja <code>app/directives</code> tiedostoon <code>app/app.min.js</code>.
    </li>
    <li>
      <code>cssmin</code>-taski yhdistää kaikki <code>css</code>-tiedostot kansiosta <code>css/common</code> tiedostoon <code>css/app.min.css</code>
    </li>  
  <ul>
</p>
</div>
</section>
<section class="week">
  <header>
    <a name="viikko6"></a>
    <h1 data-week-id="6">Viikko 6</h1>
  </header>
</section>
<section class="week">
  <header>
    <a name="viikko7"></a>
    <h1 data-week-id="7">Viikko 7</h1>
  </header>
</section>
        </article>


</body>
</html>
